TODO: Vyzkoušet npm/mixin

-----------------------------------------------------------------------

TODO: Rozhodnout dilema s pojmeovávání class:

/Shared/SharedClass
/Client/Class
/ServerClass

nebo

/Shared/Class
/Client/ClientClass
/Server/ServerClass

- První varianta může být trochu matoucí při find-in-files (jsem na serveru
  nebo na klientu?)
- ale dává smysl při posílání mezi klientem a serverem
  (classy by se jmenují stejně, tudíž se vzájemně serializují/deserializují).
- Navíc SharedCosi zní jako "sdílená část čehosi", což je intuitivní význam.



-----------------------------------------------------------------------

TODO: Zvážit, jestli nějak nerozlišit incoming a outgoing packety
  (asi různé adresáře na klientu a na serveru).
Anser: Nepotřebuju víc adresářů, řeší to dědičnost.

  shared/packet
  client/incomingPacket
  client/outgoingPacket
  server/incomingPacket
  server/outgoingPacket

  nebo

  client/packet/in
  client/packet/out

  client/packet/incoming
  client/packet/outgoing

Respektive jinak: Možná to není otázka adresářů, ale dědičnosti.
  - outgoing packety například asi nepotřebují metodu process().
    Aha, jasně, na BNextu jsem to měl zděděné z Reuqest a Response.
    Ale Packet měl metodu process s error messagem v body, což
    asi není dobře - měl jsem zpracovávat Requesty a posílat Responsy.
  - možná rootovej Packet vůbec není potřeba.

Takže otázka zní: Pojmenovat ancestory Request a Response, nebo IncommingPacket
  a OutgointPacket?
  - incoming/outgoing mění význam podle toho, jestli jsem na serveru nebo
    na klientu. To by mohlo mást...
  - na druhou stranu třeba SceneUpdate není ani Request, ani Response. Na nic
    totiž neresponduje, server ho posílá automaticky.
- incoming/outgoing je asi dobrý v tom, že je jasný, že incoming má mít metodu
  process a outgoing ne.
- Response by asi šla zdědit z outgoingPacketu - hmm, vlastně nešla, protože
  na serveru je outgoing a na clientu incoming. To bude možná problém...

TODO: Upravit dědičnost packetů (nejspíš zrušit Packet a nahradit ho dvojicí
  IncomingPacket/OutgointPacket).
  - hmm, možná tady byl problém s křížovým děděním, Response/Request mají
    taky nějaké sdílené vlastnosti a nedají se jednoduše zdědit
    z Incoming/Outgoing packetu. Možná to vyřešit propertou:
    RegisterRequest by byl například zděděnej z OutgoingPacketu a měl property
    requestData: RegisterRequestData.

Hmm, ono to možná vůbec nepůjde.
  Pokud mám třeba SharedPlayerInput, v něm něco, co chci zdědit, a z toho
  zdědím /Client/PlayerInput a /Server/PlayerInput, tak na clientu
  je to outgoing packet a na serveru incomming.
- což jsem zas u toho, že by všecha sdílená data toho packetu musela být
  pověšená pod IncomingPacket/OutgoingPacket coby .data: PlayerInputData.

Je fakt, že když bych měl PlayerInputData, tak bych k tomu nemusel dělat
  client a server verzi (všechna data v packetu jsou shared).
  Na druhou stranu by mi ale nic neohlídalo, že v client i server verzi
  packetu mám property data: PlayerInputData - na to bych ty packety
  musel dědit z nějakého interfacu (což bych ale asi mohl).

Takže bych měl:
  /Shared/IncomingPacket
  /Shared/OutgoingPacket
  /Shared/PlayerInputData
  /Shared/PlayerInputInterface

  a k tomu:

  /Client/PlayerInput
    class PlayerInput extends OutgoingPacket implements PlayerInputInterface
    {
    }

  a na serveru obdobu.

- Problém to úplně neřeší, protože pořád můžu zapomenout napsat to
  'implements PlayerInputInterface' a tudíž mě nic neohlídá, ale
  asi je to lepší než nic...


-----------------------------------------------------------------------

TODO: Přejmenovat adresáře Client/js, Server/js, atd. (na CamelCase)

TODO: Zamyslet se, jestli by se nedaly enumy nahradit stringama
- na druhou stranu by se pak posílalo o dost víc dat po síti, což
  asi nechci. Takže v případě paketů zůstanu raději u enumů.
  (Na druhou stranu u stringových typů šlo nějak zajistit, že jsem
   vyčerpal všechny možnosti - to je fajn.)
- otázka je, jestli by nešlo tu kontrolu intelisensem dělat i u enumů
  (TODO: Nastudovat to a vyzkoušet).

TODO: Zjistit, co mi to tam chodí za system message.

TODO: Asi sloučit classy Client a KosmudClient, Server a KosmudServer.

TODO: Serializable by nemělo nic vědět o entitách.

TODO: Klikání na objekty ve hře:
  You could do this using Query.point giving a mouse position and
  Composite.allBodies(engine.world). This will give you a list of
  bodies under the mouse.

Ok, seriózní TODO: Zprovoznit pohyb lodě tak, že na serveru to bude physics
  body v matter.js a na klienta se bude posílat aktuální pozice a rotace.
- importnout na serveru Matter.js
  [done]
- vytvořit testovací body pro ship
  [done]
- nasimulovat wsad (speed, rotation, position).
  (Zatím nic moc, ale tohle teď skipnu, s tím si bude lepší hrát s vizuální
   odezvou.)
- ukrást websockety z BrutusNext
[done]
- ukrást Serializable z BrutusNext
[done]
- posílat pozici a rotaci a zobrazovat to na klientu.
- posílat keyboard eventy (nejspíš už přeložené na herní akce?)


npm install --save @types/matter-js


Note that Matter.Runner is not yet supported in nodejs, so you'll need your own game loop.

      var Matter = require('matter-js/build/matter.js');

      var engine = Matter.Engine.create();

      var boxA = Matter.Bodies.rectangle(400, 200, 80, 80);
      var boxB = Matter.Bodies.rectangle(450, 50, 80, 80);
      var ground = Matter.Bodies.rectangle(400, 610, 810, 60, { isStatic: true });

      Matter.World.add(engine.world, [boxA, boxB, ground]);

      console.log('boxA', boxA.position);
      console.log('boxB', boxB.position);

      for (var i = 0; i < 100; i++) {
          Matter.Events.trigger(engine, 'tick', { timestamp: engine.timing.timestamp });
          Matter.Engine.update(engine, engine.timing.delta);
          Matter.Events.trigger(engine, 'afterTick', { timestamp: engine.timing.timestamp });
      }

      console.log('boxA', boxA.position);
      console.log('boxB', boxB.position);





https://github.com/Lightnet/project-phaser3-matterjs
https://gamedevacademy.org/phaser-3-tutorial/
https://github.com/liabru/matter-js/wiki/Tutorials
http://docs.lance.gg/r3.0.0/tutorial-spaceships.html
tilemapy a matter.js: https://www.mikewesthad.com/blog.html
---

TODO: Objekty ve scéně by měly být v classe, která se celá
  nainstancuje ve Scene.create(), ať nemusím testovat, jestli to existuje.
  - problém je, že některé věci se vyrábí v preloadu...
    Preload s konkrétními sprity nesouvisí - z jedné textury se dá vyrobit
    milión lodí. 

TODO: Prostudovat avanced Typescript typy:
  https://levelup.gitconnected.com/advanced-typescript-types-with-examples-1d144e4eda9e
- nebo si to možná hodit do nějakého typescriptového howtu či manuálu.

TODO: Mrknout na:
  var game = new Phaser.Game("100%", "100%", Phaser.CANVAS, 'parent');
  ...
  game.scale.scaleMode = Phaser.ScaleManager.RESIZE
https://stackoverflow.com/questions/28227090/phaser-make-background-screen-width-instead-of-content-width



TODO: Nahradit fs-promise něčím jiným
  npm WARN deprecated fs-promise@2.0.3: Use mz or fs-extra^3.0 with Promise Support


TODO: Updatovat verzi tasks.json (budu to muset celý předělat...)

TODO: Zkontrolovat, že http server neservuje soubory mimo www-root.

TODO: Vyzkoušet ES6 moduly v browseru.
https://medium.com/dev-channel/es6-modules-in-chrome-canary-m60-ba588dfb8ab7
   <script type="module" src="module.js"></script>
- nefungují, protože browser vyžaduje v importech '.js' a typescript
  ho tam se zapnutým outputem "module": "es2015" nedává.
  viz https://github.com/Microsoft/TypeScript/issues/16577