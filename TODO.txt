[UNCAUGHT_EXCEPTION] Failed to send packet to websocket (/ [::ffff:195.113.180.1
95]). Reason: WebSocket is not open: readyState 2 (CLOSING) (this exception has
propagated to top-level function. It needs to be caught much deeper where the er
ror can be properly recovered from.)
    at ServerSocket.send (D:\svetlym\tmp\00\Brutus\Kosmud\Src\Server\Net\ServerS
ocket.ts:69:13)
    at Connection.send (D:\svetlym\tmp\00\Brutus\Kosmud\Src\Server\Net\Connectio
n.ts:184:17)
    at Function.broadcast (D:\svetlym\tmp\00\Brutus\Kosmud\Src\Server\Net\Connec
tions.ts:52:18)
    at Function.updateClients (D:\svetlym\tmp\00\Brutus\Kosmud\Src\Server\Game\G
ame.ts:67:19)
    at Timeout.start.setInterval [as _onTimeout] (D:\svetlym\tmp\00\Brutus\Kosmu
d\Src\Server\Game\Game.ts:37:20)
    at ontimeout (timers.js:425:11)
    at tryOnTimeout (timers.js:289:5)
    at listOnTimeout (timers.js:252:5)
    at Timer.processTimers (timers.js:212:10)
- zaprvé musím tyhle exceptiony někde odchytávat.
- zadruhé musím testovat, jestli je connection CLOSING
  (to nejspíš souvisí s testováním connection.isOpen()
   v Connections.broadcast)))



TODO: Connections.broadcast() musí testovat, jestli jsou
  connectiony otevřené.

TODO: Výhledově sjednotit formát improtů (asi import { ERROR } from './ERROR').

TODO: Updatnout commenty v Application, Client a Server.

TODO: Uncaught error: Failed to send data because the connection is closed.

TODO: Packety asi nemusí mít version (nemusí se posílat).

TODO: Zvážit, jestli v Game.start() spíš nepustit jen jeden timer
  a z něj pak volat všechno ostatní.
  (60 tiků za vteřinu je blbý číslo btw, bude se s tím špatně počítat...
   na druhou stranu je to rozumný strop fps).
- Každopádně to jsou entry-level funkce a je tam potřeba reportovat uncaught
  exceptiony [to je DONE].

TODO: V ClientSocket (a nejspíš i ServerSocket) je pořád spousta ERROR()
  callů. Zkontrolovat, jestli to nemají být exceptiony.

TODO: Zamyslet se, co se zbytkem Utils
  (mělo by to mít specifičtější pojmenování.)


Prozatímní řešení client-server predikce
-----------------------------------------

TODO: Napsat "simulátor lagu"
  (random setInterval() před posláním packetu).

TODO: Vyzkoušet webpack

TODO: Fyziku přesunout do shared kódu (ve finálu tam bude muset bejt,
  aby šlo dělat client-side simulaci, tak bych s tím rovnou mohli počítat.
  (klient-side simulaci ale zatím dělat nebudu).

TODO: Na klienta posílat nejen aktuální stav, ale i rychlost a rotaci.
  Klient bude pokračovat v pohybu, kterej se od serveru dozvěděl.
  - resetne se to v okamžiku nového příchozího packetu
    (možná postupná interpolace pozice?)
  - predikce poběží jen určitej čas (třeba 100ms nebo tak nějak),
    pak se pohyb utlumí do nuly (aby se mi nestávalo to co v AOčku, tj.
    že při velkém lagu objekt ustřelí kamsi do dáli. Zastavit ho je mnohem
    lepší).


-----------------------------------------------------------------------

TODO: Exceptiony ve FileSystem.


TODO: Pořešit FileSystem.isEmpty() a FileSystem.isEmptySync()
- jsou v 'extfs', který jsem zrušil, nejsou ve 'fs-extra'

-----------------------------------------------------------------------

Refactoring Connectionů
------------------------

TODO: Asi bych to mohl udělat tak, že Connection zdědím z WebSocketu
- díky tomu to pořád bude separated code, ale nebudu muset řešit
  alokaci websocketu a budu mít protected přístup na receiveData().


TODO: Try-catchnout volání serialize() a deserialize().

TODO: Musí být connection.receiveData() public?
- jestli se to volá ze socketu, tak sloučením Socketu a Connection
  by callback vidě na private receiveData().

TODO: Oštřit socket.isOpen() až v Socket (časem to nejspíš beztak předělám,
  ale prozatím).

TODO: send() a receiveData() by asi vůbec neměly catchovat exceptiony
  (respektive receiveData() možná jo, ta se volá interně z callbacku,
   ale send() volá někdo jinej a ten by asi měl exception dostat).
- Jasně. A onReceiveMessage() už pak reportí jen uncaught exception
  pro případ, že by ji někdo nezhandlil sám.

TODO: Pořešit rethrow v ServerSocket.send()
  (a asi i v ClientSocket)


-----------------------------------------------------------------------

TODO: Rozdělit Utils na víc souborů.
- stringové fce
- souborové fce
  - ty by asi mohly jít do FS (už je tam isValidFileName()).
- ...

TODO: Vyhodit z Utils ERROR a FATAL_ERROR (a vůbec ho celý projít).
- nahradit je exceptionama.

-----------------------------------------------------------------------


TODO: Obecněji pořešit posílání packetů do closed connection.
  (i když nejvíc to vadilo u "client closed browser tab" message,
   páč tam problikla exception těsně před zavřením tabu)

-----------------------------------------------------------------------

---

Typescript mixins:
https://blog.mariusschulz.com/2017/05/26/typescript-2-2-mixin-classes

---

TODO: Asi sloučit classy Client a KosmudClient, Server a KosmudServer.


TODO: Klikání na objekty ve hře:
  You could do this using Query.point giving a mouse position and
  Composite.allBodies(engine.world). This will give you a list of
  bodies under the mouse.

TODO: Rozhodnout dilema s pojmeováváním class
- vidím to na SharedClass, Client/Class, Server/Class
- zatím používám trik:
   import * as Shared from '.../Class';
   class Class extends Shared.Class {}
Je to teda pořád otázka. ClientEntities a ServerEntities jsou asi názornější,
než když se tři classy jmenují stejně.


TODO: Prostudovat avanced Typescript typy:
  https://levelup.gitconnected.com/advanced-typescript-types-with-examples-1d144e4eda9e
- nebo si to možná hodit do nějakého typescriptového howtu či manuálu.

TODO: Mrknout na:
  var game = new Phaser.Game("100%", "100%", Phaser.CANVAS, 'parent');
  ...
  game.scale.scaleMode = Phaser.ScaleManager.RESIZE
https://stackoverflow.com/questions/28227090/phaser-make-background-screen-width-instead-of-content-width


TODO: Updatovat verzi tasks.json (budu to muset celý předělat...)

TODO: Zkontrolovat, že http server neservuje soubory mimo www-root.

TODO: Vyzkoušet ES6 moduly v browseru.
https://medium.com/dev-channel/es6-modules-in-chrome-canary-m60-ba588dfb8ab7
   <script type="module" src="module.js"></script>
- nefungují, protože browser vyžaduje v importech '.js' a typescript
  ho tam se zapnutým outputem "module": "es2015" nedává.
  viz https://github.com/Microsoft/TypeScript/issues/16577



TODO: Potenciální problém - 'entities' asi budou muset bej v Application
  místo v Entities, protože se k nim musím dostat
  v Serializable.readEntityReference a v Serializable nejdou importnout
  Entities.
- Možná si metodu GetEntities() { return Entities.entities; } hodit někam
  do Utils.
(zatím to přeložit jde. Nechám si to tu, až budu zprovoznovat Entities)

TODO: Přidat comment k Serializable.deserialize(), jak se loadují
  entity (nějak přes Entities)