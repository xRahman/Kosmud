TODO: Sledovat moji issue v animated tiles pluginu:
  https://github.com/nkholski/phaser-animated-tiles/issues/3

TODO: Opravit bug s přetáčením do jednoho směru.

TODO: Updatovat torqueRatio.

TODO: volat updateWaypointDirection() v každém tiku, kdy je nenulová
  distance (abych zastavil ve směru příletu).
[done]


TODO: Dvojitý zášleh, když couvám dál než braking distance.
- ok tak občas i nejen přes braking...
[fixed]

TODO: Asi bych při finálním dobržďování mohl prostě nenastavovat
  thrust ratia (respektive je nulovat). Tím zmizí závěrečné "bliknutí"
  thrusterů.
  (ratia setuju na 0, když je desiredSpeed 0)
- skoro, občas ale pořád ještě bliknout při zastavování dozadu.

Vypadá to, že:
- Přes impulsy to nebuguje (tak asi přece jen taky)
- Trhání nastává dřív, než se vůbec dostanu na zrychlení, kdy buguje fyzika
  (tzn. mám tam ještě problém někde jinde).


TODO: Problém v:
  private computeThrustValue(velocityChange: Vector, fullThrust: number)
- strašně dlouhou vzdálenost se mi počítá menší než FULL THRUST.

---------------

TODO: Ve stávajícím nastavení (s density 1) v Box2d nefunguje akcelerace
  menší než 0.02
    (a = F / m), takže je třeba určitá minimální velikost síly
  při dané hmotnosti.
- Udělat na to check.
  (respektive spíš budu muset pužít fyziku, která ten bug nemá...)

Bug s malou akcelerací je popsanej tady:
  http://discuss.cocos2d-x.org/t/cocos2d-x-3-17-physicsbody-applyforce-still-works-wrong/42631
  https://discuss.cocos2d-x.org/t/cocos2d-x-3-16-physicsworld-weird/39518
- možná zkusit Planck.js?

TODO: Sledovat moji issue v typescript Box2d:
  https://github.com/flyover/box2d.ts/issues/50


----------------

TODO: Zjevně jsem zapomněl pronásobit thrust ratia aktuálním
  thrustem (vždycky zobrazuju full thrust).

TOFIX: Zase mám obráceně levej a pravej thrust (spíš ratio).
- špatně se počítal angleToShip().
[fixed]

TOFIX: Dopředu a dozadu mám stejnej thrust.
  (respektive stejnou braking distance)
[fixed]


TODO: Thrust ratia počítám blbě - když letím šikmo, tak musí jít thrust
  do dvou směrů, ne jen do boku.
- asi bych si měl udělat dvě funkce. Jedna bude pouze vracet brakingThrust,
  druhá bude vracet výsledný thrust a při tom updatovat thrustRatios,
  ať nemusím tahat ven úhly a podobně.
I když ne, ratio na základě thrust anglu asi můžu spočítat v pohodě.
  forwardRatio = cos(angle)
  leftwardRatio = sin(angle)

ÚVAHA: Tím, že thrusty mohou jít nad 100% a navíc každej zvlášť, jsem si
  to brutálně zkomplikoval.

TODO: Udělat jen jeden modifikátor thrustu, kterej teda může jít nad 1, ale
  vztahuje se na všechny thrusty současně, včetně torque.

ÚVAHA: Možná bych thrustInDirection mohl počítat podobně jako ratia.
  Nebo možná jako elipsu.
  - pak bych mohl thrust ratia spočítat jako souřadnice bodu na elipse
    (a thrust by byl "poloměr" elipsy v daném místě)
Heh, ratia vychází stejně jak na kruhu
  (forward je cons(angle), leftward je sin(angle)), protože ratio je poměr
  ku poloose elipsy a "a * cos(angle) / a" je "cos(angle) a to samé pro
  kolmý směr.
ThrustSquared je potom:
 (forwardThrust * forwardThrustRatio)^2 + (leftwardThrust * leftwardThrustRatio)^2

TODO: Box2d má limit i na angular velocity (PI/2).
- Udělat na to check.

TODO: Tahák s fyzikálníma properties:
http://box2d.org/forum/viewtopic.php?t=3333

TODO: Zrušit .torque, zavést .torqueRatio a vracet ho v getTorqueRatio().
  (a typ number místo MinusOneToOne).
[done]

TODO: Reneablovat thrustInDirection().
- ještě to vyzkoušet

TODO: Zakázat ve VS code autocomplete

TODO: Nezapomenout nakonec validovat rychlost.
[done]
TODO: Validovat taky angular velocity.
  validateAngularVelocity()

TODO: Ošetřit zastavení do nuly
  (když jsem fakt blízko, tak přesně spočítat force za tik)
- i když, to by možná mělo dělat samo...
- ok, to teď fakt potřebovat budu :-)

TODO: Pročistit data properties ve VehiclePhysics.

Steering tutorial:
https://gamedevelopment.tutsplus.com/tutorials/understanding-steering-behaviors-flee-and-arrival--gamedev-1303

- brakingDistance se bude počítat prostě z aktuálního fullBrakingThrustu
  a MAX_SPEED
  (tedy bude to vzdálenost, za kterou stávajícím maximálním braking thrustem
   zabrzdím z MAX_SPEED na nulu).

TODO: (pokud to bude fungovat, tak mám asi zbytečně složitou i rotaci...)
- zjednodušit rotaci.

TODO: Opravit posílání thrustů na klient.

TODO: Zkontrolovat zvuk exhaustů
- nevím, jestli mi funguje hlasitost
- a asi by se neměla přehrávat celá smyčka, ale jen část.


-----------------------

TODO: Že bych nakonec všechny dynamické classy vyráběl přes Object.create()
  místo přes new?
- znamenalo by to, že při registraci classy by se nesavoval konstruktor, ale
  rovnou instance - a z ní by se pak dělali potomci přes Object.create().
Výhodu by to mělo, že by bylo průlhlednější (ne)volání konstruktoru.
  Při vyrábění té prototypové instance by se konstruktor normálně volal
  (což se teď neděje, když volám new na uložený konstruktor), protože by
  ho zavolal ten, kdo by prototypovou instanci registroval.
    A při factory create už by se samozřejmě konstruktor nevolal.


------------------------------------------------------------

TODO: Linear arrive forces

Dokud jsem dál než maxBrakingDistance, tak zaručeně acceleruju.
- když bych v příštím tiku překročil maxBrakingDistance, tak bych měl
  updatnout brakingDistance podle aktuální speed?

- když se vzdaluju (je jedno kterým směrem, prostě vzdálenost v tomhle tiku
  je větší než v minulém), tak musím přepočítat brakingDistance.
  - problém bude v tom, že nevím, jak dlouho mi bude trvat zrychlování
    (protože klidně můžu zrychlovat po nějaké křivce, takže to rozhodně
     nebude lineární).
  - stejně tak si nemůžu bejt jistej deccleraing thrustem, protože ten
    taky závisí na směru.

V každým okamžiku asi dokážu říct, jakej mám thrust k cíli a od cíle.
- že bych prostě v každém okamžiku počítal dráhu na základě těchle dvou
  thrustů?

distance
accForce
deccForce
v

maxBrakingDistance bude taky závislá na aktuální rotaci, tedy na
  aktuální deccForce.

1) pokud jsem dál než je aktuální maxBrakingDistance, tak akceleruju
   až do MAX_SPEED.
2) Když jsem blíž, tak je jasný, že nedosáhnu MAX_SPEED, tzn. řeším
   jen problém typu střecha


d = dAcc + dDecc
dAcc = (m * v * v) / (fAcc * 2)
dDecc = (m * V_MAX * V_MAX) / (fDecc * 2)
d = (m * v * v) / (fAcc * 2) + (m * V_MAX * V_MAX) / (fDecc * 2)
(m * V_MAX * V_MAX) / (fDecc * 2) = d - (m * v * v) / (fAcc * 2)
(m * V_MAX * V_MAX) = d * (fDecc * 2) - (m * v * v) * (fDecc * 2) / (fAcc * 2)
(m * V_MAX * V_MAX) = d * fDecc * 2 - m * v * v * fDecc / fAcc
vMaxSquared = d * fDecc * 2 / m - v * v * fDecc / fAcc

(m * vMaxSquared) = d * fDecc * 2 - m * v * v * fDecc / fAcc

dDecc = (m * vMaxSqared) / (fDecc * 2)
dDecc = (d * fDecc * 2 - m * v * v * fDecc / fAcc) / (fDecc * 2)
dDecc = (d - m * v * v) / (fAcc * 2)


Hmm, mám to špatně. Akcelerační vzdálenost není z rychlosti v do nuly,
ale z rychlosti v do rychlosti VMax

// Akcelerační vzdálenost je rovna:
//   Vzálenost, za kterou se dostanu z nuly na V_MAX
//   mínus vzdálenost, za kterou se dostanu z nuly na v.
dAcc = (m * V_MAX * V_MAX) / (fAcc * 2) - (m * v * v) / (fAcc * 2)
dDecc = (m * V_MAX * V_MAX) / (fDecc * 2)

d = dAcc + dDecc

d + (m * v * v) / (fAcc * 2) = (m * V_MAX * V_MAX) / (fAcc * 2) + (m * V_MAX * V_MAX) / (fDecc * 2)
d + (m * v * v) / (fAcc * 2) = (0.5 * m * V_MAX * V_MAX) * (1 / fAcc + 1 / fDecc)
d + (m * v * v) / (fAcc * 2) = (0.5 * m * V_MAX * V_MAX) * (fDecc / fDecc * fAcc + fAcc / fAcc * fDecc)
d + (m * v * v) / (fAcc * 2) = (0.5 * m * V_MAX * V_MAX) * (fDecc + fAcc) / (fDecc * fAcc)
d * (fDecc * fAcc) + (m * v * v) * (fDecc * fAcc) / (fAcc * 2) = (0.5 * m * V_MAX * V_MAX) * (fDecc + fAcc)
d * fDecc * fAcc + 0.5 * m * v * v * fDecc = (0.5 * m * V_MAX * V_MAX) * (fDecc + fAcc)

m * V_MAX * V_MAX = (2 * d * fDecc * fAcc + m * v * v * fDecc) / (fDecc + fAcc)

dDecc = (m * vMaxSqared) / (fDecc * 2)
dDecc = (2 * d * fDecc * fAcc + m * v * v * fDecc) / (fDecc + fAcc) * (fDecc * 2)
dDecc = (2 * d * fAcc + m * v * v) / (fAcc + fDecc) * 2
// Součet je asi ok, jen nesmím zapomenout, že fAcc má opačný směr
// (a tedy i znaménko) než fDecc.


Ok, one step at a time:

1) Disablovat rotaci
2) počítat se stejným thrustem do všech směrů.
3) vykašlat se na max_speed, zkusit rovnou šílenej výpočet
   akcelerace/deccelerace.


---

Možná to zbytečně komplikuju a stačilo by to, co jsem tam měl....
  (i když tam byl vlastně problém s tím přepočítáváním braking distance)

------------


TODO: Pokud opravdu zruším stopping distance, tak ji ani neposílat
  na klient a nezobrazovat.


TODO: ShipVectors kreslí i kruhy a tak, asi by se to mělo jmenovat jinak
  (ShipDebugGraphics?)

TODO: Problém je, že braking distance se dynamicky updatuje, takže se může
  stát, že zahájím braking manévr a následně se opět dostanu ven z braking
  distance.
- asi bych měl braking distanci měnit jen dokud jsem v accelerating fázi,
  případně po updatu waypointu (čímž se ovšem vrátím k problému, protože
  dokud držím lmb, tak se pozice waypoint updatuje každej tik).
{ Ono to možná vadit nebude, pokud bude správně fungovat natáčení }


SUPER IMPORTANT:
https://stackoverflow.com/questions/44866044/libgdx-box2d-velocity-not-increasing-enough

Jak řešit, když fyzika nestíhá:
https://gafferongames.com/post/fix_your_timestep/

TODO: CoordsTransform.tileObject() by možná mohlo rovnou i ztransformovat
  souřadnice, ne jen posouvat o půlku tily.

TODO: Zavést měřítko do CoordsTransform (nejspíš 1:1000)

TODO: CoordsTransform možná dát do /Client/Engine, je to čistě zobrazovací
  záležitost a týká se to konkrétně Phaseru.
  - tak ne, CoordsTransform se používá i v Shared/Tilemap
    (data tilemapy jsou v client koordinátech)
Ale mohla by bejt v Shared/Engine místo v Shared/Physics

TODO: Zamyslet se nad parametrem pro akceleraci lodi (kterým by se asi
  násobila steering force). Momentálně je omezené pouze maximum, což
  může vést k tomu, že se silnější motory až tak moc neprojevěj.


TODO: Speed lodi na clientu je nulová, takže se nezobrazuje
  (nejspíš ji nesetuju do physicsBody)
- ale jo, potřebuju ji - musím vidět, jak se aktuální velocity lodi
  blíží desiredVelocity.
  - asi to ale můžu posílat jako skalár a jen tím pronásobit vektor
    desiredVelocity.

desiredForwardComponentMagnitude může bejt záporná,
  s tím asi nepočítám.
- i když, asi jo. A zjednodušit to nejde, protože dozadu je jinej
  thrust než dopředu.

Refactoring steeringu
----------------------

Mohl bych asi na začátku arrive() vyrobit
  const phase = "Accelerating" | "Braking" | "Stopping"
a předávat ji pak dalším fcím, aby podle ní mohly switchovat.
[done]
Možná pak nebude potřeba předávat všude distance a tak.
- v computeLinearForces to totiž asi budu potřebovat switchovat taky
  (a je vůbec otázka, jestli to nerozdělit do víc funkcí, protože
   třeba seek() dobržďovací část vůbec nebude potřebovat).
Takže:
- computeSeekLinearForces()
- computeArriveLinearForces()

Opravy steeringu
-----------------

TODO: Přijde mi, že MAXIMUM_SPEED lodi nic nedělá
- vektory jsou delší, to jo, ale vizuálně loď neletí rychlejš.
- a taky je divný, že se pořád letí na maximum thrust
  (to je teda fajn - sice to není fyzikálně správně, ale vypadá to dobře).

 Refactorovat steering
- různá chování počítají jen desired velocity
  I když, to je otázka.
  - Za prvé nevím, jestli bude fungovat skládání behaviourů přes rychlosti
    (nejspíš je nějakej důvod, proč se skládaj až výsledné steering forces)
  - Za druhé nevím, co složitější behaviours s těma silama dělaj...
Ok, asi se raději budu držet skládání sil.

TODO: Forward thrust se z nějakých důvodů limituje na 80% výkonu.

TODO: Steering by se možná choval líp, kdyby se prostě loď nejdřív otočila
  do požadovaného směru a pak se aplikoval jen forward/backward thrust.
- tohle asi dělat, jen když je loď blízko k cíli.
- rozhodně to budu muset ještě poladit.
TODO: Asi budu muset přece jen trošku poladit arrive() - na thrusterech
  je vidět, jak se to občas chová divně.
TODO: Opravit "backlash" při zastavování.

-----

Zprovoznit entity
- Savovat/loadovat lodě z disku.
- Savovat/loadovat zónu z disku.
- Posílat v rámci packetů zónu/lodě místo ručně vytažených properties.
  (ZoneUpdate se asi bude muset pořád vyrábět ručně, uvidíme...)
- Udělat entity pro textury, zvuky, shapy a podobně
  - používat idčko entity jako idčko resourcu v Phaseru.




Upřesnění aktuálního cíle:
---------------------------
- 1 player ship, 1 enemy ship
- střelba railgunem a raketama
  - zvukové efekty
  - exploze při zásazích, exploze při zničení lodi
  - grafika a fyzika vraku
- basic interface (healthbar, skillbar, zobrazení cooldownu na rakety).
  (na to asi budu muset rozběhat windows a vůbec základy gui).
- detekce zásahů, detekce kolizí lodí. Basic počítání hpček.
(překážky, tedy obecně objekty ve scéně, na tohle nejsou potřeba)


TODO: V rámci EnterFlightRequest.sendResponse() posílat
  zónu (respektive to z ní, co player vidí. A hlavně seznam
  toho, co se má preloadnout).
  - zatím to dělat nebudu a budu číst data zóny natvrdo.

TODO: V Client/EnterFlightRequest.process() creatnout zónu z poslaných dat
  (zatím ji tam budu natvrdo vyrábět).


TODO: Pokud nebudou potřeba data tilemapy po načtení shapů, tak je
  nedržet (tj. dát to do dočasné proměnné).
  (tzn. Zone.tilemaps by asi mělo být dočasné a ne class property)
- shapy v paměti držet budu.

TODO: V EnterShip.fakeLoadFighter() setovat i ostatní physics properties.
  (ve Vehicle budou jen defaultní).


Obecně se mi nechce dělat classy pro jednotlivé typy lodí.
- různou funkčnost zařídím prostě tak, že do nich dám různé zbraňové systémy,
  každý se svou funkčností.
=> Jednotlivé lodě musej bejt instance s různě nastavenými vlastnostmi.
  - to v zásadě můžu udělat i v kódu, prostě udělám 4x new Ship() a nasetuju
    jim properties (efektivně to je totéž jako load entity z disku).
{tohle si tu nechám, ať vím, kam směřuju}



Far TODO:
----------
3) Dát něco do scény.
4) Vyhýbání (překážkám a jiným lodím).
7) Bullets (railgun a tak)
8) Rakety!
9) Lag simulátor a interpolace na clientu, aby se to netrhalo.
   - zatím asi až tak moc nespěchá, hratelný to bude i bez toho.

-----------------------------------------------------------------------


Prozatímní řešení client-server predikce
-----------------------------------------

TODO: Napsat "simulátor lagu"
  (random setInterval() před posláním packetu).

TODO: Na klienta posílat nejen aktuální stav, ale i rychlost a rotaci.
  Klient bude pokračovat v pohybu, kterej se od serveru dozvěděl.
  - resetne se to v okamžiku nového příchozího packetu
    (možná postupná interpolace pozice?)
  - predikce poběží jen určitej čas (třeba 100ms nebo tak nějak),
    pak se pohyb utlumí do nuly (aby se mi nestávalo to co v AOčku, tj.
    že při velkém lagu objekt ustřelí kamsi do dáli. Zastavit ho je mnohem
    lepší).

-----------------------------------------------------------------------

Bugfixy phaseru:
-------------------

TODO: Sledovat opravu https://github.com/photonstorm/phaser/pull/3964
  (momentálně mám hacknutou client-side opravu v 'up: function (event, time)').
  https://github.com/photonstorm/phaser/issues/3779



Odložené TODO:
---------------

TODO: Po reloadu tabu se špatně zobrazuje pozice waypointu.
- asi ho budu muset posílat ze serveru spolu se scénou
  (tzn. s lodí).

TODO: Udělat classu wrapující fastbitvector.
TODO: Udlělat ji Serializable a vyhodit serializační hack ze Serializable.

TODO: Napsat serializaci/deserializaci PriorityQueue
  (a rovnou to opravit, protože to prakticky určitě nebude dobře).

TODO: Hmm, možná kdybych důsledně používal wrapper na bitvector a byl
  zděděnej ze Serializable, tak bych ho nemusel v Serializable
  řešit.

IDEA: U vehiclů je otázka, jak se budou savovat - když bude například
  pozice jen ve physicsBody, tak dokud loď body nemá, tak nemá jak pozici
  uložit. Navíc asi tak jako tak nebudu chtít savovat vnitřek b2Body.
- mohl bych to udělat tak, že vehicle vždycky bude mít PhysicsBody
  (což je moje classa) a v tom se budou savovat údaje jako pozice a podobně.
  - ha, tzn. by tam taky rovnou mohly být konstanty jako restitution a tak.
  PhysicsBody by pak mohlo a nemuselo mít b2Body.

TODO: Packety se serializují, takže bych neměl spoléhat na to, že se provede
  konstruktor. Navíc prázná pole a objekty se vůbec neposílají a spoléhá se,
  že jsou na druhé straně inicializované na nějakou defaultní hodnotu.
=> Asi bych měl ve všech packetech důsledně všem propertiesům dávat defaultní
  hodnoty.
=> A možná bych v Serializable objektech vůbec neměl používat konstruktor.
{obecně nevím, jak tohle ošetřit. Asi leda commentem na začátku souborů}
- jo a mohl bych tam asi opravdu zrušit konstruktory a setovat všechno
  dodatečně.

TODO: Zvážit, že by physics shapy byly entity (měly by unikátní idčko a tak).

TODO: Updatnout Tilemap.Data podle
  http://docs.mapeditor.org/en/stable/reference/tmx-map-format/
- respektive je tam i verze pro JSON.

TODO: Výhledově místo atlas animací používat tile animace vytvořené v Tiled
  editoru a číst je z dat tilemapy.

TODO: Časem udělat (pre)loadovací scénu.
- to pak znamená jinak loadovat pluginy, viz:
  https://github.com/photonstorm/phaser3-plugin-template


TODO: Možná by stálo za to transformaci souřadnic ještě upravit, aby [0, 0]
  bylo uprostřed obrazovky.
  (protože typicky budu chtít loď uprostřed obrazovky...)
  - i když, to možná bude lepší vyřešit kamerou.
{ Asi by to fakt chtělo - teď když resizuju hru, tak se objekty ve flight
 scéně držej vlevo nahoře, protože tam mají origin. Správně by asi mělo
 to, co je veprostřed obrazovky, zůstat uprostřed }


TODO: Zapínání a vypínání debug grafiky.
- flaga na zapnutí debug view by asi měla bejt na serveru (v accountu?)
      (bude přepínat, jestli se ve SceneUpdate bude nebo nebude
       posílat info na debug draw a když tam bude, tak ho klient
       prostě vykreslí
       - otázka ale je, co s vykreslováním bounding boxů, které
         se neposílají v každém paketu
         - asi se přepínání bude muset posílat taky).


TODO: SetWaypoint by se asi mělo posílat z něčeho jinýho než
  z Waypointu.
  - ani scéna by to neměla dělat. Možná engine?


TODO: Výhledově zrušit posílání ShipToScene
  z WebSocketServer.acceptConnection()
  a posílat ho až po nalogování playera do hry.


TODO: Výhledově líp pořešit keyboard handling. Psát extra handler na každou
  klávesu je dost overkill, navíc by se blbě psalo mapování keybindů.
  - asi to můžu udělat přes DOM eventy místo přes Phaser.


TODO: Klikání na objekty ve hře:
  You could do this using Query.point giving a mouse position and
  Composite.allBodies(engine.world). This will give you a list of
  bodies under the mouse.


TODO: Mrknout na:
  var game = new Phaser.Game("100%", "100%", Phaser.CANVAS, 'parent');
  ...
  game.scale.scaleMode = Phaser.ScaleManager.RESIZE
https://stackoverflow.com/questions/28227090/phaser-make-background-screen-width-instead-of-content-width


TODO: Vyzkoušet linear a angular drag (zapnout na physicsBody).
- to by teoreticky mělo způsobit, že síla bude muset působit pořád,
  abych udržel rychlost. Na druhou stranu...
Tohle ale až časem (možná vůbec). Současná varianta je celkem ok.


TODO: Asi budu potřebovat seekForward() a seekBackward()
(protože v současném módu se couvat moc nedá).
IDEA: Dozadu by se mohlo jet tak, že kliknu před loď a dragnu skrz loď za ni.
// IDEA: Se shiftem loď strafuje/couvá.

TODO: Odhackovat Client/Phaser/Sound.setVolume();

-----------------------------------------------------------------------

Výhledové TODO:
-----------------

TODO: Neposílat všem playerům updaty všech zón, stačí každému poslat
  update zóny, ve které se nachází.
  (Server/Game/updateClients())

TODO: Konstantu FPS ve Vehicle.ts hodit někam jinam (udělat jednu konstantu
  pro veškeré časování a tu všude používat).
- možná do Engine, pokud něco takovýho bude existovat.

TODO: Až bude Vehicle zděděné z Entity, zrušit Vehicle.getErrorIdString().

TODO: Hlasitost zvuku ostatních lidí snižovat se vzdáleností od pozice
  hráčovy lodě (nejspíš ne od pozice kamery).


TODO: Vyzkoušet dekompozici nekonvexních pologynů na konvexní:
  https://github.com/Louis-T/fernandez-polygon-decomposition
  https://github.com/schteppe/poly-decomp.js/
  - ten druhej asi neumí díry (a navíc má koordináty v poli), takže
    asi spíš ten první.
  - ideálně by se to mělo procesit offline, ale co už.
Spíš to asi odložím. Zatím můžu ručně editovat čiste konvexní polygony
  (ostatně to znamená rychlejší start.


TODO: Pořešit FileSystem.isEmpty() a FileSystem.isEmptySync()
- jsou v 'extfs', který jsem zrušil, nejsou ve 'fs-extra'


TODO: Použít https://letsencrypt.org/


TODO: Přidat comment k Serializable.deserialize(), jak se loadují
  entity (nějak přes Entities)


TODO: (Znovu) vyzkoušet ES6 moduly v browseru.
https://medium.com/dev-channel/es6-modules-in-chrome-canary-m60-ba588dfb8ab7
   <script type="module" src="module.js"></script>
- nefungují, protože browser vyžaduje v importech '.js' a typescript
  ho tam se zapnutým outputem "module": "es2015" nedává.
  viz https://github.com/Microsoft/TypeScript/issues/16577


TODO: Prostudovat avanced Typescript typy:
  https://levelup.gitconnected.com/advanced-typescript-types-with-examples-1d144e4eda9e
- nebo si to možná hodit do nějakého typescriptového howtu či manuálu.


TODO: Výhledově místo neposílání paketů do closed connection
  při disconnectu disablovat komplet herní keyboard processing.
  (viz Keyboard.sendPlayerInput())
  - component.hide() nestačí, to je vypne zobrazování.


Tslint
--------

TODO: Nepovedlo se mi rozplazit tslint extension, kterej by lintoval
  při psaní a zároveň nežral message reportnuté z buildu, které
  vyžadují type info.
    HINT: "problemMatcher": [ "$tslint5" ] je definovaný v tslint extensioně,
    takže když zapnu nějakou jinou, přestane fungovat matchování tslintových
    problémů při rebuildu.

TODO: Výhledově ještě jednou zkusit zapnout "no-unsafe-any" v tslintu
  (teď už na to nemám sílu).
TODO: Výhledově ještě jednou zkusit zapnout "strict-boolean-expressions"
  (teď už na to nemám sílu).
  - IDEA je v Serializable nepovolit v serialize/deserialize paramu
    typ any, ale nejspíš jen union některých typů.
    (bude to nejspíš znamenat, že už při vytváření paramů budu muset ošetřit,
      jestli tam neleze null nebo undefined, ale mělo by to pak dál
      ušetřit některé testy).

TODO: Tslint (co momentálně nejde v tslintu nastavit):
- zakázat newline na konci souboru
- Vyžadovat newline za if (), while() a podobně
  (teď se dá napsat na jednu řádku if (x === 0) { doSomething(); }).
- závorky za funkcí (volání i deklarace)
- jednořádkové if/for/do/while
  (mělo by to bejt tak, že když je za ifem jeden řádek a je to return nebo
   throw, tak {} být nemusí, jinak ano).
   - Hmm a vlastně ani to vždycky neplatí, protože když je za ifem
     throw new Error(), kterej se nevejde na jeden řádek, tak je taky lepší
     ho uzávorkovat do {}.
- kontroly vyžadující type information
