Priority:
1) Opravit pohyb lodi, aby se rozumně otáčela a zabrzdila na waypointu
   (couvání a strafování zatím netřeba).
   - ještě to není úplně ok, ale prozatím se dá.
   [done]
2) Efekty trysek (grafický a zvukový).
   [done]
3) Lag simulátor a interpolace na clientu, aby se to netrhalo.
4) Dát něco do scény.
5) Vyhýbání (překážkám a jiným lodím).
6) Lepší physics body shape pro loď (a pro překážky taky).
7) Anchor pointy (pro exhausty, časem pro zbraně).
8) Bullets (railgun a tak)
9) Rakety!

TODO: Než se pustím do následujícího, tak přece jen ještě
  vyzkoušet texture atlas animaci na exhaust.
Ok, TODO: Vyrobit celou loď úplně znova.
- vymyslet lepší název než "rogue"
  - missile_ship, railgun_ship,
  - fighter, bomber, support, assault
- pojmenvávat důsledně layery ("layer_"), tilesety ("tileset_").
  (tohle asi stačí pro názvy konstant v kódu - v editoru to může
   bejt bez přípony, tam to je přehlednější).
- zmenšit loď na půlku.
- v Tiled editoru ji dát do object layeru
  - ve hře z ní pak udělat spritu
- vyrobit texturu s exhausty v TexturePackeru
  + vyexportovat texture atlas
- naimportovat ji do Tiled editoru, vyrobit z ní tilesy


IDEA: Ještě bych možná mohl zkusit, že místo vyrábění spritů z object layeru
  vyrobím nové tilesy do tile layeru.
- Hmm, vlastně bych ty thrustery rovnou mohl udělat jako static layer,
  teda až na to, že pak nepůjde scalovat velikost...
Problém trochu je, že tilesy jsou velikostí nastavené na loď a všechny
layery zjevně musej mít tilesy stejné.
  Takže asi leda udělat v mapě lodě základní tilesy podle animace exhaustů
  (loď holt bude přes víc tilesů) - to je dost pitomý, protože to pak
  bude fungovat jen na tuhle konkrétní animaci.

IDEA: Nejjednodušší asi bude, vyrobit tu animaci znova v texture packeru
  s tím, že sprity nechám poskládat jednu vedle druhý, tzn. tu textutu
  budu moct beze změny využít jako tileset v Tiled editoru.
- a můžu zkusit requestnout tile animaci spritů vyrobených z object layerů
  v tile animation pluginu...

TODO: Vytáhnout info o animaci z tilemapy,
  vyrobit tuhle animaci ručně a přidělit ji na exhaust spritu vytvořenou
  z object layeru v tilemapě.
- vůbec nejdřív tu animaci prostě vytvořit ručně (ať mám představu).

TODO: vyzkoušet https://github.com/nkholski/phaser-animated-tiles
- nefunguje kvůli bugu, viz:
  https://github.com/nkholski/phaser-animated-tiles/issues/2
- a je otázka, jestli vůbec funguje na sprity vytvořené z object layeru
  (spíš asi ne).
TODO: Každopádně vyzkoušet sprite animaci aspoň na tiles layeru.
[done]
- a možná bych si pak ten converter mohl napsat...

TODO: Exhausts možná přejmenovat na Thrusters?
- každopádně se pro něco rozhodnout a používat to všude (včetně tilemapy lodi).

TODO: Konzistentně dávat do klíčů, názvů layerů a podobně příponu, co to je.
  tzn: "thrusters_layer", "exhaust_animation"

TODO: Časem udělat (pre)loadovací scénu.
- to pak znamená jinak loadovat pluginy, viz:
  https://github.com/photonstorm/phaser3-plugin-template

Ad 2:
-----

Ad 4:
------
TODO: načíst výstup z Tiled editoru.
- na serveru do fyziky, na klientu do grafiky

https://medium.com/@michaelwesthadley/modular-game-worlds-in-phaser-3-tilemaps-1-958fc7e6bbd6



TODO: Forward thrust se z nějakých důvodů limituje na 80% výkonu.


TODO: Steering by se možná choval líp, kdyby se prostě loď nejdřív otočila
  do požadovaného směru a pak se aplikoval jen forward/backward thrust.


TODO: Refactoriiiing!
- Učesat steering kód.
- Místo Phaser.Scene všude předávat Scene
  (což je z ní beztak zděděné, ale je to můj interní typ).
- SceneUpdate by asi mělo parametry dostávat trochu víc strukturovaně
 (konstruktor s 20 parametry už je trochu přes míru...)

 Refactorovat steering
- různá chování počítají jen desired velocity
  I když, to je otázka.
  - Za prvé nevím, jestli bude fungovat skládání behaviourů přes rychlosti
    (nejspíš je nějakej důvod, proč se skládaj až výsledné steering forces)
  - Za druhé nevím, co složitější behaviours s těma silama dělaj...
Ok, asi se raději budu držet skládání sil.

TODO: Odchytávání výjimek ze Steeringu.

TODO: Když umře server tak SendWaypoint na klientu hodí Uncaught Error.

TODO: Projít všechny metody ve Vehicle, jestli musejí být public.

TODO: Asi budu muset přece jen trošku poladit arrive() - na thrusterech
  je vidět, jak se to občas chová divně.

TODO: Opravit "backlash" při zastavování.

-----------------------------------------------------------------------

TODO: Shared/Game/Ship je možná zbytečná, Ship na clientu z ní není
  zděděná.
- tak možná ne, nějaké společné properties to už má.

-----------------------------------------------------------------------


Prozatímní řešení client-server predikce
-----------------------------------------

TODO: Napsat "simulátor lagu"
  (random setInterval() před posláním packetu).


TODO: Fyziku přesunout do shared kódu (ve finálu tam bude muset bejt,
  aby šlo dělat client-side simulaci, tak bych s tím rovnou mohli počítat.
  (klient-side simulaci ale zatím dělat nebudu).

TODO: Na klienta posílat nejen aktuální stav, ale i rychlost a rotaci.
  Klient bude pokračovat v pohybu, kterej se od serveru dozvěděl.
  - resetne se to v okamžiku nového příchozího packetu
    (možná postupná interpolace pozice?)
  - predikce poběží jen určitej čas (třeba 100ms nebo tak nějak),
    pak se pohyb utlumí do nuly (aby se mi nestávalo to co v AOčku, tj.
    že při velkém lagu objekt ustřelí kamsi do dáli. Zastavit ho je mnohem
    lepší).

-----------------------------------------------------------------------

Bugfixy phaseru:
-------------------

TODO: Sledovat opravu https://github.com/photonstorm/phaser/pull/3964
  (momentálně mám hacknutou client-side opravu v 'up: function (event, time)').
  https://github.com/photonstorm/phaser/issues/3779



Odložené TODO:
---------------

TODO: Možná by stálo za to transformaci souřadnic ještě upravit, aby [0, 0]
  bylo uprostřed obrazovky.
  (protože typicky budu chtít loď uprostřed obrazovky...)
  - i když, to možná bude lepší vyřešit kamerou.

TODO: Zapínání a vypínání debug grafiky.
- flaga na zapnutí debug view by asi měla bejt na serveru (v accountu?)
      (bude přepínat, jestli se ve SceneUpdate bude nebo nebude
       posílat info na debug draw a když tam bude, tak ho klient
       prostě vykreslí
       - otázka ale je, co s vykreslováním bounding boxů, které
         se neposílají v každém paketu
         - asi se přepínání bude muset posílat taky).

TODO: SetWaypoint by se asi mělo posílat z něčeho jinýho než
  z Waypointu.
  - ani scéna by to neměla dělat. Možná engine?



TODO: Výhledově zrušit posílání ShipToScene
  z WebSocketServer.acceptConnection()
  a posílat ho až po nalogování playera do hry.


TODO: Výhledově líp pořešit keyboard handling. Psát extra handler na každou
  klávesu je dost overkill, navíc by se blbě psalo mapování keybindů.
  - asi to můžu udělat přes DOM eventy místo přes Phaser.


TODO: Klikání na objekty ve hře:
  You could do this using Query.point giving a mouse position and
  Composite.allBodies(engine.world). This will give you a list of
  bodies under the mouse.


TODO: Mrknout na:
  var game = new Phaser.Game("100%", "100%", Phaser.CANVAS, 'parent');
  ...
  game.scale.scaleMode = Phaser.ScaleManager.RESIZE
https://stackoverflow.com/questions/28227090/phaser-make-background-screen-width-instead-of-content-width

TODO: Výhledově Ship zdědit z Vehicle a přesunout tam věci, které by ship měla
sdílet s jinými pohyblivými objekty.
- pak je taky otázka, co s turretama a podobně. Brát je jako Vehicle? Uvidíme.


TODO: Vyzkoušet linear a angular drag (zapnout na physicsBody).
- to by teoreticky mělo způsobit, že síla bude muset působit pořád,
  abych udržel rychlost. Na druhou stranu...
Tohle ale až časem (možná vůbec). Současná varianta je celkem ok.


TODO: Asi budu potřebovat seekForward() a seekBackward()
(protože v současném módu se couvat moc nedá).
IDEA: Dozadu by se mohlo jet tak, že kliknu před loď a dragnu skrz loď za ni.
// IDEA: Se shiftem loď strafuje/couvá.

TODO: Odhackovat Client/Phaser/Sound.setVolume();

-----------------------------------------------------------------------

Výhledové TODO:
-----------------

TODO: Nepovedlo se mi rozplazit tslint extension, kterej by lintoval
  při psaní a zároveň nežral message reportnuté z buildu, které
  vyžadují type info.
    HINT: "problemMatcher": [ "$tslint5" ] je definovaný v tslint extensioně,
    takže když zapnu nějakou jinou, přestane fungovat matchování tslintových
    problémů při rebuildu.

TODO: Výhledově ještě jednou zkusit zapnout "no-unsafe-any" v tslintu
  (teď už na to nemám sílu).
TODO: Výhledově ještě jednou zkusit zapnout "strict-boolean-expressions"
  (teď už na to nemám sílu).
  - IDEA je v Serializable nepovolit v serialize/deserialize paramu
    typ any, ale nejspíš jen union některých typů.
    (bude to nejspíš znamenat, že už při vytváření paramů budu muset ošetřit,
      jestli tam neleze null nebo undefined, ale mělo by to pak dál
      ušetřit některé testy).

TODO: Tslint (co momentálně nejde v tslintu nastavit):
- zakázat newline na konci souboru
- Vyžadovat newline za if (), while() a podobně
  (teď se dá napsat na jednu řádku if (x === 0) { doSomething(); }).
- závorky za funkcí (volání i deklarace)
- jednořádkové if/for/do/while
  (mělo by to bejt tak, že když je za ifem jeden řádek a je to return nebo
   throw, tak {} být nemusí, jinak ano).
   - Hmm a vlastně ani to vždycky neplatí, protože když je za ifem
     throw new Error(), kterej se nevejde na jeden řádek, tak je taky lepší
     ho uzávorkovat do {}.
- kontroly vyžadující type information

TODO: Pořešit FileSystem.isEmpty() a FileSystem.isEmptySync()
- jsou v 'extfs', který jsem zrušil, nejsou ve 'fs-extra'


TODO: Použít https://letsencrypt.org/


TODO: Přidat comment k Serializable.deserialize(), jak se loadují
  entity (nějak přes Entities)


TODO: (Znovu) vyzkoušet ES6 moduly v browseru.
https://medium.com/dev-channel/es6-modules-in-chrome-canary-m60-ba588dfb8ab7
   <script type="module" src="module.js"></script>
- nefungují, protože browser vyžaduje v importech '.js' a typescript
  ho tam se zapnutým outputem "module": "es2015" nedává.
  viz https://github.com/Microsoft/TypeScript/issues/16577


TODO: Prostudovat avanced Typescript typy:
  https://levelup.gitconnected.com/advanced-typescript-types-with-examples-1d144e4eda9e
- nebo si to možná hodit do nějakého typescriptového howtu či manuálu.


TODO: Rozhodnout dilema s pojmeováváním class
- vidím to na SharedClass, Client/Class, Server/Class
- zatím používám trik:
   import * as Shared from '.../Class';
   class Class extends Shared.Class {}
Je to teda pořád otázka. ClientEntities a ServerEntities jsou asi názornější,
než když se tři classy jmenují stejně.


TODO: Výhledově sjednotit formát importů (asi import { ERROR } from './ERROR').
- spíš to nechám postaru. Vidět v importu, jestli je to ze /Shared, /Client
  nebo /Server je docela důležitý.


TODO: Výhledově místo neposílání paketů do closed connection
  při disconnectu disablovat komplet herní keyboard processing.
  (viz Keyboard.sendPlayerInput())
  - component.hide() nestačí, to je vypne zobrazování.