TODO: Sledovat moji issue v animated tiles pluginu:
  https://github.com/nkholski/phaser-animated-tiles/issues/3

TODO: Zajímavá myšlenka: Předělat klienta přes async funkce, stejně
  jako server (metody preload() a create() by resolvnuly promisu,
  což by spustilo moji vlastní load() případně init() funkci).
- při té příležitosti používat flagu zone.active.
  (když budu z něčeho volat create(), tak tam můžu setnout zone.active = true;


TODO: FlightSceneContents v původním významu postrádá smysl,
  lodě a objekty teď budou ve scéně.
  - pořád někde musí být waypoint (i když ten možná může bejt v ShipModelu)
    a background (ten by zas mohl bejt v úplně jiný scéně...).
  - každopádně pokud to zůstane, mělo by se to asi jmenovat jinak.
{zatím to nechám být - je v tom background a waypoint}


TODO: Mrknout se na serveru, jestli se initShapes() v zone.preload()
  nemůže volat až v creatu (na serveru to je všechno async, ale i tak
  by asi bylo lepší, aby to bylo stejně jako na klientu).
- zone.create() na serveru vůbec nemám, ale mám tam createPhysicsWorld(),
  s tím by se to možná dalo sloučit.

TODO: zone.steerVehicles() by se možná dalo hodit do update()
  (opět aby to bylo koncepčně stejně jako na klientu).

TODO: FlightScene.preload()
- loadovat podle seznamu v zóně.

TODO: Vyházet z konstructoru Client/Ship() vyrábění grafiky a tak
  a dělat to až z FlightScene.create()
  (nejspíš provolat scene.create(), která provolá create() jednotlivých
   lodí ve scéně).
- problém je, že pak grafické bazmeky v Shipu nebudou inicializované
  v konstruktoru. Možná je všechny sloučit do ShipGraphics?
  - ono to tak vlastně i je, jen exhausty a zvuky jsou mimo.
    (což možná není nutný, exhausty jsou očividně grafickej bazmek,
     takže klidně mohou být v shipGraphics.
  - Zvuky by tam ideálně měly bejt taky.
    - V tom případě by se to ale asi nemělo jmenovat ShipGraphics. Jak?
      - ShipMedia? ShipMultimedia? ShipAudiovisuals?
      ShipModel, ha!

TODO: zone.update() se nikde nevolá
  (tzn. se nevolá ani steerVehicles()).


TODO: Vyhodit vyrábění tilemapy z konstruktoru ShipModelu
  (tilemapa se bude vyrábět v creatu flightScény).


TODO: Vyrábět v zóně seznam shapů
- na serveru
  - tam se to snad dělá
- na klientu
Začnu tím, že flight scénu nebudu předávat do konfigu Phaser.Game 
(tím se totiž rovnou pustí preload() a create()), ale pouze ji vytvořím
 a preload pustím později ručně.
- FlightScene nesmí vyžadovat zónu.

TODO: Zkontrolovat, že se při vytvoření shipy na clientu
  správně získá shape ze zóny.

TODO: Animation by asi mohla bejt samostatná classa
  (teď se to dělá přes Scene).
- scene.createAnimation() by mohla vrátit rovnou Animation.

Hmm, ono by to asi celý mělo bejt tak, že scene.createNěco() vytvoří
  a vrátí rovnou wrapper, nikoliv interní phaserovou property.
  - takže createAnimation() by mělo vrátit Animation,
    createSound() by mělo vrátit sound, atd.
  - čili konstruktory wrapperů pak nebudou dostávat jako parametr
    Scene, ale to, co mají wrappovat.
Bohužel teda u PhysicsWorld a createBody() to takhle nepůjde, protože
  v body si Vehicle drží fyzikální properties (a má ho tudíž od začátku,
  přestože ještě není v physics worldu).
  - Možná bych to ale mohl předělat, vrátit properties do PhysicsConfigu,
    nebo tak něčeho a PhysicsBody vyrábat opravdu až v addToPhysicsWorld().
    - asi jo.

-----

Note:
  Scénu držím v connection. Asi to není úplně logický místo, ale předpokládám,
  že na zónu budu přistupovat z nějakýho packetu (ZoneUpdate, nejspíš), takže
  se tam bude hodit.

-----

IDEA: U vehiclů je otázka, jak se budou savovat - když bude například
  pozice jen ve physicsBody, tak dokud loď body nemá, tak nemá jak pozici
  uložit. Navíc asi tak jako tak nebudu chtít savovat vnitřek b2Body.
- mohl bych to udělat tak, že vehicle vždycky bude mít PhysicsBody
  (což je moje classa) a v tom se budou savovat údaje jako pozice a podobně.
  - ha, tzn. by tam taky rovnou mohly být konstanty jako restitution a tak.
  PhysicsBody by pak mohlo a nemuselo mít b2Body.

TODO: Vyrobit client verzi Zóny.
-mark-: Hrabu se v EnterFlightResponse.process().

TODO: Ship na clientu budu muset asi pojmout úplně jinak
  - měla by být schopna existovat v zóně, i když ještě není ve scéně.
I když, hmmm.
  Možná, že ne - flight scéna přece jen asi může existovat už od začátku.
  Jen je teda otázka, jak vyřeším preload...
Zjevně se nějak řeší, jeslti je scéna "active", a tedy ji má Phaser automaticky
  loadnout a pustit, viz:
  http://www.html5gamedevs.com/topic/36148-phaser-3-scene-phaser-2-state-passing-data-to-init-when-start/

TODO: Loading scene: https://phaser.io/news/2018/05/phaser-3-preloader-tutorial

TODO: Ještě líp popsaný loading:  
https://jwiese.eu/en/blog/2018/04/phaser-3---loading-screen--asset-organization/

Otázka je, jestli se má shape posílat v rámci přidávání lodě do scény,
nebo spíš na klientu vyrobit z dat tilemapy stejně jako na serveru.
- logičtější by asi bylo ho tam vyrobit, protože data tilemapy musí
  načíst tak jako tak.
  - bude tam ale pak chybět kontrola, že to má opravdu takovej shape, jako
    si myslím (jakej to má na serveru).
  - na druhou stranu posílat shape pro každou tilesu je blbost, stejně jako
    posílat ho pro každou loď znova.
Pak je ještě otázka, co všechno se má poslat s lodí, aby se dala na klientu
správně zobrazit.
- ideálně asi poslat celou entitu (její Shared část) a neřešit to...
- každopádně teď ale asi budu muset poslat shapeId

TODO: Na clientu loadovat tilemapy ve scéně
- na to asi budu muset dát klientu vědět, jakou scénu má loadovat.
  (v rámci EnterGame?)
  - jednotlivé zóny budou instance stejné classy, takže bude opravdu
    potřeba ta data poslat.
  - místo ShipToScene pak taky budu posílat UpdateZone, nebo tak něco
    (a přibalit do toho celou shared Ship, místo abych z ní musel něco
     vytahovat).
  Posílat entity zatím nebudu - vezmu to natvrdo ze Zone.preloadData.
  - ok, to bych měl dělat v rámci preloadu scény.
TODO: A vyčíst z nich shapy
TODO: Ve FlightScene.createShip() použít shape loadnutej z tilemapy
  místo shapu poslaného ze serveru.


Scéna nepotřebuje odkaz na zónu - renderuje se zóna do scény, ne naopak.
- tzn. asi bych měl nejdřív vyrobit flight scénu a až pak si říct serveru
  o zónu (tzn. poslat EnterFlightRequest).
    Díky tomu pak bude existovat flightScene ve chvíli, kdy dostanu scénu
  a věci v ní, a tudíž jim můžu dát scénu jako parametru.

Takže TODO:
- posílat EnterFlightRequest až poté, co je vyrobená (ne preloadnutá)
  flight scéna.

TODO: Server/Zone.getSceneUpdate() by se asi mohlo jemnovat prostě
  getUpdate().
A ScenUpdate (packet) by se mohl jmenovat ZoneUpdate.
(updatuje se stav zóny, kterej si pak klient promítne do scény).



Upřesnění aktuálního cíle:
---------------------------
- 1 player ship, 1 enemy ship
- střelba railgunem a raketama
  - zvukové efekty
  - exploze při zásazích, exploze při zničení lodi
  - grafika a fyzika vraku
- basic interface (healthbar, skillbar, zobrazení cooldownu na rakety).
  (na to asi budu muset rozběhat windows a vůbec základy gui).
- detekce zásahů, detekce kolizí lodí. Basic počítání hpček.
(překážky, tedy obecně objekty ve scéně, na tohle nejsou potřeba)


TODO: V rámci EnterFlightRequest.sendResponse() posílat
  zónu (respektive to z ní, co player vidí. A hlavně seznam
  toho, co se má preloadnout).
  - zatím to dělat nebudu a budu číst data zóny natvrdo.

TODO: V Client/EnterFlightRequest.process() creatnout zónu z poslaných dat
  (zatím ji tam budu natvrdo vyrábět).


TODO: Výhledově zdědit Client/Ship ze Shared/Ship
- ještě to dotáhnout.

TODO: Pokud nebudou potřeba data tilemapy po načtení shapů, tak je
  nedržet (tj. dát to do dočasné proměnné).
  (tzn. Zone.tilemaps by asi mělo být dočasné a ne class property)
- shapy v paměti držet budu.

Problém: Jak se dostat k json datům tilemapy, které loadnul Phaser?
  Možná takhle:
    let data = this.cache.json.get('levelData');
  JSON se případně preloaduje takhle (ale je blbost ho loadovat dvakrát):
    this.load.json("yourkey", "your.json")

TODO: V EnterShip.fakeLoadFighter() setovat i ostatní physics properties.
  (ve Vehicle budou jen defaultní).


Obecně se mi nechce dělat classy pro jednotlivé typy lodí.
- různou funkčnost zařídím prostě tak, že do nich dám různé zbraňové systémy,
  každý se svou funkčností.
=> Jednotlivé lodě musej bejt instance s různě nastavenými vlastnostmi.
  - to v zásadě můžu udělat i v kódu, prostě udělám 4x new Ship() a nasetuju
    jim properties (efektivně to je totéž jako load entity z disku).
{tohle si tu nechám, ať vím, kam směřuju}



TODO: Umožnit na klientu víc lodí.
- a pořádně to projít i na serveru, asi je to teď lehce zmatený.
  (getPlayerShip() je ale ok řešení, asi by šlo použít i na klientu).
- tohle pořeší předělání na scény, ale i tak to projít


TODO: doladit vizuály exhaustů
- úlně je schovávat, když nejsou aktivní.
- dát jim nějakou minimální délku (jako u zadních).

TODO: Server root jsem vrátil na ${workspaceRoot} - server servuje
  klienta, takže to dává smysl.
  - možná by se Client mohl rovnou jmenovat WWW, wwwRoot, nebo tak něco
    (i když, Client je asi ok).
- Potom je taky otázka, jestli má vůbec smysl adresář /Server.
  Spíš ne, je to akorát matoucí. Momentálně obsahuje /js a /Keys,
  což obojí asi může bejt rovnou v rootu (/js by se možná mohlo jmenovat
  /build, ale na clientu je to /js, tak asi dává smysl mít to stejně).
(Tohle je teda zrovna dost blbý dělat, když se to nedá přeložit, pustit
 a otestovat, takže to asi odložím.)
- otázka je, co s adresářem /Server. Buď ho zrušit úplně a přesnout
  /Server/js do rootu, nebo ho přejmenovat na Build, takže by bylo
  /Build/js/...
  - /Build by měl smysl, kdyby do něj časem přistálo víc věcí, než jen
    javascript. A taky je idiomatický (líp vyjadřuje, o co jde, než čistě /js)
  - hmm, nebo /bin? i když, /Bin by asi vypadalo blbě, takže spíš /Build
Ok, přejmenuju /Server na /Build.

TODO: odchytávat výjimky z Tilemap.getShape().



TODO: Refactoriiiing!
- Místo Phaser.Scene všude předávat Scene
  (což je z ní beztak zděděné, ale je to můj interní typ).

TODO: Když umře server tak SendWaypoint na klientu hodí Uncaught Error.

TODO: Projít všechny metody ve Vehicle, jestli musejí být public.


Opravy steeringu
-----------------

TODO: Přijde mi, že MAXIMUM_SPEED lodi nic nedělá
- vektory jsou delší, to jo, ale vizuálně loď neletí rychlejš.
- a taky je divný, že se pořád letí na maximum thrust
  (to je teda fajn - sice to není fyzikálně správně, ale vypadá to dobře).

TODO: Odchytávání výjimek ze Steeringu.
- to už možná je, ale chce to zkontrolovat.

 Refactorovat steering
- různá chování počítají jen desired velocity
  I když, to je otázka.
  - Za prvé nevím, jestli bude fungovat skládání behaviourů přes rychlosti
    (nejspíš je nějakej důvod, proč se skládaj až výsledné steering forces)
  - Za druhé nevím, co složitější behaviours s těma silama dělaj...
Ok, asi se raději budu držet skládání sil.

TODO: Forward thrust se z nějakých důvodů limituje na 80% výkonu.

TODO: Steering by se možná choval líp, kdyby se prostě loď nejdřív otočila
  do požadovaného směru a pak se aplikoval jen forward/backward thrust.
- rozhodně to budu muset ještě poladit.
TODO: Asi budu muset přece jen trošku poladit arrive() - na thrusterech
  je vidět, jak se to občas chová divně.
TODO: Opravit "backlash" při zastavování.


Far TODO:
----------
3) Dát něco do scény.
4) Vyhýbání (překážkám a jiným lodím).
7) Bullets (railgun a tak)
8) Rakety!
9) Lag simulátor a interpolace na clientu, aby se to netrhalo.
   - zatím asi až tak moc nespěchá, hratelný to bude i bez toho.

-----------------------------------------------------------------------


Prozatímní řešení client-server predikce
-----------------------------------------

TODO: Napsat "simulátor lagu"
  (random setInterval() před posláním packetu).


TODO: Fyziku přesunout do shared kódu (ve finálu tam bude muset bejt,
  aby šlo dělat client-side simulaci, tak bych s tím rovnou mohli počítat.
  (klient-side simulaci ale zatím dělat nebudu).

TODO: Na klienta posílat nejen aktuální stav, ale i rychlost a rotaci.
  Klient bude pokračovat v pohybu, kterej se od serveru dozvěděl.
  - resetne se to v okamžiku nového příchozího packetu
    (možná postupná interpolace pozice?)
  - predikce poběží jen určitej čas (třeba 100ms nebo tak nějak),
    pak se pohyb utlumí do nuly (aby se mi nestávalo to co v AOčku, tj.
    že při velkém lagu objekt ustřelí kamsi do dáli. Zastavit ho je mnohem
    lepší).

-----------------------------------------------------------------------

Bugfixy phaseru:
-------------------

TODO: Sledovat opravu https://github.com/photonstorm/phaser/pull/3964
  (momentálně mám hacknutou client-side opravu v 'up: function (event, time)').
  https://github.com/photonstorm/phaser/issues/3779



Odložené TODO:
---------------

TODO: Packety se serializují, takže bych neměl spoléhat na to, že se provede
  konstruktor. Navíc prázná pole a objekty se vůbec neposílají a spoléhá se,
  že jsou na druhé straně inicializované na nějakou defaultní hodnotu.
=> Asi bych měl ve všech packetech důsledně všem propertiesům dávat defaultní
  hodnoty.
=> A možná bych v Serializable objektech vůbec neměl používat konstruktor.
{obecně nevím, jak tohle ošetřit. Asi leda commentem na začátku souborů}
- jo a mohl bych tam asi opravdu zrušit konstruktory a setovat všechno
  dodatečně.

TODO: Zvážit, že by physics shapy byly entity (měly by unikátní idčko a tak).

TODO: Updatnout Tilemap.Data podle
  http://docs.mapeditor.org/en/stable/reference/tmx-map-format/
- respektive je tam i verze pro JSON.

TODO: Výhledově místo atlas animací používat tile animace vytvořené v Tiled
  editoru a číst je z dat tilemapy.

TODO: Časem udělat (pre)loadovací scénu.
- to pak znamená jinak loadovat pluginy, viz:
  https://github.com/photonstorm/phaser3-plugin-template


TODO: Možná by stálo za to transformaci souřadnic ještě upravit, aby [0, 0]
  bylo uprostřed obrazovky.
  (protože typicky budu chtít loď uprostřed obrazovky...)
  - i když, to možná bude lepší vyřešit kamerou.


TODO: Zapínání a vypínání debug grafiky.
- flaga na zapnutí debug view by asi měla bejt na serveru (v accountu?)
      (bude přepínat, jestli se ve SceneUpdate bude nebo nebude
       posílat info na debug draw a když tam bude, tak ho klient
       prostě vykreslí
       - otázka ale je, co s vykreslováním bounding boxů, které
         se neposílají v každém paketu
         - asi se přepínání bude muset posílat taky).


TODO: SetWaypoint by se asi mělo posílat z něčeho jinýho než
  z Waypointu.
  - ani scéna by to neměla dělat. Možná engine?


TODO: Výhledově zrušit posílání ShipToScene
  z WebSocketServer.acceptConnection()
  a posílat ho až po nalogování playera do hry.


TODO: Výhledově líp pořešit keyboard handling. Psát extra handler na každou
  klávesu je dost overkill, navíc by se blbě psalo mapování keybindů.
  - asi to můžu udělat přes DOM eventy místo přes Phaser.


TODO: Klikání na objekty ve hře:
  You could do this using Query.point giving a mouse position and
  Composite.allBodies(engine.world). This will give you a list of
  bodies under the mouse.


TODO: Mrknout na:
  var game = new Phaser.Game("100%", "100%", Phaser.CANVAS, 'parent');
  ...
  game.scale.scaleMode = Phaser.ScaleManager.RESIZE
https://stackoverflow.com/questions/28227090/phaser-make-background-screen-width-instead-of-content-width


TODO: Vyzkoušet linear a angular drag (zapnout na physicsBody).
- to by teoreticky mělo způsobit, že síla bude muset působit pořád,
  abych udržel rychlost. Na druhou stranu...
Tohle ale až časem (možná vůbec). Současná varianta je celkem ok.


TODO: Asi budu potřebovat seekForward() a seekBackward()
(protože v současném módu se couvat moc nedá).
IDEA: Dozadu by se mohlo jet tak, že kliknu před loď a dragnu skrz loď za ni.
// IDEA: Se shiftem loď strafuje/couvá.

TODO: Odhackovat Client/Phaser/Sound.setVolume();

-----------------------------------------------------------------------

Výhledové TODO:
-----------------

TODO: Neposílat všem playerům updaty všech zón, stačí každému poslat
  update zóny, ve které se nachází.
  (Server/Game/updateClients())

TODO: Konstantu FPS ve Vehicle.ts hodit někam jinam (udělat jednu konstantu
  pro veškeré časování a tu všude používat).
- možná do Engine, pokud něco takovýho bude existovat.

TODO: Až bude Vehicle zděděné z Entity, zrušit Vehicle.getErrorIdString().

TODO: Hlasitost zvuku ostatních lidí snižovat se vzdáleností od pozice
  hráčovy lodě (nejspíš ne od pozice kamery).


TODO: Vyzkoušet dekompozici nekonvexních pologynů na konvexní:
  https://github.com/Louis-T/fernandez-polygon-decomposition
  https://github.com/schteppe/poly-decomp.js/
  - ten druhej asi neumí díry (a navíc má koordináty v poli), takže
    asi spíš ten první.
  - ideálně by se to mělo procesit offline, ale co už.
Spíš to asi odložím. Zatím můžu ručně editovat čiste konvexní polygony
  (ostatně to znamená rychlejší start.


TODO: Pořešit FileSystem.isEmpty() a FileSystem.isEmptySync()
- jsou v 'extfs', který jsem zrušil, nejsou ve 'fs-extra'


TODO: Použít https://letsencrypt.org/


TODO: Přidat comment k Serializable.deserialize(), jak se loadují
  entity (nějak přes Entities)


TODO: (Znovu) vyzkoušet ES6 moduly v browseru.
https://medium.com/dev-channel/es6-modules-in-chrome-canary-m60-ba588dfb8ab7
   <script type="module" src="module.js"></script>
- nefungují, protože browser vyžaduje v importech '.js' a typescript
  ho tam se zapnutým outputem "module": "es2015" nedává.
  viz https://github.com/Microsoft/TypeScript/issues/16577


TODO: Prostudovat avanced Typescript typy:
  https://levelup.gitconnected.com/advanced-typescript-types-with-examples-1d144e4eda9e
- nebo si to možná hodit do nějakého typescriptového howtu či manuálu.


TODO: Výhledově místo neposílání paketů do closed connection
  při disconnectu disablovat komplet herní keyboard processing.
  (viz Keyboard.sendPlayerInput())
  - component.hide() nestačí, to je vypne zobrazování.


Tslint
--------

TODO: Nepovedlo se mi rozplazit tslint extension, kterej by lintoval
  při psaní a zároveň nežral message reportnuté z buildu, které
  vyžadují type info.
    HINT: "problemMatcher": [ "$tslint5" ] je definovaný v tslint extensioně,
    takže když zapnu nějakou jinou, přestane fungovat matchování tslintových
    problémů při rebuildu.

TODO: Výhledově ještě jednou zkusit zapnout "no-unsafe-any" v tslintu
  (teď už na to nemám sílu).
TODO: Výhledově ještě jednou zkusit zapnout "strict-boolean-expressions"
  (teď už na to nemám sílu).
  - IDEA je v Serializable nepovolit v serialize/deserialize paramu
    typ any, ale nejspíš jen union některých typů.
    (bude to nejspíš znamenat, že už při vytváření paramů budu muset ošetřit,
      jestli tam neleze null nebo undefined, ale mělo by to pak dál
      ušetřit některé testy).

TODO: Tslint (co momentálně nejde v tslintu nastavit):
- zakázat newline na konci souboru
- Vyžadovat newline za if (), while() a podobně
  (teď se dá napsat na jednu řádku if (x === 0) { doSomething(); }).
- závorky za funkcí (volání i deklarace)
- jednořádkové if/for/do/while
  (mělo by to bejt tak, že když je za ifem jeden řádek a je to return nebo
   throw, tak {} být nemusí, jinak ano).
   - Hmm a vlastně ani to vždycky neplatí, protože když je za ifem
     throw new Error(), kterej se nevejde na jeden řádek, tak je taky lepší
     ho uzávorkovat do {}.
- kontroly vyžadující type information
