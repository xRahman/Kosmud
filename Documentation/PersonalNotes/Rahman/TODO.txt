TODO: Možná by stálo za to transofrmaci souřadnic ještě upravit, aby [0, 0]
  bylo uprostřed obrazovky.
  (protože typicky budu chtít loď uprostřed obrazovky...)
  - i když, to možná bude lepší vyřešit kamerou.

TODO: "Dobržďování" při rotaci by možná šlo zrychlit tím, že
  nebudu angular velocity limitovat hned, ale až když bude zbývat jen
  část mojí ANGULAR_VELOCITY (třeba desetina).
TODO: a možná bych mohl udělati "zrychlování" rotace, tj. aby to z 0 na full
  neskočilo okamžitě.

TODO: Asi budu potřebovat seekForward() a seekBackward()
(protože v současném módu se couvat moc nedá).
IDEA: Dozadu by se mohlo jet tak, že kliknu před loď a dragnu skrz loď za ni.

TODO: Výhledově v Client/Phaser nechat jen wrappery Phaser objektů.
  Zbytek hodit do jiného adresáře
  (Engine? Potom ale PhaserEngine bude jinde...).
  Navíc je Ship záležitost enginu nebo hry?
    (ono na klientu asi hra moc smysl nedává tak jako tak).
  I když... Na serveru je Ship taky v Game, takže by to aspoň bylo
  konzistentní.

Phaser
  Camera
  Container
  Scene
  SceneContents (Sice to není wrapper Phaser objectu, ale patří to do Scene,
    což wrapper je.)
  Graphics
  Keyboard
  Mouse
  phaser.d.ts
  Renderer (do kterého je mergnutý PhaserEngine)
  PhaserObject
  Sprite
Game
  Ship
NevímKam (Scene? FlightScene?)
  Background
  DestinationMarker (Waypoint)
  FlightScene
  FlightSceneContents
  GeometryGraphics (tohle by se mělo jmenovat jinak. PhysicsShape?
    a stejně jako u ShipVectors - renderování by mělo bejt v ShipGraphics, ale
    data by se měla držet v Ship (a předávat do ShipGraphics jako parametr)).
  ShipGraphics? (to asi spíš do Scene než do Game)
  ShipVectors?
    (jako renderuje to, ale taky je to drží informace o lodi.
    Takže možná spíš Game? Na druhou stranu by to asi mělo bejt obecnější,
    vektory maj obecně všechny pohybující se objekty (tzn. Vehicles)

TODO: Sloučit PhaserEngine do Rendereru.
  Renderer (to už vůbec nevím kam. Scéna? Nerenderuje jen scénu...
    možná sloučit Renderer a PhaserEngine - to zní rozumně (asi pod Renderer)
- Renderer.getPhaserEngine() nemusí bejt public
  (může se to jmenovat getInstance).


TODO:
S vektory v lodi by to mělo bejt tak, že data jsou zvlášť (v Game)
  a příslušný Graphics oject (tedy renderování) by měl bejt v ShipGraphics
  (to, že se renderuje nezávisle na containeru, na věci nic nemění. Je to
   prostě součást grafiky).
  Při renderování by se měly vektory předat do ShipGraphics jako parametr.
A ShipGraphics tudíž může bejt ve Scene (respektive FlightScene).



TODO: Odstranit debugovací kód ze Steering.seek().


TODO: DestinationMarker by se možná mohl jmenovat Waypoint
  (waypointů může ostatně jít zadat i víc, pak by se to obzvlášť hodilo)
- Server/Ship.seekPosition() by se mohla jmenovat setWaypoint().

TODO: Zamyslet se nad linter messagema se zapnutými type checky
  (i když to třeba pak nechám vypnutý).

Ok, co dál:
- načítat data z Tiles editoru nepotřebuju, dokud nebudu řešit kolize,
  vyhýbání se překážkám a tak.

Potřebuju vyzkoušet steering behaviours (obecně si ujasnit, jak se bude
  ovládat loď).
  - follow by asi mohlo stačit.
  - a close nejspíš (zastavování).
    - zatím vůči jednomu bodu (mouse click).
    - časem vůči nejbližšímu vertexu od všech překážek v určité vzdálensoti.



TODO:
  7. update vehicle rotation according to the angle of the vehicle velocity
  (Vůbec jsem na pár kroků seek() zapomněl).

TODO: Omezit ve Steering.seek() rotaci a vracet ji jako další return value.

TODO: Aplikovat rotaci ze Steering.seek()
  (asi ne přes Torque Force ale rovnou přes SetAngularVelocity()).
  - což je ok, protože steering se volá v dalším tiku znova, takže se
    angular velocity bude průběžně updatovat.


Výhledově budu potřebovat načíst výstup z Tiled editoru.
- na serveru do fyziky, na klientu do grafiky


-----------------------------------------------------------------------

TODO: Shared/Game/Ship je možná zbytečná, Ship na clientu z ní není
  zděděná.
- tak možná ne, nějaké společné properties to už má.

-----------------------------------------------------------------------


Prozatímní řešení client-server predikce
-----------------------------------------

TODO: Napsat "simulátor lagu"
  (random setInterval() před posláním packetu).


TODO: Fyziku přesunout do shared kódu (ve finálu tam bude muset bejt,
  aby šlo dělat client-side simulaci, tak bych s tím rovnou mohli počítat.
  (klient-side simulaci ale zatím dělat nebudu).

TODO: Na klienta posílat nejen aktuální stav, ale i rychlost a rotaci.
  Klient bude pokračovat v pohybu, kterej se od serveru dozvěděl.
  - resetne se to v okamžiku nového příchozího packetu
    (možná postupná interpolace pozice?)
  - predikce poběží jen určitej čas (třeba 100ms nebo tak nějak),
    pak se pohyb utlumí do nuly (aby se mi nestávalo to co v AOčku, tj.
    že při velkém lagu objekt ustřelí kamsi do dáli. Zastavit ho je mnohem
    lepší).

-----------------------------------------------------------------------

Odložené TODO:
---------------

TODO: Zapínání a vypínání debug grafiky.
- flaga na zapnutí debug view by asi měla bejt na serveru (v accountu?)
      (bude přepínat, jestli se ve SceneUpdate bude nebo nebude
       posílat info na debug draw a když tam bude, tak ho klient
       prostě vykreslí
       - otázka ale je, co s vykreslováním bounding boxů, které
         se neposílají v každém paketu
         - asi se přepínání bude muset posílat taky).

TODO: SetDestination by se asi mělo posílat z něčeho jinýho než
  z DestinationMarkeru.
  - ani scéna by to neměla dělat. Možná engine?

TODO: Sledovat opravu https://github.com/photonstorm/phaser/pull/3964
  (momentálně mám hacknutou client-side opravu v 'up: function (event, time)').
  https://github.com/photonstorm/phaser/issues/3779




TODO: Výhledově zrušit posílání ShipToScene
  z WebSocketServer.acceptConnection()
  a posílat ho až po nalogování playera do hry.


TODO: Výhledově líp pořešit keyboard handling. Psát extra handler na každou
  klávesu je dost overkill, navíc by se blbě psalo mapování keybindů.
  - asi to můžu udělat přes DOM eventy místo přes Phaser.


TODO: Klikání na objekty ve hře:
  You could do this using Query.point giving a mouse position and
  Composite.allBodies(engine.world). This will give you a list of
  bodies under the mouse.


TODO: Mrknout na:
  var game = new Phaser.Game("100%", "100%", Phaser.CANVAS, 'parent');
  ...
  game.scale.scaleMode = Phaser.ScaleManager.RESIZE
https://stackoverflow.com/questions/28227090/phaser-make-background-screen-width-instead-of-content-width


-----------------------------------------------------------------------

Výhledové TODO:
-----------------

TODO: Tslint (co momentálně nejde v tslintu nastavit):
- zakázat newline na konci souboru
- Vyžadovat newline za if (), while() a podobně
  (teď se dá napsat na jednu řádku if (x === 0) { doSomething(); }).
- závorky za funkcí (volání i deklarace)
- jednořádkové if/for/do/while
  (mělo by to bejt tak, že když je za ifem jeden řádek a je to return nebo
   throw, tak {} být nemusí, jinak ano).
   - Hmm a vlastně ani to vždycky neplatí, protože když je za ifem
     throw new Error(), kterej se nevejde na jeden řádek, tak je taky lepší
     ho uzávorkovat do {}.
- kontroly vyžadující type information

TODO: Pořešit FileSystem.isEmpty() a FileSystem.isEmptySync()
- jsou v 'extfs', který jsem zrušil, nejsou ve 'fs-extra'


TODO: Použít https://letsencrypt.org/


TODO: Přidat comment k Serializable.deserialize(), jak se loadují
  entity (nějak přes Entities)


TODO: (Znovu) vyzkoušet ES6 moduly v browseru.
https://medium.com/dev-channel/es6-modules-in-chrome-canary-m60-ba588dfb8ab7
   <script type="module" src="module.js"></script>
- nefungují, protože browser vyžaduje v importech '.js' a typescript
  ho tam se zapnutým outputem "module": "es2015" nedává.
  viz https://github.com/Microsoft/TypeScript/issues/16577


TODO: Prostudovat avanced Typescript typy:
  https://levelup.gitconnected.com/advanced-typescript-types-with-examples-1d144e4eda9e
- nebo si to možná hodit do nějakého typescriptového howtu či manuálu.


TODO: Rozhodnout dilema s pojmeováváním class
- vidím to na SharedClass, Client/Class, Server/Class
- zatím používám trik:
   import * as Shared from '.../Class';
   class Class extends Shared.Class {}
Je to teda pořád otázka. ClientEntities a ServerEntities jsou asi názornější,
než když se tři classy jmenují stejně.


TODO: Výhledově sjednotit formát importů (asi import { ERROR } from './ERROR').
- spíš to nechám postaru. Vidět v importu, jestli je to ze /Shared, /Client
  nebo /Server je docela důležitý.


TODO: Výhledově místo neposílání paketů do closed connection
  při disconnectu disablovat komplet herní keyboard processing.
  (viz Keyboard.sendPlayerInput())
  - component.hide() nestačí, to je vypne zobrazování.