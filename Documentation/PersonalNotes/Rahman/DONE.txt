TODO: Zvážit SymmetricUnitRatio a UnitRatio
      místo UnitRatio a PositiveUnitRatio.
- UnitRatio je ve skutečnosti blbě, to může bejt třeba i 7:1
- Správné slovo je "Portion"
  - opět je ale otázka, co s <-1, 1>
    Portion, NonegativePortion?
ZeroToOne
MinusOneToOne
Portion
NonegativePortion
[vyhrálo ZeroToOne]

TODO: Někde jsem potratil vektory.
[fixed]

TODO: Předělat vyrábění StaticTilemapLayer a DynamicTilemapLayer
  (ty teda vyrábí tilemapa, ale princip by měl bejt stejnej).
- Ty se zatím nikde nevyráběj a jako parametr dostávají phaser tilemapu,
  nikoliv Tilemap, takže ok.
[won't do now]

TODO: Předělat Scene.createSound()
[done]

TODO: Předělat Scene.createTilemap()
[done]

TODO: Neměl by se PhaserObject.Config aplikovat v konstruktoru PhaserObjectu?
- asi jo, no. Chci po scéně věci, které by vůbec neměla dělat.
  Měla by prostě jen vyrobit příslušnej phaserObject a konec, setovat
  mu properties by měly wrappery.
V konstruktoru to nejde, ale je na to metoda applyConfig()
[done]

Hmm, ono by to asi celý mělo bejt tak, že scene.createNěco() vytvoří
  a vrátí rovnou wrapper, nikoliv interní phaserovou property.
  - takže createAnimation() by mělo vrátit Animation,
    createSound() by mělo vrátit sound, atd.
  - čili konstruktory wrapperů pak nebudou dostávat jako parametr
    Scene, ale to, co mají wrappovat.
{ Tohle asi nebrat - intuitivnější je udělat 'new Sprite()'. }
Bohužel teda u PhysicsWorld a createBody() to takhle nepůjde, protože
  v body si Vehicle drží fyzikální properties (a má ho tudíž od začátku,
  přestože ještě není v physics worldu).
  - Možná bych to ale mohl předělat, vrátit properties do PhysicsConfigu,
    nebo tak něčeho a PhysicsBody vyrábat opravdu až v addToPhysicsWorld().
    - asi jo.
[won't do]

TODO: Aktivita scény by se mohla zapisovat přímo do scény místo extra flagy.
  (sleep/wake, nebo tak něco).
- scene manager má přímo setActive() a isActive(), to by mohlo stačit
  (tzn. v konstruktoru by se setovalo setActive(false)).
(Aha a můžu použít setActive(boolean) místo activate/deactivate).
[done]

TODO: Graphics (a vůbec všechn phaser object wrappery) by měl
  v konstruktoru přijímat options (a možná i config) stejně jako
  Sprite.
- a měl by tam být container.
[done]

TODO: Potřebuju vůbec u phaser object wrapperů rozlišovat Config a Options?
- co brání tomu, aby to bylo v jednom objektu?
TODO: Config by mohl být zděděný z nějakýho základního Configu
  (PhaserObject.Config asi)
  - position, rotation, depth, container, ať neopakuju pořád stejnej kód.
[done]

TODO: Přejmenovat všechny modely na XxxModel.
  (a asi bych taky mohl sjednotit, jestli se dědí z Phaser object wrapperů,
   nebo se tyhle objekty wrappujou).
[done]

TODO: Vyhodit z BackgroundScene scrollFactor.
[done]

TODO: adresář FlightScene možná přejmenovat na Flight a BackgroundScene
  na Background?
[done]

TODO: Opravit resizování backgroundu
  (nejspíš se mi neprovolává resize() kam má).
{ Zatím to nechám takhle - funguje to, to stačí }
[done]

TODO: Udělat BackgroundScene
(BackgroundModel možná vůbec nebudu potřebovat - v BackgroundScene
 beztak bude jen jedna sprita).
- Background model jsem nechal, třeba do něj časem něco přibude.
[done]

TODO: Fyziku přesunout do shared kódu (ve finálu tam bude muset bejt,
  aby šlo dělat client-side simulaci, tak bych s tím rovnou mohl počítat.
  (klient-side simulaci ale zatím dělat nebudu).
  [done]

TODO: Server root jsem vrátil na ${workspaceRoot} - server servuje
  klienta, takže to dává smysl.
  - možná by se Client mohl rovnou jmenovat WWW, wwwRoot, nebo tak něco
    (i když, Client je asi ok).
- Potom je taky otázka, jestli má vůbec smysl adresář /Server.
  Spíš ne, je to akorát matoucí. Momentálně obsahuje /js a /Keys,
  což obojí asi může bejt rovnou v rootu (/js by se možná mohlo jmenovat
  /build, ale na clientu je to /js, tak asi dává smysl mít to stejně).
(Tohle je teda zrovna dost blbý dělat, když se to nedá přeložit, pustit
 a otestovat, takže to asi odložím.)
- otázka je, co s adresářem /Server. Buď ho zrušit úplně a přesnout
  /Server/js do rootu, nebo ho přejmenovat na Build, takže by bylo
  /Build/js/...
  - /Build by měl smysl, kdyby do něj časem přistálo víc věcí, než jen
    javascript. A taky je idiomatický (líp vyjadřuje, o co jde, než čistě /js)
  - hmm, nebo /bin? i když, /Bin by asi vypadalo blbě, takže spíš /Build
Ok, přejmenuju /Server na /Build.
[done]

TODO: Umožnit na klientu víc lodí.
- a pořádně to projít i na serveru, asi je to teď lehce zmatený.
  (getPlayerShip() je ale ok řešení, asi by šlo použít i na klientu).
- tohle pořeší předělání na scény, ale i tak to projít
{asi done - lodě jsou v zóně}
[done]

Problém: Jak se dostat k json datům tilemapy, které loadnul Phaser?
  Možná takhle:
    let data = this.cache.json.get('levelData');
  JSON se případně preloaduje takhle (ale je blbost ho loadovat dvakrát):
    this.load.json("yourkey", "your.json")
{Je to trochu jinak, čte se to z cache.tilemaps.get('levelData').data}
[done]

TODO: Výhledově zdědit Client/Ship ze Shared/Ship
- ještě to dotáhnout.
[done]

Takže TODO:
- posílat EnterFlightRequest až poté, co je vyrobená (ne preloadnutá)
  flight scéna.
[done]

Otázka je, jestli se má shape posílat v rámci přidávání lodě do scény,
nebo spíš na klientu vyrobit z dat tilemapy stejně jako na serveru.
- logičtější by asi bylo ho tam vyrobit, protože data tilemapy musí
  načíst tak jako tak.
  - bude tam ale pak chybět kontrola, že to má opravdu takovej shape, jako
    si myslím (jakej to má na serveru).
  - na druhou stranu posílat shape pro každou tilesu je blbost, stejně jako
    posílat ho pro každou loď znova.
Pak je ještě otázka, co všechno se má poslat s lodí, aby se dala na klientu
správně zobrazit.
- ideálně asi poslat celou entitu (její Shared část) a neřešit to...
- každopádně teď ale asi budu muset poslat shapeId
{shapy jsou pořešené, posílání lodě zatím počká}
[done]

TODO: Na clientu loadovat tilemapy ve scéně
- na to asi budu muset dát klientu vědět, jakou scénu má loadovat.
  (v rámci EnterGame?)
  - jednotlivé zóny budou instance stejné classy, takže bude opravdu
    potřeba ta data poslat.
  - místo ShipToScene pak taky budu posílat UpdateZone, nebo tak něco
    (a přibalit do toho celou shared Ship, místo abych z ní musel něco
     vytahovat).
  Posílat entity zatím nebudu - vezmu to natvrdo ze Zone.preloadData.
  - ok, to bych měl dělat v rámci preloadu scény.
TODO: A vyčíst z nich shapy
TODO: Ve FlightScene.createShip() použít shape loadnutej z tilemapy
  místo shapu poslaného ze serveru.
[done]

Scéna nepotřebuje odkaz na zónu - renderuje se zóna do scény, ne naopak.
- tzn. asi bych měl nejdřív vyrobit flight scénu a až pak si říct serveru
  o zónu (tzn. poslat EnterFlightRequest).
    Díky tomu pak bude existovat flightScene ve chvíli, kdy dostanu scénu
  a věci v ní, a tudíž jim můžu dát scénu jako parametru.
Nějak jsem to pořešil.
[done]

TODO: FlightScene.preload()
- loadovat podle seznamu v zóně.
[loadování je celé předělané]

TODO: Vyházet z konstructoru Client/Ship() vyrábění grafiky a tak
  a dělat to až z FlightScene.create()
  (nejspíš provolat scene.create(), která provolá create() jednotlivých
   lodí ve scéně).
- problém je, že pak grafické bazmeky v Shipu nebudou inicializované
  v konstruktoru. Možná je všechny sloučit do ShipGraphics?
  - ono to tak vlastně i je, jen exhausty a zvuky jsou mimo.
    (což možná není nutný, exhausty jsou očividně grafickej bazmek,
     takže klidně mohou být v shipGraphics.
  - Zvuky by tam ideálně měly bejt taky.
    - V tom případě by se to ale asi nemělo jmenovat ShipGraphics. Jak?
      - ShipMedia? ShipMultimedia? ShipAudiovisuals?
      ShipModel, ha!
[done]

TODO: zone.update() se nikde nevolá
  (tzn. se nevolá ani steerVehicles()).
[done]

TODO: Vyhodit vyrábění tilemapy z konstruktoru ShipModelu
  (tilemapa se bude vyrábět v creatu flightScény).
[done]

TODO: Mrknout se na serveru, jestli se initShapes() v zone.preload()
  nemůže volat až v creatu (na serveru to je všechno async, ale i tak
  by asi bylo lepší, aby to bylo stejně jako na klientu).
- zone.create() na serveru vůbec nemám, ale mám tam createPhysicsWorld(),
  s tím by se to možná dalo sloučit.
[loadování je celé předělané]

TODO: Scény přemístit do Scenes.ts
[done]

TODO: Scény vyrábět metodou, která je nacpe do setu a zkontroluje přitom,
  že je jméno unikátní.
[done]

TODO: Exhausty by měly být pod lodí, ne přes ní.
  (obávám se, že to možná bude znamenat, dát je do samostatného layeru).
  - nebo možná jen prohodit pořadí vytváření asetů.
Prohození pořadí vytváření assetů pomohlo, zatím to nechám být.
[done]

TODO: Vyrábět v zóně seznam shapů
- na serveru
  - tam se to snad dělá
- na klientu
Začnu tím, že flight scénu nebudu předávat do konfigu Phaser.Game 
(tím se totiž rovnou pustí preload() a create()), ale pouze ji vytvořím
 a preload pustím později ručně.
- FlightScene nesmí vyžadovat zónu.
[done]

TODO: Zkontrolovat, že se při vytvoření shipy na clientu
  správně získá shape ze zóny.
[done]

TODO: Ship na clientu budu muset asi pojmout úplně jinak
  - měla by být schopna existovat v zóně, i když ještě není ve scéně.
I když, hmmm.
  Možná, že ne - flight scéna přece jen asi může existovat už od začátku.
  Jen je teda otázka, jak vyřeším preload...
Zjevně se nějak řeší, jeslti je scéna "active", a tedy ji má Phaser automaticky
  loadnout a pustit, viz:
  http://www.html5gamedevs.com/topic/36148-phaser-3-scene-phaser-2-state-passing-data-to-init-when-start/
[done]

TODO: Loading scene: https://phaser.io/news/2018/05/phaser-3-preloader-tutorial
[done]

TODO: Ještě líp popsaný loading:  
https://jwiese.eu/en/blog/2018/04/phaser-3---loading-screen--asset-organization/
[done]

TODO: Vyrobit client verzi Zóny.
[done]

TODO: Zajímavá myšlenka: Předělat klienta přes async funkce, stejně
  jako server (metody preload() a create() by resolvnuly promisu,
  což by spustilo moji vlastní load() případně init() funkci).
- při té příležitosti používat flagu zone.active.
  (když budu z něčeho volat create(), tak tam můžu rovnou zavolat
   zone.activate()).
Renderer.startFlightZone() by to mohl spouštět
- respektive rozdělit ho na await Renderer.loadFlightZone() a následně
  create(), init(), nebo tak něco.
  - postload() asi radši ne, to by mátlo v souvislosti s preloadem (kterej)
    teda bude skrytej, ale i tak.
[done]

TODO: Pořešit TODO v Client/SceneUpdate.process().
[done]

PROBLÉM: Na serveru se loď při přidání do zóny rovnou přidá do physics
  worldu (což celkem dává smysl). Na klientu to ale asi nepůjde, protože
  ze zóny se čte, co se vlastně má loadovat, tudíž by v ní měly bejt lodě
  ještě před preloadem.
  - i když. Potřebuju v zóně insertnuté celé lodě, abych mohl začít
    preloadovat? Asi nepotřebuju.
    - v zásadě asi ani nepotřebuju seznam lodí (idček) v zóně
Ok, lodě se do zóny přidávají až v creatu (takže jdou přidat rovnou do physics
  worldu).
[done]

TODO: Aha, kurning. Při reloadu browser tabu se vyrobí nová connection,
  takže starej account zapomene...
ok, prozatím vyřešeno (Account je natvrdo v Accounts)
[done]

TODO: Když reloadnu browser tab, tak se znovu pošele EnterFlightRequest
  a znovu se vyrobí fighter (se stejným idčkem, takže neprojde přidání
  do scény).
Co s tím?
- buď musím při disconnectu player ship vyhodit ze scény a při dalším
  connectu ji tam zas vrátit (to asi nechci, tím by se mimo jiné dalo
  slušně cheatovat)
- nebo musím testovat, jestli ta loď už ve scéně je.
Nějak jsem to prozatím ohackoval
[done]

TODO: Create zvuků.
- zvuky by si asi měla vyrábět každá loď.
Idčko zvuku v ship.create() by se nemělo brát z preloadDat, ale z dat
  lodi.
(a opět se dostávám k tomu, že by zvuky asi měly bejt entity,
 Minimálně kvůli tomu, že když budu chtít změnit cestu ke zvuku u všech
 entit, které ten zvuk používají, tak to můžu přes entitu udělat na jednom
 místě).
Asi zatím do lodě idčko zvuku exhaustu můžu narvat natvrdo.
[done]

TODO: Preload zvuků (přidat je do zone.preloadData a přidat je do preload()
  na klientu)
[done]

TODO: Přejmenovat Client/Engine/Container na GraphicContainer
- včetně proměnné v ShipModel.
[done]

TODO: Umožnit, aby Ship.model nemusel existovat.
- a vyrábět ho až v create().
[done]

TODO: Přejmenovat property Client/Ship.graphics na model.
[done]

TODO: Hodit ShipSound do ShipModel.
[done]

TODO: Hodit ShipExhausts do ShipModel.
[done]

TODO: Hmm, ShipAudio by asi bylo lepší než ShipSound.
[done]

TODO: Přejmenovat ShipGraphics na ShipModel
[done]

TODO: Startnout flightZónu
  (nejspíš v EnterFlightResponse.process()).
[done]

TODO: Renderer by se možná mohl jmenovat Engine, ať je to stejně jako na
  serveru.
[done]

TODO: Scene by měla wrappovat Phaser.Scene, ne extendovat
  (všude mám wrappery jen scéna je potomek).
[done]

TODO: První packet na server můžu poslat, až když se spustí onOpen event.
- buď sendEnterFlightRequest() přesunu tam,
- nebo z connection.connect() udělám async fci, kterou z KosmudClient.start()
  awaitnu (connect() by vyrobila promisu a awaitnula ji).
Ta druhá varianta by znamenala, že se mezi connect() a otevřením socketu
  nebude moct nic jinýho dělat - leda bych tam awaitnul nějakou složenou
  promisu. Jednodušší asi v tom případě bude, udělat to callbackem.
[done]

TODO: Zóna by měla mít vlastní physics world.
- na klientu i na serveru.
[done]

TODO: Přidat ship do physicsWorldu.
- v Zone.addShip().
[done]

TODO: Na dvou místech transformuju z Tiled koordinátů do Phaser koordinátů
  (odečítá se tam půlka tilesy). Asi by stálo za to volat na to metody
   z CoordsTransform (čistě kvůli tomu, aby se dala snadno najít všechna
   místa, kde se transformují nějaké souřadnice).
[done]

TODO: getPlayerShip() na serveru nedává smysl - hráčských lodí tam bude víc.
- potřebuju propojit connection a ship.
  - buď do connection natvrdo vrazím odkaz na ship,
    nebo musím vyrobit Account
    - do connection dát odkaz na Account
    - do accountu dát odkaz na ship
Hmm, sakra, asi bych měl zavést event (packet classu) na EnterGame nebo
  tak něco, kterou klient pošle po připojení k serveru.
- ve zpracování tohohle eventu se vyrobí new Ship a setne
  se do connection (ještě lépe do accountu).
  (výhledově by se teda ship měla začít loadovat hned po autentifikaci, ať
   player zbytečně nečeká).
[done]

TODO: Struktura server aplikace:
- dávalo by asi větší smysl, kdyby loopoval Engine a Game jen tikala,
  stejně jako fyzika.
- steer() by možná neměl bejt součástí tiku fyziky, ale tiku hry.
  (protože při tom bude potřeba procházet herní entity).
[done]

Hmm, vyrábět PhysicsBody v konstruktoru Vehiclu asi nepůjde.
- musel bych physicsShapeId předávat konstruktoru jako parametr,
  což by asi zatím fungovalo, ale až to budou entity tak ne
  (leda by shapy byly entity, pak by se to provázalo automaticky při loadu
   - jenže tím bych měl inicializovaný pouze shape, nikoliv physics body).
Čili správné řešení asi je, že může existovat Vehicle mimo physics world
  (který tedy nemá physics body).
[done]
- hmm, pak to ale vlastně asi nebude nutný preloadovat (tilemapy asi jo,
  shapy z nich půjdou vytáhnou při initu - to se teda ostatně dělá už teď).
  - tzn. že bych se vrátil k tomu, že nemám shapeId, ale "adresu" shapu
    uvnitř tilemapy? (která tilemapa, který object layer, který objekt)
    To je asi blbost, shapeId dává smysl.
[done]
- Umožnit nemít vytvoření physicsBody by znamenalo ve Vehicle zavést metodu
  getPhysicsBody, která bude házet výjimku při neexistujícím physicsBody.
  Tzn. prakticky všechny metody ve Vehicle budou házet výjimky
  (na druhou stranu díky tomu se s tím bude pracovat jako teď, takže to je
   asi ok).
[done]

- Vyrobit Shared/Game/Zone (ať na to rovnou vidí i klient. Jo, to je určitě
  potřeba, protože tam bude seznam věcí, co se mají preloadnout + jejich
  idčka).
[done]
- dát do ní seznam tilemap a shapů, které se mají loadovat (čili ne do Ship!).
[done]
- v Zone.preload preloadovat tilemapy a vyrábět z nich shapy (podle seznamů).
  - to mimojiné znamená, že nepotřebuju Tilemaps.ts - tilemapy a shapy budou
    v zóně.
[done]

Asi bych taky mohl na serveru vytvořit Zónu, víceméně čistě pro posílení
  představy, že jedné zóně na serveru odpovídá jedna scéna na klientu
  (zóna je prostě všechno, co může bejt najednou v physics worldu a může
   to tudíž vzájemně interagovat).
[done]

TODO: Asi bych mohl udělat seznam toho, co se má pro scénu/zónu preloadnout.
  - zatím klidně natvrdo do scene.preload() (respektive na serveru
    zone.preload()) s tím, že časem to zřejmě bude savnuté v zóně
    (jaké prototypy zóna obsahuje).
[done]

TODO: Někde by asi měl existovat seznam tilemap a shapů, které se mají loadnout
  - Na druhou stranu to může bejt pro každou scénu jinak. Obecně každá scéna
    (ve smyslu zóna s jedním physics worldem) by měla vědět, co do ní patří.
    - momentálně mám jen jednu scénu/zónu, takže prostě při loadování
      je to potřeba vyjmenovat.
  Seznam je teď ve scéně (časm by se mohl sestavovat z prototypů entit
    vložených do scény, ale to je daleká budoucnost).
[done]
V zásadě jsem zase u toho, že buď musím udělat 4 classy pro 4 typy lodí,
  nebo musím zavést entity. Ovšem údaje o tom, jaké shapy je potřeba loadnout,
  dost dobře nemůžou mít až instance lodí...
Mohou to ovšem mít prototypové entity lodí.
- zatím budou 4 instance (ze kterých se časem stanou prototypy).
  properties jim setuju natvro ručně (zatím jen physics shape,
   časem přibudou minimálně ostatní physics properties).
[done, for now]

1) Opravit pohyb lodi, aby se rozumně otáčela a zabrzdila na waypointu
   (couvání a strafování zatím netřeba).
   - ještě to není úplně ok, ale prozatím se dá.
[done]
2) Efekty trysek (grafický a zvukový).
[done]
5) Lepší physics body shape pro loď
[done]
   (a pro překážky taky).
6) Anchor pointy (pro exhausty, časem pro zbraně).
   - je to ještě lepší - sprity se rovnou umisťujou v Tiled editoru.
[done]

TODO: Vehicle.addToPhysicsWorld() by si mělo o shape říkat zóně, ne
  Tilemapsům.
  (Vehicle by mělo vědět, ve které je zóně.)
[done]

Tilemaps.ts zatím vypadá, že by se měl jmenovat spíš PhysicsShapes.ts.
  - nope, shapy budou v zónách.
- respektive nejspíš nemusí existovat vůbec (a pokud, tak bude schraňovat
  tilemapy, ne shapy).
Zrušeno. Tilemapy si drží (vyrábí) zóny.
[done]

TODO: Vehicle by mohlo mít rovnou property physicsConfig místo samostatných
  properties, ze kterých se physicsConfig vyrobí.
- otázka ovšem je, jestli mi pak bude fungovat dědičnost
  (jako že defaultně asi nebude. Asi by fungovala, kdyby to byly opravdu
   entity, což ale zatím nejsou).
- a odněkud se taky musí brát shapeId...
Zatím jsem to vrátil přímo do classy, kvůli dědičnosti. Až budu mít
  prototypovou děčičnost entit, tak to můžu zvážit znova.
[done]

TODO: Preload physics shapů (zaregistruje a vrátí shapeId);
- ještě je teda otázka, jestli to držet v paměti, nebo to tahat z tilemapy.
- i když, vehicly se budou vytváře průběžně a pokaždý budou potřebovat shape.
  (to spíš bude možný po naparsování zahodit data tilemapy).
[done]

TODO idčko tilemapy definující physics shape by taky mohlo bejt rovnou ve Vehicle
  - Vehicle by si pak samo vytvářelo Physics shape.
Je tam shapeId, idčko tilemapy Vehicle nepotřebuje.
[done]

TODO: Ship by asi neměla dostávat jako parametr physicsConfig.
  Místo toho by asi tyhle properties měla rovnou mít (nejspíš v předkovi,
  ale to teď nemusím řešit). Od physics shapu asi stačí idčko s tím,
  že si shape vyžádá od nějakého manageru shapů (Zone).
[done]
- výhledově by asi taky neměla init těla a podobně dělat v konstruktoru,
  ale až v initu, protože to bude entita a bude se loadovat (init() se bude
  volat ručně po loadu).
- dělá se to přes addToPhysicsWorld()
[done]
Anyways, co s tím teď?
- Potřebuju beztak sloučit parametry (jméno tilemapy, jméno object layeru,
  jméno objectu v něm).
  - Takže kam s nima?
  Zatím to prostě narvu do Shared/Ship, nebudu se to snažit vyřešit
  všechno naráz. Konstruktory ať klidně konstruují, monetálně potřebuju
  hlavně sloučit konstanty na jedno místo v kódu (jako inicializované
  properties classy, ať se dají později měnit).
  - respektive fyzikální properties by asi měly bejt rovnou ve vehicle
    (tam už ostatně některé jsou, jen mimo classu).
- narval jsem to do zóny.
[done]

TODO: Jméno tilemapy by se mělo brát
  ze Shared/Game/Ship/TILEMAP_NAME (aby bylo stejný na klientu
  i na serveru - je to ostatně stejná tilemapa). Teď není Client/Ship
  zděděná ze Shared/Ship, takže to není tak jednoduchý.
  (viz ShipGraphics.constructor()).
[done]
TODO: Sloučit Ship na clientu a serveru, aby se používaly stejné
 properties (názvy layerů, cesta k tilemapě a tak).
 - Cesta k tilemapě teda bude muset mít jinej prefix.
[done]

TODO: Přehodit stuff ze Server/Tilemap do Shared/Tilemap.
TODO: Potřebuju já vůbec client/server verze Tilemap classy?
- liší se jen loadování a to by beztak bylo lepší dělat externě
  (loadnout json object a předhodit ho konstruktoru).
- poněkud jsem zapomněl, že na klientu tilemapu používá phaser...
  (tam teda vlastně asi nemusím řešit paměť, takže klidně můžu držet
   tilemapu v paměti 2x).
Každopádně ale client verze Tilemapy existovat musí.
[zrušnea Server/Tilemap]

TODO: Ještě jednou zvážit, jestli má být Config spíš v Physics nebo
  v PhysicsBody. Physics.Config se sice líp píše, ale technicky vzato
  to není konfig celé fyziky, ale opravdu cofig PhysicsBody.
- takže to asi spíš vrátit zpět do PhysicsBody.
[done]

TODO: Úplně se mi nelíbí, že je Tilemap pokaždý v jiným adresáři
  (v /Shared/Physics, /Server/Physics ale /Client/Phaser).
IDEA: Client/Phaser přejmenovat na Client/Engine
- pak by teoreticky mohl být i Shared/Engine a Server/Engine a Tilemap
  by mohla být tam.
- jo, udělám to tak.
[done]

TODO: Zdědit Vehicle z Entity (protože proč ne).
TODO: getErrorIdString() přejmenovat na getErrorId().
- nakoned je z toho getter 'debugId'.
[done]

TODO: Shared/Game/Ship je možná zbytečná, Ship na clientu z ní není
  zděděná.
- tak možná ne, nějaké společné properties to už má.
[won't do]

TODO: Výhledově Ship zdědit z Vehicle a přesunout tam věci, které by ship měla
sdílet s jinými pohyblivými objekty.
[done]

TODO: Výhledově sjednotit formát importů (asi import { ERROR } from './ERROR').
- spíš to nechám postaru. Vidět v importu, jestli je to ze /Shared, /Client
  nebo /Server je docela důležitý.
[done]

TODO: Rozhodnout dilema s pojmeováváním class
- vidím to na SharedClass, Client/Class, Server/Class
- zatím používám trik:
   import * as Shared from '.../Class';
   class Class extends Shared.Class {}
[done]

TODO: Změnit konstanty, aby hustota byla nějaké rozumné číslo.
- bude potřeba příslušně zvednout thrust, což je ok.
Nebude to tak jednoduchý: když to zvětším, tak pak musej
  bejt mnohem větší všechny thrusty, torques a tak a vektory
  jsou pak přes celou obrazovku.
- takže to zatím nechám bejt.
[won't do]

TODO:
- předělat tilemapu lodi tak, aby byla placnutá "normálně".
- a vrátit do kódu translaci.
  (důvod: fyzika je taky posunutá a translace tam je, tak ať je to stejně).
[done]

TODO: Dát návrh na rozvoj tile animation pluginu.
[done]

TODO: SceneUpdate by asi mělo parametry dostávat trochu víc strukturovaně
 (konstruktor s 20 parametry už je trochu přes míru...)
- sort of done
[done]


TODO: načíst výstup z Tiled editoru.
- na serveru do fyziky, na klientu do grafiky
Body zkusím editovat rovnou u tilesy (pokud to bude fungovat pro object layer).
https://medium.com/@michaelwesthadley/modular-game-worlds-in-phaser-3-tilemaps-1-958fc7e6bbd6
[done]

TODO: Tilemap by pak mohla ještě vytvářet StaticLayery a DynamicLayery.
- asi to můžu připravit, tj. classy StaticLayer a DynamicLayer zděděné klasicky
  z PhaserObjectu.
StaticTilemapLayer a DynamicTilemapLayer možná nebudou moci bejt PhaserObjecty,
protože jejich phaser varianty nejsou zděděné z GameObjectu.
- možná jim dát jiného předka? (TilemapLayer)?
- nebo možná zdědit DynamicTilemapLayer ze StaticTilemapLayer.
Zjevně to funguje, i když to v Phaseru zděděné není.
- Připravené to je, zatím to nechám být.
[done]

TODO: Asi bych měl udělat shared předka classy Tilemap,
  kterého různě implementuje klient a server. Časem budu chtít počítat
  fyziku i na klientu a asi budu chtít vyrábět zóny stejnejma metodama,
  tak ať to na to je připravený.
[done]

TODO: Ship.getShape() by si asi mohlo výsledek pamatovat, ať se pokaždý
 nevolá tilemap.getShape().
- na druhou stranu volá se to asi jen jednou (rovnou se z toho vytvoří
  physics body), takž je to asi ok.
[won't do]

TODO: Načíst physics shape lodi.
  OK, jak budu vyrábět ship?
  - primárně každopádně na serveru.
    - loadne se entita. Ta má příslušnej typ (prototyp), tzn.
      má nasetovaný properties, jako třeba jakou má použít tilemapu.
    - na server se pošle info o tom, z čeho se má pro loď vytvořit grafika
      (hmm, to zavání posláním prototypu, abych ty datový struktury
       nemusel deklarovat dvakrát)
       - Momentálně to každopádně můžu na klientu a na serveru vytvořit
         paralelně.
   Ship na serveru (nebo možná i v Shared) by každopádně měla mít
     info o tom, jakou tilemapu má použít. Prozatím to může bejt
     přiřazený natvrdo, nemusí se to loadovat z disku
     (to mi ostatně ušetří posílání prototypu na klienta - když
      to bude natvrdo v shared kódu, tak na to klient uvidí automaticky).
Async constructor asi nepůjde - to znamená, že:
- buď musím nejdřív loadnout tilemapu a až pak udělat new Ship
- nebo new Ship a pak await ship.load().
Ship tak jako tak nebude existovat od začátku, takže by asi dávalo větší
  smysl, aby měla všechny properties inicializované v konstruktoru.
- to znamená udělat nějakej preload.
[done]

TODO: Vehicly (a obecně herní objekty) by asi měly mít nastavenou hmotnost
  spíš než hustotu (hustota by se měla dopočítat).
  - na druhou stranu když pak zvětším loď na dvojnásobek, tak bude
    mít absurdní hustotu (zůstane jí hmotnost...)
[kašlat na to, hustota je ok]

TODO: Vůbec se mi nelíbí přetypování tilemapy. Mělo by se to loadovat
  jako Serializable, aby se kontrolovalo, že tam jsou patřičné properties.
- Ono to je nakonec asi ok. Když budou data jinak, tak to tak jako tak hodí
  exception. Sice nebude moc dobře popsaná a vysvětlená, ale zas mít kód
  plnej ošetřování možnáho 'undefined' by bylo taky dost naprd.
[it's ok]

TODO: Procházení dat tilemapy je dost šílený - asi to bude chtít
  udělat tak, že to projdu jen jednou a při tom vytahám všechna potřebná
  data.
- ideálně by se to mělo offline přechroustat do formátu, kterej se nemusí
  traverzovat (všechno rovnou zaindexovat), ale na to teď není prostor.
  - při tom by se daly rovnou rozřezávat nekonvexní polygony.
[done]

TODO: Přiřadit Ship shape do body
  (místo stávajícího hacku na obdélníkové body).
- Skoro!
TODO: Pořešit, proč jsou všechny polygony přes sebe.
[done]

TODO: Přesunout interface Tilemap.Data do Shared/Tilemap.
[done]

TODO: Nakonec pořádně projít a pročistit ShipGraphics, tam jsem hodně
  hackoval.
[done]

TODO:
- pojmenvávat důsledně layery ("_layer"), tilesety ("_tileset").
  (tohle asi stačí pro názvy konstant v kódu - v editoru to může
   bejt bez přípony, tam to je přehlednější).
- bez podtržítek, ale done.
[done]

TODO: Konzistentně dávat do klíčů, názvů layerů a podobně příponu, co to je.
  tzn: "thrusters_layer", "exhaust_animation"
- bez podtržítek, ale done.
[done]

TODO: Zamyslet se nad konvencí stringových jmen a idček
  (mohou tam být mezery - mělo by se to normálně číst. Otázka je, jestli
   Všechna Písmena Velká nebo jak (to moc jako normální čtení nezní)...)
[done]

TODO: .tmx formát tilemap asi vůbec není potřeba - Tiled editor by měl
  umět načítat rovnou JSON.
- cesty k texturám jsou relativní, takže záleží na tom, kde je soubor
  savnutej. Jinak je ten save stejne jako export.
  - tzn. asi budu editovat rovnou z /Client. Aspoň nebudu muset nic
    exportovat.
TODO: Tzn /RawData/TileMaps kompletně zrušit.
[done]

TODO: Zprovoznit debugování
  (abych mohl debugnout thruster backlash při dobržďování).
- ono to kupodivu v server kódu funuje.
[done]

TODO: Doma si pročistit font cache GIMPu, ať nestartuje 100 let.
[done]

TODO: Když vyrábím sprity z object layeru, tak se jim nenastavuje
  base scale.
- pokud to nebude fungovat samo, tak musím baseScale spočítat
  jako poměr stávající velikosti a velikosti v textuře.
[done]

TODO: Nějak budu muset pořešit preload tilemapy
- možná zdědit FlightSceneTilemap z TileMap?
  nebo udělat FlightSceneTilemaps jako container TileMap
  (protože zatím je sice jen jedna, ale bude jich určitě víc).
Hmm, FlightSceneTilemaps asi nebyl dobrej nápad, to asi může dělat
  rovnou ShipGraphics. Tilemapy nesouvisející s lodí budu beztak
  chtít dát někam samostatně.
[done]

TODO: Udělat ve Sprite víc konstruktorů
  (možnost předat rovnou vyrobenou spritu, nejspíš bez animace).
- udělal jsem to přes union type, ale asi done.
[done]

TODO: Výroba spritů z tilemap object layeru.
  - asi statická metoda Sprity? Ee, Tilemapy.
    Nebo možná udělat classu na tilemapu, která tohle bude dělat
    (to je lepší).
  - vrátí Array<Sprite>
  - jako parametr bere pole jmen objektů v layeru.
  - rovnou posune sprity aby byl origin uprostřed
  - rovnou na ně přiřadí a pustí texturovou animaci
    (to by měl zvládnout konstruktor spritu).
[done]

TODO: Rozdělit Sprite.baseScale na  Sprite.baseScaleX a Sprite.baseScaleY
- nastavovat to při vyrábění spritů v Tilemap.createSprites.
[done]

TODO: Ještě líp by se baseScale mělo zapamatovávat až v konstruktoru Spritu,
  když dostane jako parametry Sprite místo configu.
  - a ostatně baseScale by mělo být jen ve Sprite.Config, ne ve Sprite.Options.
[done]

TODO: Opravit pozice a scalování exhaustů.
Ha, phaserSprite.originX a phaserSprite.originY jsou ratia,
  ne absolutní hodnoty!
[done]

TODO: Že bych vůbec texturovou animaci nevyráběl automaticky při vytváření
  spritu, ale vždycky mimo?
  - pak bych mohl do konstruktoru spritu předat prostě jen jméno animace.
TODO: Má být createAnimation statická metoda Sprity?
- kde jinde by měla bejt?
  Je to přece jen sprite animation (tilové animace se zatím dělají jinak),
  takže to asi dává smysl.
[je to ok]

Ok, TODO: Vyrobit celou loď úplně znova.
- vymyslet lepší název než "rogue"
  - missile_ship, railgun_ship,
  + fighter, bomber, support, assault (zatím takhle)
  [done]
- zmenšit loď na půlku.
  [done]
- v Tiled editoru ji dát do object layeru
  [done]
  - ve hře z ní pak udělat spritu
- vyrobit texturu s exhausty v TexturePackeru
  + vyexportovat texture atlas
  [done]
- naimportovat ji do Tiled editoru, vyrobit z ní tilesy
  [done]

TODO: Hmm, textura pro lodě (a nejspíš i exhausty) by zřejmě neměla
  být jen jedna a ne pro každou loď zvlášť.
  - a tile-size by zřejmě měla bejt něco malýho (tzn. že loď bude přes více
    tilů). To možná dost zkomplikuje editaci shapu (u lodí ho asi nechci mít
    složený z X tilů, nebo jo?)
- asi se na to vykašlu a nechám 1 ship per tile (ovšem i tak jich můžu dát
  na texturu víc).
[zatím nechám 1 tile per ship]

TODO: Rozhodnout defaultní orientaci spritů.
  Asi by to mělo bejt tak, že nulová 'rotation' odpovídá defaultní
  pozici, takže orientace "doprava" je dobře.
  (to bude mít i fajn side effect, že to bude texture packer nativně
   skládat správně. Zas to ale možná bude divně v Tiled editoru... Co už).
   Budiž to "doprava"
[done]
- a pak ji všude dodržovat (u lodi, u exhaustů)...
TODO: Předělat exhausty "doprava" místo "dolů)
[done]

TODO: Pročistit data.
[done]
TODO: Vyrobit znova data pro ship_fighter
- jen object layery
[done]

TODO: vyzkoušet https://github.com/nkholski/phaser-animated-tiles
- nefunguje kvůli bugu, viz:
  https://github.com/nkholski/phaser-animated-tiles/issues/2
- a je otázka, jestli vůbec funguje na sprity vytvořené z object layeru
  (spíš asi ne).
TODO: Každopádně vyzkoušet sprite animaci aspoň na tiles layeru.
[done]
- a možná bych si pak ten converter mohl napsat...
Plugin teď asi vůbec nebudu potřebovat
[na to zatím kašlu]

TODO: Exhausts možná přejmenovat na Thrusters?
- každopádně se pro něco rozhodnout a používat to všude (včetně tilemapy lodi).
Nechám exhausts
[done]

IDEA: Nejjednodušší asi bude, vyrobit tu animaci znova v texture packeru
  s tím, že sprity nechám poskládat jednu vedle druhý, tzn. tu textutu
  budu moct beze změny využít jako tileset v Tiled editoru.
- a můžu zkusit requestnout tile animaci spritů vyrobených z object layerů
  v tile animation pluginu...
- vyzkoušeno, udělám to tak.
[done]

TODO: Vytáhnout info o animaci z tilemapy,
  vyrobit tuhle animaci ručně a přidělit ji na exhaust spritu vytvořenou
  z object layeru v tilemapě.
- vůbec nejdřív tu animaci prostě vytvořit ručně (ať mám představu).
[na tohle zatím kašlat]

IDEA: Ještě bych možná mohl zkusit, že místo vyrábění spritů z object layeru
  vyrobím nové tilesy do tile layeru.
- Hmm, vlastně bych ty thrustery rovnou mohl udělat jako static layer,
  teda až na to, že pak nepůjde scalovat velikost...
Problém trochu je, že tilesy jsou velikostí nastavené na loď a všechny
layery zjevně musej mít tilesy stejné.
  Takže asi leda udělat v mapě lodě základní tilesy podle animace exhaustů
  (loď holt bude přes víc tilesů) - to je dost pitomý, protože to pak
  bude fungovat jen na tuhle konkrétní animaci.
[na tohle kašlat]

TODO: Než se pustím do refactoringu kódu a dat tile animací, tak přece jen
  ještě vyzkoušet texture atlas animaci na exhaust.
[done]

TODO:
  Uncaught Error: Failed to resize scene 'Flight scene' because scene contents doesn't exist
    at FlightScene.resize (FlightScene.ts:113)
    at Object.resize (Renderer.ts:27)
    at CanvasDiv.onResize (CanvasDiv.ts:72)
    at CanvasDiv.window.addEventListener (CanvasDiv.ts:52)
- dlouho se loadovalo (v browseru) a do toho jsem otevřel konzoli v Chromu,
  takže došlo k resize okna. Nejspíš ještě scéna nebyla vytvořena.
- asi prostě jen neházet error - když scéna nemá contents,
  tak není co resizovat.
[done]

TODO: Nastavovat scale a visibility exhaustů podle thrustu/torque.
[done, sort of]

TODO: přidat baseVolume do Sound.
[done]

TODO: Nastavovat zvukům thrusterů volume podle thrustu.
[done]


TODO:
- Posílat na klienta thrusty a torque
  [done]
- Scalovat je a zapínat/vypínat podle thrustů a torque
[done]

TODO: Přidat classu ShipSound
[done]

TODO: Zjevně potřebuju classu Sound.
[done]

TODO: Exhausts by asi mohly být v samostatné classe.
- sprity ale pořád musej přidávat do ShipGraphics, tedy do containeru.
  - čili class ShipExhausts by měla mít taky referenci na ShipGraphics?
[done]

TODO: Udělat strafing thrustery mnohem menší.
[done]

TODO: Přidat do spritu baseScale, který se bude přinásobovat při setScale().
[done]

TODO: Natáčel loď bych měl směrem k desiredSteeringForce, nikoliv směrem
  k desiredVelocity.
  Tím se bude trochu "přetáčet".
  - tohle můžu dělat jen při seeku. Jakmile začnu brzdit, tak se tímhle
    točím do protisměru - tzn. je potřeba točit k -desiredSteeringForce.
[done]

TODO: Proč mám na začátku loď otočenou o 180°?
- asi se bere, že je ve fázi brždění, takže se aplikuje rotationFlip...
- vrátil jsem tam zpět zákaz točení při malé vzdálenosti, to to prozatím
  pořešilo
[done]

TODO: Přejmenovat adresáře v /Client (na PascalCase).
- Huh, v práci začíná všechno velkým.
- v práci je to každopádně dobře, ještě to checknout doma.
[done]

TODO: posílat aktuální thrusty
  (asi stačí číslama, není nutný posílat vektory).
- implementovat getForwardThrustRatio(),
  getLeftwardThrustRatio(),
  getTorqueRatio()
[done]

TODO: Arrive
- ještě správně počítat breaking distance.
TODO: Breaking distance se nepočítá spávně.
TODO: Asi budu ji budu muset posílat na klient a zobrazovat.
(jakž takž)
[done]

IDEA: Určit na tvrdo nějakou malou vzdálenost (10 třeba).
- před ní bude desired speed dejme tomu 10% aktuální.
- za ní bude gradual slowdown.
Skoro!
- ještě asi přidat, že když jsem fakt blízko cíli, tak se nebudu točit jak
  čamrda.
Bude to chtít hódně refactoringu, ale snad to funguje.
[done]

TODO: Jak pojmenovávat texture atlasy?
- mám několik efektů v jenom atlasu
- Adresář v TexturePackeru by se asi měl jmenovat stejně jako výsledný atlas
  (tj. Exhausts00).
  - což je vlastně vstupní adresář.
- Zjevně potřebuju nějakej adresář na "raw data". Možná SrcData?
  - raději RawData, ať se to nebije se /Src
- Kam patří tps file? (Texture packer project?)
  - Taky do RawData. Možná přímo do Textures - vždycky tam, kde je adresář,
    ze kterého je atlas udělanej.
  Tzn.:
  /RawData/Textures/Effects/Exhausts/Exhausts00.tps
  /RawData/Textures/Effects/Exhausts/Exhausts00/ExhaustBlueConical
  /RawData/Textures/Effects/Exhausts/Exhausts00/ExhaustYellowConical
  /RawData/Textures/Effects/Exhausts/Exhausts00/ExhaustYellowRectangular
.
- i kdyz to mozna není uplně chytrý, protože bych mohl chtít dělat
  atlasy napříč logickým rozdělením. Tzn. ne vsechny exhausty, ale
  spis vsechny textury k jedne lokaci/scene.
  - tzn. atlasy by mely mit nezavislou strukturu:
.
  - Spíš TexturePacks (atlas je to až vyexportované).
.
  /RawData/TexturePacks/Effects/Exhausts/Exhausts00.tps
.
  A textury taky:
.
  /RawData/Textures/Effects/Exhausts/ExhaustBlueConical
  /RawData/Textures/Effects/Exhausts/ExhaustYellowConical
  /RawData/Textures/Effects/Exhausts/ExhaustYellowRectangular
.
Možná zrušit Graphics a nahradit to rovnou podadresářema (Textures, atp?)
- asi nemusím rozlišovat texture atlasy a jiné textury
  (atlas má prostě u sebe ještě json)
.
/Client/Textures/Background
/Client/Textures/Effects/Exhausts
/Client/Textures/Markers
/Client/Textures/Ships
.
To samé v RawData (tj. /Textures/...)
[done]

TODO: Vymyslet lepší adresářovou strukturu pro TexturePacker
- output určitě rovnou do /Client, ať to nemusím překopírovávat
  a nemám to dvakrát.
[done]

TODO: Dát lodi všechny exhausty (a na správná místa)
- 2 velké dozadu
- 2 malé dopředu
- 2 doleva
- 2 doprava
[done]

TODO: Zdědit Ship ze Steering (tedy z Vehicle),
  ať nemusím do steeringových funkcí předávat takový stohy parametrů.
[done]

TODO: Fixnout errory v konzoli na klientu
  "Texture.frame missing: 1"
  "Invalid Animation Key, or Key already in use: animation_exhausts_00"
[done]

TODO: "Skákající animace": Možná je to buglé:
  https://github.com/photonstorm/phaser/issues/3288
- tak je to tím, že je v texture packeru povolená rotation
  Nenašel jsem na to vypínátko, ale pomohlo přepnout Algorithm na "basic".
[done]

TODO: To přetáčení budu muset přece jen ještě nějak stabilizovat...
[done]

TODO: Ehm, ona ta původní varianta se skládáním desiredSteeringForce
  z forward a leftward složky byla asi dobře - jsou to přece jen dva
  oddělené propulsion systémy, takže ve spolupráci opravdu dokáží
  poskládat sílu v obdélníku.
  - zase to zapnout a vyzkoušet (možná bude loď míň "plavat").
Tak ne - je to sice asi technicky správně, ale loď pak "plave" mnohem víc.
Revertuju zpět na novější verzi.
[done]

TODO: Vyzkoušet přece jen rotaci přes torque...
- Funguje!
[done]

TODO: "Dobržďování" při rotaci by možná šlo zrychlit tím, že
  nebudu angular velocity limitovat hned, ale až když bude zbývat jen
  část mojí ANGULAR_VELOCITY (třeba desetina).
[done]
TODO: a možná bych mohl udělati "zrychlování" rotace, tj. aby to z 0 na full
  neskočilo okamžitě.
- tohle jsem vyřešil přes torque
[done]

TODO: Pořád je tam problém s výpočtem směru rotace, to musím opravit.
[done]

TODO: Opravit šílené zrychlování do boku.
  Zjevně mám chybu v úvaze.
  - Když totiž limituju složky zvlášť, tak se mi změní směr vektoru.
  Tzn. musím:
  - Zjistit, jakým faktorem se limituje v jednotlivých směrech.
  - Menším z těch faktorům pronásobit původní vektor.
[done]

TODO: Zvážit, jestli je rozumný tahat ship position z grafiky (spíš není).
- tzn. pamatovat si ji v Ship.
[done]

TODO: Přejmenovat GeometryGraphics na něco rozumnějšího (ShapeGraphics)
[done]
TODO: A taky oddělit data od renderování.
[done]

TODO:
S vektory v lodi by to mělo bejt tak, že data jsou zvlášť (v Ship)
  a příslušný Graphics oject (tedy renderování) by měl bejt v ShipGraphics
  (to, že se renderuje nezávisle na containeru, na věci nic nemění. Je to
   prostě součást grafiky).
  Při renderování by se měly vektory předat do ShipGraphics jako parametr.
A ShipGraphics tudíž může bejt ve Scene (respektive FlightScene).
[done]

TODO: DestinationMarker by se možná mohl jmenovat Waypoint
  (waypointů může ostatně jít zadat i víc, pak by se to obzvlášť hodilo)
- Server/Ship.seekPosition() by se mohla jmenovat setWaypoint().
[done]

TODO: Všude přejmenovat Geometry na Shape.
[done]

TODO: Výhledově v Client/Phaser nechat jen wrappery Phaser objektů.
  Zbytek hodit do jiného adresáře
  (Engine? Potom ale PhaserEngine bude jinde...).
  Navíc je Ship záležitost enginu nebo hry?
    (ono na klientu asi hra moc smysl nedává tak jako tak).
  I když... Na serveru je Ship taky v Game, takže by to aspoň bylo
  konzistentní.
.
Phaser
  Camera
  Container
  Scene
  SceneContents (Sice to není wrapper Phaser objectu, ale patří to do Scene,
    což wrapper je.)
  Graphics
  Keyboard
  Mouse
  phaser.d.ts
  Renderer (do kterého je mergnutý PhaserEngine) [done]
  PhaserObject
  Sprite
Game
  Ship
FlightScene
  Background
  DestinationMarker (Waypoint)
  FlightScene
  FlightSceneContents
  GeometryGraphics (tohle by se mělo jmenovat jinak. PhysicsShape?
    a stejně jako u ShipVectors - renderování by mělo bejt v ShipGraphics, ale
    data by se měla držet v Ship (a předávat do ShipGraphics jako parametr)).
  ShipGraphics? (to asi spíš do Scene než do Game)
  ShipVectors?
    (jako renderuje to, ale taky je to drží informace o lodi.
    Takže možná spíš Game? Na druhou stranu by to asi mělo bejt obecnější,
    vektory maj obecně všechny pohybující se objekty (tzn. Vehicles)
[done]

TODO: Přejmenovat SetDestination na SetWaypoint.
[done]

TODO: Sloučit PhaserEngine do Rendereru.
  Renderer (to už vůbec nevím kam. Scéna? Nerenderuje jen scénu...
    možná sloučit Renderer a PhaserEngine - to zní rozumně (asi pod Renderer)
- Renderer.getPhaserEngine() nemusí bejt public
  (může se to jmenovat getInstance).
[done]

TODO: Vyřešit problém s odečítáním úhlů a cyklením po 2*PI.
[done]

TODO: Když jsou vektory mimo kontejner lodi, musí mí jinak z-order.
[done]

TODO: Rotaci lodě říkat 'rotation', ne 'angle'
[done]

TODO: Možná ještě přece jen PhaserObject zdědit (nejspíš z CoordsTransform)
  a přesunout tam metody na transformaci koordinátů.
  (transformVector(), transformPolygon(), transformAngle()).
  - obojí musí být tam i zpět (takže by ty metody asi měly bejt pojmenovaný
    podle toho, z čeho do čeho transformují).
    angleFromPhaserToBox2d()
    angleFromBox2dToPhaser()
    vectorFromPhaserToBox2d()
    vectorFromBox2dToPhaser()
    polygonFromPhaserToBox2d()
    polygonFromBox2dToPhaser()
    - nakonec stačí jedna sada funkcí, protože fungují oběma směry.
  - možná by nemuselo bejt potřeba zvlášť setX() a setY().
[done]

TODO: Vymyslet, kam dát funkce lowerBound(), upperBound() a intervalBound()
  (momentálně jsou ve Steering).
[done]
TODO: Ještě jednou zvážit rozdělení Utils (a možná přejmenování).
  - /Utils/StringUtils by mohlo být prostě Utils/String.
  - applyDefaults() by mohlo být v Utils/Object
  - reportMissingCase() těžko říct kam, možná do Syslogu?
    (sice to nic neloguje, aspoň ne přímo, ale asi proč ne).
  - lowerBound, upperBound a podobně buď do Utils/Math nebo Utils/Number.
[done]

TODO: Graphics by potřebovala oddělit kód kterej pracuje s Box2d koordinátama
 a kód na transformaci koordinátů.
 (částečně to je, DrawLine a DrawPolygon jsou ty transformační metody.
  Možná je hodit do předka?)
[done]

TODO:
  Tohle by chtělo udělat nějak líp:
    this.container.add(this.geometryGraphics.getGraphics());
  (možná zdědit ShipGraphics z Graphics?)
[done]

TODO: Phaser.GameObject wrappery přece jen z něčeho zdědit.
- transformace zajistí interní setX, setY a setAngle v předkovi.
- spousta metod je stejná, chce to nějak podědit.
[done]

TODO: seek() se pořád místy chová divně
- jen při couvání směrem trochu šikmo na levou trysku...
- problém byl v tom, že se odečítaly úhly v různých intervalech
  (což pak při ořezání na menší interval občas dělalo psí kusy)
[done]

TODO: Opravit background.
[done]

TODO: Pořešit transformaci koordinátů mezi serverem a klientem
- flip y axis
- flip all angles.
TODO: Ještě v Graphics.
[done]

TODO: Vektory nakonec nesmí být v kontejneru s grafikou lodi
  (netočí se, jsou absolutní).
  - jo, ale musej se translatovat na pozici lodi.
[done]

TODO: Fce jako setDesiredVelocity() v Client/Ship by asi neměly překreslovat
  debug grafiku rovnou, ale pouze queueovat requst na překreslení
  (ať se to zbytečně nepřekresluje víckrát v jednom tiku).
[done]

TODO: DebugGraphics by mohla být samostatná class.
- nakonec jen ShipVectors (ať je to single responsibility class).
  (debugGeometry je přímo Graphics, na to není třeba extra classa)
[done]

TODO: Debugové zobrazení fyziky na klientu
  - physics body (obrys)
    [done]
  - target position
    - k tomu budu potřebovat měnit pozici pouze při button_down
    [done]
  - desired velocity
    - k tomu ji budu muset posílat v rámci SceneUpdate
    [done]
  - steering force
    (a to před limitem i po limitu ať vidím, jak moc se mi to ořezává)
    - po limitu done.
  TODO: Ještě před limitem.
[done]

TODO: Destination marker by se výhledově asi měl renderovat v nějaké UI scéně
(aby nescaloval se zoomováním - i když, možná to bude ok...).
- zoomování vypadá ok.
[won't do]
TODO: Dát mu Z-order (menší než DEBUG ale větší než DEFAULT).
- správně by to mělo bejt:
  Překážky ve scéně
  - Waypointy
    - Ship
      - debug graphics
[done]
TODO: Dát lodi Z_ORDER_SHIPS
[done]
IMPORTANT: depth je potřeba nastavit kontejneru (v Ship). Celej obsah
  containeru má zřejmě jeho depth (+ uvnitř to ještě může bejt jinak).
[done]

TODO: Destination market by měl zmizet, když na cílové místo dorazím.
- to je asi zbytečný, loď ho prostě překreje.
[won't do]

TODO: Zvážit, jestli místo matter.js nepoužít radši Box2d
- zváženo a použito
[done]

TODO: Seekovat k destination markeru, ne k pozici myši.
- to asi znamená, posílat něco jinýho než MouseInput.
TODO: Vyrobit a posílat paket SetDestination
TODO: Zpracovávat SetDestination na serveru (místo MouseInputu).
[done]

TODO: Destination marker má zůstat viditelný i po releasu buttonu
[done]

TODO: Opravit detektování mouse-down.
- je to chyba v Phaseru
[done]

TODO: Smazat ./vscode/Build, až ho nebudu potřebovat.
[done]

TODO: Updatovat verzi tasks.json (budu to muset celý předělat...)
[done]

TODO: Vyhodit tslint option "no-unused-variables" a nahradit ji typescriptovou.
[done]

TODO: Vyzkoušet ještě lint options co chtějí type info.
- nepovedlo se mi rozběhat.
[done]

TODO: Zkusit pouštět tslint před tsc (sice v tslintu píšou,
  že se má pouštět až na zkompilovaný kód, ale třeba to není
  nutný).
  - pokud to bude ok, tak smazat příslušné commenty v tasks.json.
[done]

TODO: Přidat do build tasku mazání starého buildu.
[done]

TODO: Možná do build tasku hodit i lint celého kódu
  (ideálně s type information), ať se při rebuildu
  checkne všechno.
- pokud to rozběhnu, budu potřebovat -e na ignorování Box2d.
[done]

for those who use vscode with tslint as editor/lintinig you can add the
following to the vscode config:
// Configure glob patterns of file paths to exclude from linting
"tslint.exclude": "**/PATH_eg_TESTS/**/*.ts"
- musím opravit liter errory, abych zjistil, jestli to pak pustí tsc
  ve watch módu
[done]

TODO: Zvážit použití
  https://marketplace.visualstudio.com/items?itemName=eg2.ts-tslint
  (kvůlivá kontrolám, které vyžadují type information)
- nepovedlo se mi rozběhat
[done]

Warning: member-ordering - Bad member kind: public-before-private
Warning: The 'prefer-readonly' rule requires type information.
Warning: The 'promise-function-async' rule requires type information.
Warning: The 'await-promise' rule requires type information.
Warning: The 'no-floating-promises' rule requires type information.
Warning: The 'no-for-in-array' rule requires type information.
Warning: The 'no-inferred-empty-object-type' rule requires type information.
Warning: The 'no-unsafe-any' rule requires type information.
Warning: The 'restrict-plus-operands' rule requires type information.
Warning: The 'strict-boolean-expressions' rule requires type information.
Warning: The 'use-default-type-parameter' rule requires type information.
Warning: The 'deprecation' rule requires type information.
Warning: The 'match-default-export-name' rule requires type information.
Warning: The 'no-boolean-literal-compare' rule requires type information.
Warning: The 'no-unnecessary-type-assertion' rule requires type information.
Warning: The 'return-undefined' rule requires type information.
[Warn  - 6:31:20 PM] Warning: member-ordering - Bad member kind: public-before-private
[Warn  - 6:31:20 PM] Warning: The 'prefer-readonly' rule requires type information.
[Warn  - 6:31:20 PM] Warning: The 'promise-function-async' rule requires type information.
[Warn  - 6:31:20 PM] Warning: The 'await-promise' rule requires type information.
[Warn  - 6:31:20 PM] Warning: The 'no-floating-promises' rule requires type information.
[Warn  - 6:31:20 PM] Warning: The 'no-for-in-array' rule requires type information.
[Warn  - 6:31:20 PM] Warning: The 'no-inferred-empty-object-type' rule requires type information.
[Warn  - 6:31:20 PM] Warning: The 'no-unsafe-any' rule requires type information.
[Warn  - 6:31:20 PM] Warning: The 'restrict-plus-operands' rule requires type information.
[Warn  - 6:31:20 PM] Warning: The 'strict-boolean-expressions' rule requires type information.
[Warn  - 6:31:20 PM] Warning: The 'use-default-type-parameter' rule requires type information.
[Warn  - 6:31:20 PM] Warning: The 'deprecation' rule requires type information.
[Warn  - 6:31:20 PM] Warning: The 'match-default-export-name' rule requires type information.
[Warn  - 6:31:20 PM] Warning: The 'no-boolean-literal-compare' rule requires type information.
[Warn  - 6:31:20 PM] Warning: The 'no-unnecessary-type-assertion' rule requires type information.
[Warn  - 6:31:20 PM] Warning: The 'return-undefined' rule requires type information.
[Warn  - 6:33:48 PM] vscode-tslint: Cannot read tslint configuration - 'Failed to load c:\Brutus\Kosmud\Src\tslint.json: Unexpected string in JSON at position 1515 in c:\Brutus\Kosmud\Src\tslint.json'
[done]

TODO: Upgradnout verzi typecriptu (a možná i tslintu)
[done]

TODO (Tslint) import { Cosi } from...
- pořád se mi to moc nezdá, ale asi jo, no
  (každopádně to dává smysl, je to v podsatě vytahování properties z objektů).
[done]

TODO: Prozkoumat (a ideálně použít):
  https://decembersoft.com/posts/say-goodbye-to-relative-paths-in-typescript-imports/
(nejspíš bude stačit baseurl
 - nebude, na serveru to nefunguje a je potřeba nastavit NODE_PATH)
[done]

TODO: Nastavit z-order pro Ship.gebugGraphics.
[done]

TODO: debug čáry by to asi chtělo dát do stejné grupy jako Ship
  (respektive Ship bude group a v ní bude ship_hull, debug_draw a tak),
  abych to rotoval a posouval najednou.
  - musí to být container, s grupou se nedá hejbat.
Scene.create()
{
  let group = this.add.group();
  let sprite = this.add.sprite(400, 300, 'phaser');
  
  group.add(sprite);
}
[done]

TODO: Vyrobit classu Phaser/Graphics,
  která bude umět kreslit čáry (a rovnou třeba vykreslist Geometry).
- je otázkla, jestli strokePoints() bude dělat to, co si myslím, ale
  třeba jo. Musím to vyzkoušet.
[done]

TODO: Zdědit FlightScene ze Scene a rozhodit mezi ně kód.
- DEPTH_COSI by asi měly bejt až ve FlightScene.
[done]

TODO: Steně tak asi rovnou vyrobit i FlightSceneContents
[done]


TODO: Zrušit přidávání shipy do scény při creatu scény.
[done]
TODO: Procesit ShipToScene na clientu (přidat ship do scény).
- možný problém: ShipToScene může klidně přijít před vytvořením
  scény (až se bude dýl loadovat, tak to dokonce bude celkem pravděpodobný).
[done]
Co s tím?
- buď si to nabufferovat a zpracovat to až ve chvíli, kdy bude scéna existovat.
  - tohle má výhodu v tom, že se mohou data poslat ještě v průběhu loadování.
- nebo po vytvoření scény poslat na server request.
TODO: Do Scene přidat buffer na přidávání věcí do scény.
  - dokud není scéna vytvořená, dávat ShipToScene do bufferu.
  - při vytvoření zpracovat ShipToScene z bufferu.
[done]

TODO: Na klientu nevyrábět ship rovnou, ale až když mi přijde
  packet s přidáním shipy do scény.
- player se teda asi bude na scénu přidávat rovnou při loginu
  (respektive spíš při EnterGame), ale přidávat se budou i jiný
  entity v průběhu, takže se to neztratí.
(Technicky vzato je to update scény, ale asi je lepší udělat novej typ
 packetu, než dělat komplikovaný vnitřní typy).
[done]

TODO: Mergnout SceneContents a Scene.
- to asi nebyl úplně nejlepší nápad. Teď zas musím ošetřovat každou property
  zvlášť. Mít to sdružený dohromady dávalo smysl.
Takže jinak: Nechat SceneContents, ale jen jako data container, nedávat do
  něj metody. Scéna prostě bude přistupovat přes this.contentns.camera apod.
[done]

TODO: Na serveru vyrábět a posílat paket ShipToScene
- otázka je kdy.
  - asi jako response na přihlášení klienta
    (nejspíš tam, co se bude výhledově posílat LoginRequest či co...
     - hmm, to asi nepůjde, páč komunikace po connectu začíná až tím,
       že user klikne na login button - pak se pošle LoginRequest)
     - takže asi zatím natvrdo do WebSocketServer.onNewConnection.
[done]

TODO: Je blbost posílat geometrii v každém tiku, takže:
- vyrobit packet "Přidávám playera na scénu"
  [done]
  - ShipToScene (přejmenovat to můžu vždycky)
- ten bude obsahovat:
  - geometrii.
    [done]
  - startovní pozici
    [done]
  - co vlastně přidávám
    (to zatím řešit nebudu)
[done]

TODO: Remove unecessary constructors from packet classes.
[done]

TODO: Udělat 'version' static.
[done]
TODO: Nepsat 'version' do paketů a nekontrolovat ji při deserializaci.
[done]

TODO: Možná by v Packetech přece jen nemusel bejt Vector, ale pouze
  {x, y}. Posílalo by se míň dat (a fungovat to asi bude taky)
  - otázka je, jak ten typ pojmenovat. XY? Coords?
  - a kam ho dát? Do Types? Do Packetu, protože se bude používat jen
    v packetech?
  - nebo prostě Packet.Vector...
[done]
- blbý je, že se to musí konvertit ručně, páč Vector se vleze do
  interfacu { x, y }...
Možná teda vyžadovat v constructoru packetů paramety (x: number, y: number)
  místo složeného typu (to zabrání předání a tedy assignování vectoru).
- err, to je taky naprd.
Takže jinak:
TODO: Vrátit do packetů vectory a upravit Serializační kód aby byl výsledek
  míň ukecanej.
[done]

TODO: metoda Vector.setLength();
- normalize
- scale
[done]

TODO: Použít classu Vector všude kde jsou koordináty
- místo GameEntity.Position
  [done]
- místo { x: number, y: number }
  [done]
- místo b2Vec2
[done]

TODO: Fix onBeforeUnload
- když je connection closed nebo closing, nezavírat ji.
[done]

TODO: Naučit Serializable savovat Vectory, aby Vector nemusel bejt zděděnej
  ze Serializable.
- netestováno
[done]

TODO: Vyrobit classu Vector (v Physics)
- Math ne, to by kolidovalo s javascriptovým Math.
[done]

TODO: Rozdělit PlayerInput na MouseInput a KeyboardInput
(nemusel bych dělat komplikovanej vnitřní typ).
[done]

TODO: Vymyslet, jak to udělat s typama
- určitě chci Position (nebo Vector?)
- otázka je, jestli to opravdu má bejt v GameEntity.
  Smysl to sice jakž takž dává, ale GameEntity není ničím zvláštní.
- Možná to hodit do Types?
- Nebo použít Vector (ať se s tím dá rovnou počítat?)
  - asi jo.
- Vector by asi měl bejt Serializable
[done]

TODO: Implementovat "Follow mouse position"
- posílat mouse_position na server
  [done]
- implementovat Steering.seek()
  [done]
- aplikovat steering force na ship
  [done]

Zatím mi ale stačí natvrdo jedno body pro ship, takže to prostě hacknu
  a uvidíme.
[done]

Aktuální TODO:
- umím vyrobit Box2D body (respektive PhysicsBody).
- někde vyrobit world
[done]
- v něm vyrobit body pro ship
[done]
- posílat na klienta pozici a rotaci shipy
[done]
- na klientovi to vykreslovat
  - transformovat souřadnice a rotace
    - tohle nějak záhadně není potřeba
      (nebo to možná dělám a ani o tom nevím. Asi správně zvolená znaménka
        u zatáčení na serveru).
  - setovat pozici a rotaci
[done]

TODO: Zatrhnout prohledávání TODO, DONE a CONTEMPLATION
- možná to rovnou přehodit někam do Users/Rahman
[done]

TODO: Jo a zatrhnout prohledávání Shared/Box2D
[done]


TODO: Dodělat cleanup a refactoring:
.
+Client root (KosmudClient.ts)
+Client/Class
+Client/Gui
+Client/Log
+Client/Net
Client/Phaser
+Client/Protocol
.
+Server root (KosmudServer.ts)
+Server/Class
+Server/FS
+Server/Game
+Server/Log
+Server/Net
Server/Physics
+Server/Protocol
.
+Shared/Utils
+Shared/Class
+Shared/Game
+Shared/Log
+Shared/Net
+Shared/Protocol
+Shared/Utils
.
(ve zbytku se vrtám)
[done]

TODO: Zavést classu GUI a v ní metodu init().
[done]

TODO: Opravit poslední commit.
[done]

TODO: PhaserEngine přejmenovat na DisplayEngine
  (nebo RenderEngine, nebo tak něco)
  - možná prostě Renderer?
- zatím přidán Renderer, který vlastní PhaserEngine. Časem to určitě
  budu refactorovat dál.
[done]

TODO: Zvážit, jestli v Game.start() spíš nepustit jen jeden timer
  a z něj pak volat všechno ostatní.
  (60 tiků za vteřinu je blbý číslo btw, bude se s tím špatně počítat...
   na druhou stranu je to rozumný strop fps).
- Každopádně to jsou entry-level funkce a je tam potřeba reportovat uncaught
  exceptiony [to je DONE].
[done]

TODO: Updatnout commenty v Application, Client a Server.
- všechno smazáno, takže asi done :-)
[done]

TODO: Přesunout FileUtils na Server (Client je nepotřebuje).
- mergnul jsem to do FileSystem.
[done]

TODO: Return values ve StringUtils
[done]

TODO: Rozdělit Utils na víc souborů.
- stringové fce
- souborové fce
  - ty by asi mohly jít do FS (už je tam isValidFileName()).
TODO: Zamyslet se, co se zbytkem Utils
  (mělo by to mít specifičtější pojmenování.)
- zatím to vypadá, že 'Utils' bude asi nejlepší...
- ...
[done]

TODO: Vyhodit z Utils ERROR a FATAL_ERROR (a vůbec ho celý projít).
- nahradit je exceptionama.
[done]

TODO: Asi sloučit classy Client a KosmudClient, Server a KosmudServer.
[done]

TODO: Potenciální problém - 'entities' asi budou muset bej v Application
  místo v Entities, protože se k nim musím dostat
  v Serializable.readEntityReference a v Serializable nejdou importnout
  Entities.
- Možná si metodu GetEntities() { return Entities.entities; } hodit někam
  do Utils.
(zatím to přeložit jde. Nechám si to tu, až budu zprovozňovat Entities)
TODO: Ještě jednou se zkusit obejít bez .entities v Application. Šlo
  by pak zrušit instancování klientu a serveru (dělá to Syslog, to stačí).
[done]

TODO: Rozdělit MessageType na Syslog.MessageType a zbytek.
  (mimo jiné se nebude muset všude se Syslogem importovat ještě MessageType).
- ten "zbytek" navíc zatím nejspíš nebudu potřebovat, takže prostě
  vyrobit Syslo.MessageType a MessageType zrušit.
[done]

TODO: Try-catchnout všechna volání serialize() a deserialize().
- ještě to zkontrolovat
[done]

TODO: Refactorovat Connectiony a WebSockety.
+/Shared/Net/PacketHandler.ts
+/Shared/Net/Socket.ts
+/Shared/Net/WebSocketEvent.ts
+/Server/Net/Connection.ts
+/Server/Net/Connections.ts
+/Server/Net/HttpsServer.ts
+/Server/Net/Socket.ts
+/Server/Net/WebSocketServer.ts
+/Client/Net/Connection.ts
+/Client/Net/Socket.ts
[done]

TODO: Obecněji pořešit posílání packetů do closed connection.
  (i když nejvíc to vadilo u "client closed browser tab" message,
   páč tam problikla exception těsně před zavřením tabu)
[done]

TODO: Pořešit Client/Connection.reportClosingBrowserTab()
- info je v commentu
[done]

[UNCAUGHT_EXCEPTION] Failed to send packet to websocket (/ [::ffff:195.113.180.1
95]). Reason: WebSocket is not open: readyState 2 (CLOSING) (this exception has
propagated to top-level function. It needs to be caught much deeper where the er
ror can be properly recovered from.)
    at ServerSocket.send (D:\svetlym\tmp\00\Brutus\Kosmud\Src\Server\Net\ServerS
ocket.ts:69:13)
    at Connection.send (D:\svetlym\tmp\00\Brutus\Kosmud\Src\Server\Net\Connectio
n.ts:184:17)
    at Function.broadcast (D:\svetlym\tmp\00\Brutus\Kosmud\Src\Server\Net\Connec
tions.ts:52:18)
    at Function.updateClients (D:\svetlym\tmp\00\Brutus\Kosmud\Src\Server\Game\G
ame.ts:67:19)
    at Timeout.start.setInterval [as _onTimeout] (D:\svetlym\tmp\00\Brutus\Kosmu
d\Src\Server\Game\Game.ts:37:20)
    at ontimeout (timers.js:425:11)
    at tryOnTimeout (timers.js:289:5)
    at listOnTimeout (timers.js:252:5)
    at Timer.processTimers (timers.js:212:10)
- zaprvé musím testovat, jestli je connection CLOSING
  (to nejspíš souvisí s testováním connection.isOpen()
   v Connections.broadcast)))
[done]
- zadruhé musím tyhle exceptiony někde odchytávat.
[done]

TODO: Client musí nějak ošetřit disconnect
  (aby pak neházel errory jako
   'Uncaught Error: Failed to send data to the server because the connection
    is closed')
- jsou tam alerty a exeptiony by mělo pořešit neposílání paketů do closed
  connection.
[done]

TODO: Event handlery v Keyboard jsou top-level fce, měly by asi volat
  Syslog.reportUncaughtException().
- done, ale výhledově to chce keyboard handling komplet přepsat.
[done]

TODO: Projít všechny výskyty send() a zajistit, že se testuje isOpen().
  A přidat taky exception handling. Connection.send() hází výjimky.
- v Keyboard() je to done.
[done]

TODO: send() a receiveData() by asi vůbec neměly catchovat exceptiony
  (respektive receiveData() možná jo, ta se volá interně z callbacku,
   ale send() volá někdo jinej a ten by asi měl exception dostat).
- Jasně. A onReceiveMessage() už pak reportí jen uncaught exception
  pro případ, že by ji někdo nezhandlil sám.
[done]

TODO: Pořešit rethrow v ServerSocket.send()
  (a asi i v ClientSocket)
[done]

TODO: Musí být connection.receiveData() public?
- jestli se to volá ze socketu, tak sloučením Socketu a Connection
  by callback vidě na private receiveData().
[done]

TODO: Asi bych to mohl udělat tak, že Connection zdědím z WebSocketu
- díky tomu to pořád bude separated code, ale nebudu muset řešit
  alokaci websocketu a budu mít protected přístup na receiveData().
[done]

TODO: Connections.broadcast() musí testovat, jestli jsou
  connectiony otevřené.
[done]

TODO: V ClientSocket (a nejspíš i ServerSocket) je pořád spousta ERROR()
  callů. Zkontrolovat, jestli to nemají být exceptiony.
[done]

TODO: ještě jednou mrknout na connection.send(packet), jestli by to nemělo
  bejt v PacketHandleru (musí se tomu dát serialize mode, takže asi ani
  nemůže, ale mohlo by to tam bejt aspoň abstract).
[done]

TODO: Přesunout connection instance na Clientu do Connection.
[done]

TODO: Posílání PlayerInputu prohnat fcí, která otestuje, jeslti je connection
  open.
[done]

TODO: Alerty o disconnectech (momentálně je to nejjednodušší).
[done]

TODO: Shared.Connection by se asi mělo jmenovat jinak.
[done]

TODO: Refactorovat WebSocketServer
[done]

TODO: Exceptiony ve FileSystem.
[done]

TODO: Vyzkoušet webpack
- pomalé, žere class names. Zatím nebrat
[done]

TODO: Použít Express (kvůli security)
[done]

TODO: HttpServer by se asi rovnou mohl jmenovat HttpsServer...
[done]

TODO: Refactorovat HttpServer
[done]

TODO: Zkontrolovat, že http server neservuje soubory mimo www-root.
- to zařídí express
[done]

TODO: Neservovat data, když je https server closed.
- hmm to asi nepůjde, když to teď dělá express.
- takže možná zrušit .open
(když to někdy bude potřeba, tak se to dá napsat dodatečně)
[done]

ERROR()
--------
.
Pokud nechám ERROR(), asi by se dalo použít tohle:
https://www.bennadel.com/blog/2828-creating-custom-error-objects-in-node-js-with-error-capturestacktrace.htm
.
  In the V8 engine, the stacktrace of an error is gathered using the
  Error.captureStackTrace() method:
  .
    Error.captureStackTrace( errorObject, localContextFunction )
  .
  This method injects a "stack" property into the first argument and,
  optionally, excludes the localContextFunction from the stacktrace.
  So, for example, if we were to generate the stacktrace inside of an
  error Factory function, we could tell V8 to exclude the factory function
  when generating the stack. This would reduce the noise of the error
  implementation and confine the stacktrace to meaningful information
  about the error context.
[done]

TODO: Otestovat reportování errorů.
[done]

TODO: Vyzkoušet ERROR() a REPORT() i na klientu.
[done]

TODO: Někde v kódu mám RERORT(new Error("test"));
- už snad ne
[done]

TODO: Reportování errorů a exceptionů je pořád divný.
- snad fixed
[done]

TODO: Odstranit testovací kód na ERROR() a REPORT() ze serveru a z klienta.
[done]

TODO: Když se stejně nakonec na zobrazení errorů volá Syslog,
  nebylo by lepší udělat polymorfní jen ten, místo Application?
  - respektive neprovolávat ty reporting funkce přes Application.
    (Tam to moc nepatří).
  - application je zatím taky singleton, možná to bude potřeba
[done]

TODO: Asi jsem rozbil tikání physics enginu a posílání updatů.
- to bylo nejspíš tím, že mi utekla uncaught exception. Client
  se tím zřejmě taky zastaví.
[done]

TODO: Updatnout commenty v ERROR (a vůbec v celém reportovacím kódu).
[done]

TODO: Z Utils oddělit ještě FileUtils.
[done]

TODO: FATAL_ERROR() by neměl bejt v Shared kódu (na klientu nedává smysl).
  A možná by šel vyhodit úplně.
- zrušen kompletně
[done]

TODO: Extra házení EXCEPTION_CAUGHT možná není úplně dobrý, protože tam
  není uvedeno, jaká exception byla chycena. Asi by to fakt měl bejt jeden
  message.
[done]

TODO: Mrknout ještě na REPORT() a logování catch message.
[done]

TODO: Testnout additional message u RERPORT().
[done]

TODO: Funkce ze StringUtils by se měly volat jak StringUtils.něco
  (ať je jasný, že to je z externího modulu).
[done]

TODO: Otestovat, jestli getTrimmedStackTrace() správně trimuje stack trace.
- otestováno při hození erroru.
- Klient to nepoužívá, hází místo toho exception.
[done]

TODO: Zvážit, jestli úplně nezrušit ERROR a nenechat jen syslog.
- Nakonec ne, viz třeba ClientSocket. Entry point funkce rovnou reportují,
  nemá smysl, aby házely exception.
[done]

TODO: Nahradit fs-promise něčím jiným
  npm WARN deprecated fs-promise@2.0.3: Use mz or fs-extra^3.0 with Promise Support
[done]

TODO: Everything is brutally slow now. Need to investigate what has happened.
  (fs-extra probably causes this).
- never mind, it works fine.
[done]

TODO: Serializable by nemělo nic vědět o entitách.
  - Entity by si měly přetížit metodu na serializaci/deserializaci properties.
- Nakonec jsem deserializování referencí na entity nechal v Serializable,
  aby šly házet reference na entity do non-entity class (a serializovat je
  jako reference).
[won't do]

Ok, seriózní TODO: Zprovoznit pohyb lodě tak, že na serveru to bude physics
  body v matter.js a na klienta se bude posílat aktuální pozice a rotace.
- importnout na serveru Matter.js
  [done]
- vytvořit testovací body pro ship
  [done]
- nasimulovat wsad (speed, rotation, position).
  (Zatím nic moc, ale tohle teď skipnu, s tím si bude lepší hrát s vizuální
   odezvou.)
- ukrást websockety z BrutusNext
[done]
- ukrást Serializable z BrutusNext
[done]
- posílat pozici a rotaci a zobrazovat to na klientu.
[done]
- posílat keyboard eventy (nejspíš už přeložené na herní akce?)
[done]

TODO: Velocity vector se musí updatovat spolu s rotací lodě.
- pamatovat si velocity (scalar value) starnou a velocity vector
  z ní počítat každej update().
[done]

TODO: Hodit funkce na práci s typy z Utils do Types.
[done]

TODO: Uklidit v Serializable public, protected atd.
[done]

TODO: Updatnout úvodní pokec v Serializable.
[done]

TODO: Vrátit se k jednoduchému modelu shared-only a data-only packetů
  a processPacket() udělat jako externí kód se switchem na className packetu.
- Zrušit Server/Protocol a Client/Protocol
- Zrušit IncomingPacket a OutgoingPacket.
- Classy XXXData přejmenovat na XXX.
- napsat processPacket() na serveru.
- napsat processPacket() na klientu.
[abandoned, reverted]

TODO: Vyhodit z gitu zkompilovaný kód.
[done]

TODO: Přejmenovat adresáře Client/js, Server/js, atd. (na CamelCase)
[done]

TODO: Objekty ve scéně by měly být v classe, která se celá
  nainstancuje ve Scene.create(), ať nemusím testovat, jestli to existuje.
  - problém je, že některé věci se vyrábí v preloadu...
    Preload s konkrétními sprity nesouvisí - z jedné textury se dá vyrobit
    milión lodí. 
[done]