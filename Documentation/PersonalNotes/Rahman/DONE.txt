TODO: Zónu serializovat s contentem nejen při savování, ale i při posílání
  na klienta (místo ZoneUpdate);
  - tímhle taky vyřeším, co všechno se má posílat po nalogování.
    Pošle se prostě player a pokud je v zóně, tak zóna.
Budu asi předpokládat, že loď vždycky musí bejt v nějaký zóně
  (jinak bych musel řešit případ, kdy player má aktivní loď, ale nemá ji
   v zóně).
Hmm, customSerializeProperty() by asi stačilo na serveru, ale co už.
[done]

TODO: Posílat definice assetů.
- buď je přihodit do contents zóny (pak se ale budou posílat i při zone updatu,
  což bych asi musel ošetřit dalším serializable módem), nebo je přibalit
  při loginu (respektive obecně při loadování nové zóny).
  - každopádně abych je mohl přibalit, tak je musím mít v nějakém seznamu.
Buď ten seznam vytvořím při posílání (projdu entity, vytáhnu to z nich),
  nebo už při vkládání entit do zóny.
- tohle už jsem řešil a rozhodl sem se projít entity. Fakt ale je, že to
  nemusím dělat až na klientu při loadování assetů, ale už před posláním
  zóny (protože beztak musím poslat definice assetů).
[done]

TODO: Packety by se neměly vyrábět přes new
  (new LoginRequest, atd.)
  ClassFactory.newInstance(Class).
TODO: Což zároveň znamená, že nemůžu předávat parametry konstruktoru.
  Otázka teda je, jestli je to až taková výhra...
  (vlastně asi jo, kvůli tomu, že serializable classy se deserializují)
[done]

TODO: Neměl by bejt player i v Server/Connection?
  V tom případě bych asi musel vyrobit shared verzi Connection a hodit
  ho do ní.
- zjevně tam dokonce je, takže to asi fakt sloučit.
- místo hasPlayer() použít isLoggedIn().
Hmm, to nebude tak jednoduchý. Client a server connection jsou zděděné
  z client a server verze socketů.
  - ty bych musel zrušit (tzn. věci z nich přesunout do connectionů)
Asi to dává smysl - věci, co jsou jen na klientu nebo jen na serveru
  budou pořád jen na klientu nebo jen na serveru. Společné věci budou společné.
[done]

TODO: Dočistit kód od pozůstatků accountu.
- zbyly jen v commentech, na to peču.
[done]

TODO: Connection by neměla mít odkaz na zónu, ten by měl bejt
  v playerovi.
  (Player by měl sloužit jako kontejner všech věcí, které s ním nějak
   souvisí.)
[done]

TODO: Přidávání entity do packetu (odebírání asi nebude potřeba).
[done]

TODO: Přejmenovat Account na Player.
[done]

TODO: Shared verze accountu neexistuje - což musí, pokud se má posílat
  na klient.
[done]

TODO: Registrovat Player prototyp na klientu (ze Shared to bejt nemůže).
- zatím se registruje v Shared/Connection. Časem nejspíš bude client
  verze playera, tak to budu moct přehodit do ní.
[done]

TODO: Založit rovnou i client verzi playera
- dát do ní registrování entity (z connection).
- přetížit getActiveShip() aby vracela client verzi lodi.
[done]

ÚVAHA: Přijde mi, že v Accountu motám dohromady dvě responsibility.
- account by měl mít údaje o accountu, tzn. kdy byl vytvořenej, na jakej
  mail je registrovanej, atd.
- jakou má zrovna player aktivní loď by v něm bejt nemělo.
  - jak to ale nazvat? Player?
Možná tomu rovnou říkat Player místo Account.
- jaké má hráč lodě, základny, atd.
- určitě tyhle věci nechci savovat do jinýho souboru.

Ad assety: Ještě je tu jedna možnost - nepřekopírovávat reference na assety
  do zóny a místo toho při loadu projít všechno, co je v zóně a naloadovat
  od toho assety.
- bylo by to asi jednodušší.
- potenciálně bych procházel spoustu entit v zóně, který žádný assety nemají,
  nebo už je mají loadnutý.
Na druhou stranu se to dělá jen jednou při loadu zóny a navíc asi jen
  na klientu, takže pohoda.
- Pořád to ale asi bude chtít dávat seznam assetů do entity, ať nemusím psát
  funkci, kde budou muset bejt všechny vyjmenované tak jako tak.
IDEA: Asset.newXYAsset() by mohlo brát jako parametr GameEntitu a rovnou
  to do ní přidat.
  - hmm ovšem většinou se nebudou vyrábět nový ale setovat existující...
[úvaha done]

TODO: 2) Předělat assety na entity (nejspíš physics shape, tilemap, sound).
[done]

TODO: 3) Dávat do lodi reference na použité assety
  - ideálně do nějakýho pole, ať se dají při přidávání lodi do zóny
    zpracovávat hromadně
[done]

TODO: 4) Při přidání lodi do zóny je pushnout do assetů zóny
  (Tady je teda otázka, jak pořešit, když loď zas ze zóny odeberu.
   Asi k seznamu assetů v zóně přidat counter, kolikrát je použitej.)
- tohle udělám jinak (projdu všechny entity v zóně, ty projdou svoje assety).
[won't do]

TODO: VehiclePhysics dostává entitu jako parametr konstruktoru,
  to asi nebude fungovat.
- snad fixed (přes onInstantiate()).
[done]

TODO: Dávat assetům jména.
[done]

TODO: Server/Zone.customSerializeProperty()
[done]

TODO: Projít Zone a důsledně zakázat savování všeho, co se nemá savovat.
[done]

TODO: Založit Ships (nejspíš classu).
[done]

TODO: ships v Zóně asi taky nemusí bejt mapa
  (getnout entitu podle idčka jde i z Entities, takže jakékoliv další seznamy
   indexované idčkem postrádají smysl).
[done]

TODO: V zóně asi contents serializovat do json objectu místo
  do stringu, ať se to savne bez \n.
[done]

TODO: Id taky savovat prioritně (asi hned za className).
- a prototypeId taky.
[done]

TODO: Server/Zone.customDeserializeProperty()
- snad
[done]

TODO: Projít Ship (Shared i Server verze) a VehiclePhysics a ošetřit,
  co se savuje a co ne.
- jakž takž
[done]

Je vůbec nějakej důvod, proč mít contents Map a ne Set?
- není
[done]

TODO: Nezapomenout, že po vytvoření zóny se musí zavolat createPhysicsWorld()
  const zone = new Zone();
  zone.createPhysicsWorld();
- v konstruktoru to bejt nemůže, ten se volá jen pro root prototyp.
[done]

TODO: loadovat zónu při startu serveru (Game.load()).
[done]

TODO: Otázka je, jestli zóny dávat do Game, nebo spíš do World či tak něco
  (World asi ne, to znamená 1 planetu).
- možná prostě Zones.
Aha, doteď byly zóny v Game...
  A, hmm, někde beztak musí bejt seznam toho, co se má loadnout
  (zatím asi klidně natvrdo v kódu. I když...).
  - na to by se asi hodilo Zones coby savovatelné Serializable.
[done]

TODO: vyrobit zónu jako entitu
  - asi zase stejně jako u accountů nebudu v Zones dělat seznam zón,
    respektive možná časem nějakej vyhledávací (aby šla najít zóna podle
    jména nebo tak).
  - aha, potom ale asi Shared/Zones k ničemu nepotřebuju. Nový zóny se
    budou vyrábět jen na serveru (a budou se dávat jen do Entities).
    - časem ale Zones určitě potřeba budou, takže je teď prostě nechám prázdný.
- asi ji zas jednorázově savnout.
[done]

TODO: Dávat save filům příponu .json.
[done]

TODO: Problém - Zone.load() je něco o dost jinýho než Zone.save().
  (load() loaduje assety (tilemapy a shapy), save() savuje data zóny).
- možná load() přejmenovat na loadAssets()?
[done]

TODO: posílání updatů
- zóna neví, co v ní je za playery (teda možná časem bude, ale nutně nemusí)
  Tzn. dává větší smysl procyklovat aktivní connectiony a poslat do příslušné
  connectiony vždycky jen tu zónu, která k ní přísluší.
To znamená:
- connection musí vědět, ve které zóně je player
  - connection má account, account má v sobě activeShip, activeShip je v nějaký
    zóně (nebo taky ne, ale v tom případě není třeba posílat update zóny).
- V tiku projít všechny connectiony (tzn. nejspíš Connections.tick())
  a rozposílat updaty.
[done]

Jak má loď vědět, ve které je zóně...
- zóna je container entita a loď se dává dovnitř.
- všechny entity někam vložené by asi měly znát idčko toho, do čeho jsou
  vložené (tzn. container entity má nejen contents, ale i container.
Aha, ona se všem GameEntitám setuje zóna.
  Tak tím líp - dává to smysl, entita může být vložena do něčeho jinýho,
  (třeba motor do lodi), ale i tak je dobrý vědět, do který patří zóny.
- až na to, že getZone() vrací Shared/Zone a já potřebuju server verzi...
[done]

TODO: Entities asi zase předělat na classu, ať se dají dědit.
[done]

TODO: v LoginRequest.process() loadnou vytvořenej account
  (idčko zatím zadat ručně).
[done]

TODO: Entita si zjevně musí pamatovat prototypeId.
[done]

TODO: Registrovat Ship v Entites přes createRootPrototypeEntity().
[done]

Ještě se taky někdy musí založit account, ehm.
- to prozatím můžu udělat ručně.
[done]

TODO: Asi by se hodilo savovat nejdřív className a pak až version.
[done]

TODO: Místo Vector.validate(x) použít x.validate()
 (PhysicsBody)
[done]

TODO: String je javascriptový typ, takže ho nemůžu jen tak přepsat
  vlastním namespacem. Utils/String musí extendovat javascript String
  podobně jako se extenduje Number.
[done]

TODO: Entity.isValid().
[done]

TODO: Entity.setId()
  (zajistit, že idčko jde setnout jen jednou).
[done]

TODO: Invalidace properties entit při smazání.
[done]

TODO: Nezapomenout na Client/Entities a Server/Entities
- pokud je nebudu potřebovat (jako že možná ne), tak je smazat.
  (server Entities potřebovat budu, client verzi asi ne)
[done]

TODO: Instanciaci Serializable classů dokonce musím udělat korektně,
  protože jinak si budu přepisovat prototyp (při zápisu do vnořených objektů).
[done]

Možná přejmenovat Classes na Prototypes, pokud teda bude všechno řešeno
  přes Object.create().
  - pokud budou prototypové entity jen v Entities, tak jméno Prototypes
    bude možná matoucí.
    - SerializablePrototypes?
    - Serializables?
  možná ClassFactory (je to common pattern)...
ClassFactory it is
[done]

Otázka je, jestli vůbec do Prototypes dávat prototypové entity. Tak
 registrují se beztak pod idčkem a pod tím jsou už v Entities, takže
 asi dává větší smysl, aby je instanciovaly Entities.
- možná bych ale mohl do Prototypes hodit root entity, tzn. Ship a podobně.
  - v tom případě tam ale asi budou spíš pod class name.
Budou v Entities
[done]

TODO: Cleanup po Classes
[done]

TODO: Zakázat ve VS code autocomplete on dot
[done]

TODO: brakingDistance počítat až na klientu při zobrazení.
[done]
TODO: Na klientu je špatně pozice a waypoint pozice.
  (asi se waypoint ukládá někam jinam, s pozicí těžko říct...)
[done]

TODO: Speed lodi na clientu je nulová, takže se nezobrazuje
  (nejspíš ji nesetuju do physicsBody)
- ale jo, potřebuju ji - musím vidět, jak se aktuální velocity lodi
  blíží desiredVelocity.
  - asi to ale můžu posílat jako skalár a jen tím pronásobit vektor
    desiredVelocity.
[done]

Opravy steeringu
-----------------
.
TODO: Přijde mi, že MAXIMUM_SPEED lodi nic nedělá
- vektory jsou delší, to jo, ale vizuálně loď neletí rychlejš.
- a taky je divný, že se pořád letí na maximum thrust
  (to je teda fajn - sice to není fyzikálně správně, ale vypadá to dobře).
.
 Refactorovat steering
- různá chování počítají jen desired velocity
  I když, to je otázka.
  - Za prvé nevím, jestli bude fungovat skládání behaviourů přes rychlosti
    (nejspíš je nějakej důvod, proč se skládaj až výsledné steering forces)
  - Za druhé nevím, co složitější behaviours s těma silama dělaj...
Ok, asi se raději budu držet skládání sil.
.
TODO: Forward thrust se z nějakých důvodů limituje na 80% výkonu.
.
TODO: Steering by se možná choval líp, kdyby se prostě loď nejdřív otočila
  do požadovaného směru a pak se aplikoval jen forward/backward thrust.
- tohle asi dělat, jen když je loď blízko k cíli.
- rozhodně to budu muset ještě poladit.
TODO: Asi budu muset přece jen trošku poladit arrive() - na thrusterech
  je vidět, jak se to občas chová divně.
TODO: Opravit "backlash" při zastavování.
[done]

Refactoring steeringu
----------------------
.
Mohl bych asi na začátku arrive() vyrobit
  const phase = "Accelerating" | "Braking" | "Stopping"
a předávat ji pak dalším fcím, aby podle ní mohly switchovat.
[done]
Možná pak nebude potřeba předávat všude distance a tak.
- v computeLinearForces to totiž asi budu potřebovat switchovat taky
  (a je vůbec otázka, jestli to nerozdělit do víc funkcí, protože
   třeba seek() dobržďovací část vůbec nebude potřebovat).
Takže:
- computeSeekLinearForces()
- computeArriveLinearForces()
[done]

TODO: Zavést měřítko do CoordsTransform (nejspíš 1:1000)
[done]

TODO: CoordsTransform možná dát do /Client/Engine, je to čistě zobrazovací
  záležitost a týká se to konkrétně Phaseru.
  - tak ne, CoordsTransform se používá i v Shared/Tilemap
    (data tilemapy jsou v client koordinátech)
Ale mohla by bejt v Shared/Engine místo v Shared/Physics
[done]

TODO: Zamyslet se nad parametrem pro akceleraci lodi (kterým by se asi
  násobila steering force). Momentálně je omezené pouze maximum, což
  může vést k tomu, že se silnější motory až tak moc neprojevěj.
[done]

SUPER IMPORTANT:
  https://stackoverflow.com/questions/44866044/libgdx-box2d-velocity-not-increasing-enough
[done]

TODO: Problém je, že braking distance se dynamicky updatuje, takže se může
  stát, že zahájím braking manévr a následně se opět dostanu ven z braking
  distance.
- asi bych měl braking distanci měnit jen dokud jsem v accelerating fázi,
  případně po updatu waypointu (čímž se ovšem vrátím k problému, protože
  dokud držím lmb, tak se pozice waypoint updatuje každej tik).
{ Ono to možná vadit nebude, pokud bude správně fungovat natáčení }
Nakonec je to jinak, ale done.
[done]

TODO: Pokud opravdu zruším stopping distance, tak ji ani neposílat
  na klient a nezobrazovat.
[done]

TODO: Linear arrive forces
.
Dokud jsem dál než maxBrakingDistance, tak zaručeně acceleruju.
- když bych v příštím tiku překročil maxBrakingDistance, tak bych měl
  updatnout brakingDistance podle aktuální speed?
.
- když se vzdaluju (je jedno kterým směrem, prostě vzdálenost v tomhle tiku
  je větší než v minulém), tak musím přepočítat brakingDistance.
  - problém bude v tom, že nevím, jak dlouho mi bude trvat zrychlování
    (protože klidně můžu zrychlovat po nějaké křivce, takže to rozhodně
     nebude lineární).
  - stejně tak si nemůžu bejt jistej deccleraing thrustem, protože ten
    taky závisí na směru.
.
V každým okamžiku asi dokážu říct, jakej mám thrust k cíli a od cíle.
- že bych prostě v každém okamžiku počítal dráhu na základě těchle dvou
  thrustů?
.
distance
accForce
deccForce
v
.
maxBrakingDistance bude taky závislá na aktuální rotaci, tedy na
  aktuální deccForce.
.
1) pokud jsem dál než je aktuální maxBrakingDistance, tak akceleruju
   až do MAX_SPEED.
2) Když jsem blíž, tak je jasný, že nedosáhnu MAX_SPEED, tzn. řeším
   jen problém typu střecha
.
d = dAcc + dDecc
dAcc = (m * v * v) / (fAcc * 2)
dDecc = (m * V_MAX * V_MAX) / (fDecc * 2)
d = (m * v * v) / (fAcc * 2) + (m * V_MAX * V_MAX) / (fDecc * 2)
(m * V_MAX * V_MAX) / (fDecc * 2) = d - (m * v * v) / (fAcc * 2)
(m * V_MAX * V_MAX) = d * (fDecc * 2) - (m * v * v) * (fDecc * 2) / (fAcc * 2)
(m * V_MAX * V_MAX) = d * fDecc * 2 - m * v * v * fDecc / fAcc
vMaxSquared = d * fDecc * 2 / m - v * v * fDecc / fAcc
.
(m * vMaxSquared) = d * fDecc * 2 - m * v * v * fDecc / fAcc
.
dDecc = (m * vMaxSqared) / (fDecc * 2)
dDecc = (d * fDecc * 2 - m * v * v * fDecc / fAcc) / (fDecc * 2)
dDecc = (d - m * v * v) / (fAcc * 2)
.
Hmm, mám to špatně. Akcelerační vzdálenost není z rychlosti v do nuly,
ale z rychlosti v do rychlosti VMax
.
// Akcelerační vzdálenost je rovna:
//   Vzálenost, za kterou se dostanu z nuly na V_MAX
//   mínus vzdálenost, za kterou se dostanu z nuly na v.
dAcc = (m * V_MAX * V_MAX) / (fAcc * 2) - (m * v * v) / (fAcc * 2)
dDecc = (m * V_MAX * V_MAX) / (fDecc * 2)
.
d = dAcc + dDecc
.
d + (m * v * v) / (fAcc * 2) = (m * V_MAX * V_MAX) / (fAcc * 2) + (m * V_MAX * V_MAX) / (fDecc * 2)
d + (m * v * v) / (fAcc * 2) = (0.5 * m * V_MAX * V_MAX) * (1 / fAcc + 1 / fDecc)
d + (m * v * v) / (fAcc * 2) = (0.5 * m * V_MAX * V_MAX) * (fDecc / fDecc * fAcc + fAcc / fAcc * fDecc)
d + (m * v * v) / (fAcc * 2) = (0.5 * m * V_MAX * V_MAX) * (fDecc + fAcc) / (fDecc * fAcc)
d * (fDecc * fAcc) + (m * v * v) * (fDecc * fAcc) / (fAcc * 2) = (0.5 * m * V_MAX * V_MAX) * (fDecc + fAcc)
d * fDecc * fAcc + 0.5 * m * v * v * fDecc = (0.5 * m * V_MAX * V_MAX) * (fDecc + fAcc)
.
m * V_MAX * V_MAX = (2 * d * fDecc * fAcc + m * v * v * fDecc) / (fDecc + fAcc)
.
dDecc = (m * vMaxSqared) / (fDecc * 2)
dDecc = (2 * d * fDecc * fAcc + m * v * v * fDecc) / (fDecc + fAcc) * (fDecc * 2)
dDecc = (2 * d * fAcc + m * v * v) / (fAcc + fDecc) * 2
// Součet je asi ok, jen nesmím zapomenout, že fAcc má opačný směr
// (a tedy i znaménko) než fDecc.
.
Ok, one step at a time:
.
1) Disablovat rotaci
2) počítat se stejným thrustem do všech směrů.
3) vykašlat se na max_speed, zkusit rovnou šílenej výpočet
   akcelerace/deccelerace.
.
{Celé je to nakonec jinak, ale done}
[done]

TODO: Thrust ratia počítám blbě - když letím šikmo, tak musí jít thrust
  do dvou směrů, ne jen do boku.
- asi bych si měl udělat dvě funkce. Jedna bude pouze vracet brakingThrust,
  druhá bude vracet výsledný thrust a při tom updatovat thrustRatios,
  ať nemusím tahat ven úhly a podobně.
I když ne, ratio na základě thrust anglu asi můžu spočítat v pohodě.
  forwardRatio = cos(angle)
  leftwardRatio = sin(angle)
[fixed]

ÚVAHA: Tím, že thrusty mohou jít nad 100% a navíc každej zvlášť, jsem si
  to brutálně zkomplikoval.
.
TODO: Udělat jen jeden modifikátor thrustu, kterej teda může jít nad 1, ale
  vztahuje se na všechny thrusty současně, včetně torque.
[done]

ÚVAHA: Možná bych thrustInDirection mohl počítat podobně jako ratia.
  Nebo možná jako elipsu.
  - pak bych mohl thrust ratia spočítat jako souřadnice bodu na elipse
    (a thrust by byl "poloměr" elipsy v daném místě)
Heh, ratia vychází stejně jak na kruhu
  (forward je cons(angle), leftward je sin(angle)), protože ratio je poměr
  ku poloose elipsy a "a * cos(angle) / a" je "cos(angle) a to samé pro
  kolmý směr.
ThrustSquared je potom:
 (forwardThrust * forwardThrustRatio)^2 + (leftwardThrust * leftwardThrustRatio)^2
 [done]

TODO: Box2d má limit i na angular velocity (PI/2).
- Udělat na to check.
[done]

TODO: Zrušit .torque, zavést .torqueRatio a vracet ho v getTorqueRatio().
  (a typ number místo MinusOneToOne).
[done]

TODO: Reneablovat thrustInDirection().
- ještě to vyzkoušet
[done]

TODO: Nezapomenout nakonec validovat rychlost.
[done]
TODO: Validovat taky angular velocity.
  validateAngularVelocity()
[done]

TODO: Ošetřit zastavení do nuly
  (když jsem fakt blízko, tak přesně spočítat force za tik)
- i když, to by možná mělo dělat samo...
- ok, to teď fakt potřebovat budu :-)
[done]

TODO: Pročistit data properties ve VehiclePhysics.
[done]

TODO: (pokud to bude fungovat, tak mám asi zbytečně složitou i rotaci...)
- zjednodušit rotaci.
[done]

TODO: Opravit posílání thrustů na klient.
[done]

TODO: Zjevně jsem zapomněl pronásobit thrust ratia aktuálním
  thrustem (vždycky zobrazuju full thrust).
[fixed]

TOFIX: Zase mám obráceně levej a pravej thrust (spíš ratio).
- špatně se počítal angleToShip().
[fixed]

TOFIX: Dopředu a dozadu mám stejnej thrust.
  (respektive stejnou braking distance)
[fixed]

TODO: Musím nutně posílat this.desiredRotation?
- totéž je schováno ve waypointu (který má teď dvě složky).
Zrušeno
[done]

TODO: Opravit bug s přetáčením do jednoho směru.
[done]

TODO: Updatovat torqueRatio.
[done]

TODO: Braking angle se musí přepočítat při změně currentTorque
  (a asi i currentMaxAngularSpeed).
- nemusí, protože je zrušený
[done]

TODO: Oprava commentů.
[done]

TODO: Refactoring.
[done]

TODO: volat updateWaypointDirection() v každém tiku, kdy je nenulová
  distance (abych zastavil ve směru příletu).
[done]

TODO: Dvojitý zášleh, když couvám dál než braking distance.
- ok tak občas i nejen přes braking...
[fixed]

TODO: Asi bych při finálním dobržďování mohl prostě nenastavovat
  thrust ratia (respektive je nulovat). Tím zmizí závěrečné "bliknutí"
  thrusterů.
  (ratia setuju na 0, když je desiredSpeed 0)
- skoro, občas ale pořád ještě bliknout při zastavování dozadu.
Tohle je nakonec jinak, ale done.
[fixed]

TODO: Problém v:
  private computeThrustValue(velocityChange: Vector, fullThrust: number)
- strašně dlouhou vzdálenost se mi počítá menší než FULL THRUST.
Tohle je nakonec jinak, ale done.
[fixed]

TODO: Ještě přece jen zaexperimentovat s nezastavováním moc brozo
  při protáčení kolem zádi.
[done]

TODO:
  místo this.getPhysicsBody().getInertia().valueOf()
  používat this.getInertiaValue()
[done]

TODO: Asi přece jen implementovat změny max torque (a možná max angular
  velocity) dokud to ještě mám v hlavě.
[done]

Něco je špatně...
[něco je fixed]

TODO: Ještě bych asi uživil typ ZeroToPi (na this.brakingAngle).
[done]

Ke zvážení - zavést a použít typy pro:
- nezápornou hodnotu (NonnegativeNumber)
- PositiveNumber (třeba inertia)
- úhel -PI to PI
- úhel 0 to 2PI
- unit vector
TODO:
 getInertia() bude vracet PositiveNumber,
 getInertiaValue() bude vracet number.
- konstanty ve VehiclePhysics by asi taky měly mít tyhle typy
[done]

TODO: Z něčeho ty nový typy zdědit (NumberWrapper)
[done]

TODO: TORQUE asi přejmenovat na ANGULAR_THRUST
[done]

Zbývá přeci jen jeden rotační problém:
- když jsem roztočenej, tak kliknutí o velkej úhel zpět se nevrací, ale
  protočí skrz.
  (možná je to dokonce i rychlejší než se vracet, ale působí to neintuitivně).
Asi bych se to měl pokusit fixnout.
- bere se to jako overtaking. Distance začíná někde kolem +2 nebo -2 a roste
  postupně k PI nebo -PI
IDEA: Asi bych měl distance hodit do rozsahu 0..2PI, možná -2PI .. 2PI
- v computeArriveTorque() bych měl zohledňovat, když je distance
  větší než PI, možná než PI + brzdná dráha.
[fixed]


2 bugy:
- v "refactornutém" kódu mi to na jednu stranu přestřeluje
- když v průběhu rotace dám waypoint "zpět", tak přestřeluju tam a zpět
  - při tom se mi může dokonce stát, že overshotnu do další acceleration
    fáze a udělám otočku o 360 stupňů.
Když overshotnu, tak:
  1) Měl bych setnout brakingAngle na PI
      (to zabrání overshotu do další accelerating fáze).
  2) Měl bych jinak počítat decceleraci, jinak overshotnu znova.
[fixed]

TODO: Detekovat overshot
[done]
TODO: Nastavit this.brakingAnble na PI
[done]
TODO: Správně počítat decceleraci při overshotu.
- možná by mohlo stačit jen správě počítat decceleraci...
[done]


Sakra sakra, začíná se mi to zas nějak komplikovat...
- vím, kdy mám začít zpomalovat. Ale nemůžu to udělat přesně.
  Tzn. asi potřebuju konvergovat k nějaké hodnotě.
  - jediná hodnota, ke které můžu konvergovat, je vzdálenost.
    => při zrychlování konvergovat k desired rychlosti, ale
       při zpomalování ke vzdálenosti.
  - Tzn. rovnou počítat torque z accelerating/braking větve,
    nedělat obojí přes desiredVelocity.
ÚVAHA - jak na rotaci
- přepnutí fáze detekovat v předstihu
  - tzn. neporovnávat jen angularDistance,
    ale angularDistance + vzdálenost, kterou urazím v příštím tiku
    - tu asi spočítám jako aktuální_rychlost_za_tik + zrychlení_za_tik
- spočítat předem, jakou výslednou rychlost bych měl mít, když bych
  se pohyboval po správné dráze (tzn. dostal se na plánovanou rychlost
  a pak se část tiku buď pohyboval konstatní rychlostí, nebo začal zase
  zpomalovat).
  - pro případ, kdy hned zase brzdím:
    - desiredVelocity = currentVelocity + (zryhlení * část tiku odpovídají
      části dráhy, po kterou budu zpomalovat) - zpomalení * část tiku
      odpovídající části dráhy, kterou budu zpomalovat
     tedy:
       dVel = cVel + (TORQUE * d1 - TORQUE * d2) = cVel + TORQUE * (d1 - d2)
- nastavit torque, která mě do téhle výsledné rychlosti dostane.
  (to už vlastně dělám)
[done]

TODO: Rotace bych měl udělat stejně jako lineární pohyb, tzn:
- podle fáze počítat desiredAngularVelocity
- na základě desiredAngularVelocity pak spočítat torque.
  - otázka je, jak.
    - pokud je aktuální angular velocity menší než desired, tak
      setnout maximální TORQUE.
    - když je větší, tak naopak setnout -TORQUE.
Ono je vůbec otázka, v čem se to liší od toho, když podle fáze rovnou
  určím torque...
  - nemám tam teď angular speed limit, což ale možná nevadí. I když...
  - ale jo, to je asi odpověď - liší se to limitem na rychlost rotace.
[done]

Kdy začít s gradual approachem?
- v zásadě v okamžiku, kdy by mi další tik přehodil rychlost do opačného směru.
  - to se dá spočítat.
    - znám force (TORQUE nebo THRUST), znám hmotnost. Z toho spočítám
      zrychlení: F = m * a, tzn a = F / m.
    - zrychlení je změna rychlosti za sekundu. (a / FPS) je změna rychlosti
      za 1 frame. Když tahle hodnota přesáhne current velocity, je třeba
      nasadit gradual approach.
      - to znamená:
        - zrušit stopping distance
        - stopped distance vlastně taky nepotřebuju.
          Ta tam byla kvůli tomu, aby se na závěr dala desired speed 0.
            (což je stejně jedno, protože force pak bude approachovat
             tak jako tak. Zastavit na fleku nejspíš vůbec nejde, leda bych
             natvrdo vehiclu setnul speed 0. Každopádně to teď nepotřebuju).
          - I když... V linear forces jsem nedával nulovou desired speed,
            protože jsem potřeboval držet údaj o směru. Ten ale v zásadě
            můžu držet v jiné proměnné.
          - každopádně na rotaci to nepotřebuju.
- problém ale je, že když budu počítat brzdnou dráhu přesně, tak už na to
  dobrždění nemusí bejt čas.
  - vlastně ne. Začnu graduálně approarchovat až v okamžiku, kdy bych desired
    velicity přesáhnul, takže to je v pohodě.
[done]

Možná bych měl zavést různé typy pro fáze různých behaviourů:
  SeekPhase, ArrivePhase.
- to pak ale nebudou fungovat společné funkce computeLinearForces
  a computeAngularForces.
  (ty by neměly fázi potřebovat, takže fungovat budou)
(Každopádně to zatím nepotřebuju řešit).
[tohle je jinak]

Principiální problém:
  Pokud je brakingAngle úhel, kdy musím začít brzdit, abych to přesně stihnul,
  tak kdykoliv v průběhu brždění bych měl bejt přesně na braking anglu.
- Tzn. braking angle má smysl čistě v průběhu akcelerace jako vodítko,
  kdy mám začít brzdit.
[done]

Akcelerace/deccelerace
- co takhle to prostě rozdělit na půlku?
  - blbost, páč mám ořezanou max speed
V zásadě by mělo stačit spočítat trajektorii v okamžiku změny waypointu.
- nebude to ale tak jednoduchý, protože brzdná dráha závisí na dosažené
  rychlosti.
  - leda že by...
  IDEA:
  - při změně waypointu spočítám brzdnou dráhu pro maximální rychlost
    (tu navíc můžu mít předpočítanou v konstruktoru, protože se mění
     jen při změně akcelerace nebo max speedu)
  - porovnám ji s polovinou vzdálenosti.
    if (angularDistance / 2 < maxBreakingAngle)
      brakingAngle = angularDistance / 2;
    else
      breakingAngle = maxBreakingAngle;
    (tohle navíc stačí počítat při změně kurzu)
TODO: V initu vehiclu spočítat maxBrakingAngle.
  [snad done]
TODO: Při změně waypointu spočítat brakingAngle.
  [snad done]
TODO: Updatnout arrive();
[done]

Možná není až tak super nápad pracovat pouze s desiredAngularVelocity,
pak totiž nemám moc kontrolu, jestli už tam jsem.
- zastavení bych měl spíš řešit přes rozdíl aktuální rotace a desired
  rotace (prostě zpomaluju (nebo zrychluju) co to dá a jak se přiblížím
  na míň než jeden tik, tak setnu zastavovací torque.
(rozdíl úhlů v posledním tiku je totiž fakticky rychlost (za tik)).
- tohle by ale nejspíš zasekávalo rotaci, i když by mělo dojít k přetočení.
  (i když asi můžu testovat, jestli jsem vůbec schopen zbývající vzdálenost
   dobrzdit).
(Na druhou stranu dobržďování do nulové rychlosti je asi fajn na zastavování.
 Jen bych musel přesně spočítat brzdnou dráhu).
[done]

Problém s předpočítáváním brzdné vzdálenosti mimo jiné je, že mám vzorkovanou
  simulaci. Asi bych měl začít brzdit, už když by příští tik přejel brzdnou
  vzdálenost.
[done]

TODO: desiredAngularVelocity by měla mít směr (znaménko).
[done]

TODO: Loď se zjevně netočí kolem originu, ale kolem center of mass.
  To znamená, že vzálenosti, jako třeba stopping distance, se měří
  od špatného bodu.
- chtělo by to translatovat tak, aby byl origin v center of mass.
{Prozatím jsem to hacknul tak, že nastavuju center of mass na [0, 0]}
[done]

TODO: Předělat otáčení lodi (dotáčení je strašně pomalé).
- spočítat, od jakého úhlu musím začít "brzdit".
- nastavit -MAX_TORQUE.
[done]

Další bug: Když stojím, tak kliknutím proti směru, ve kterém jsem zastavil,
  se bere jako overtaking a tudíž se loď nezačne pohybovat.
- tohle bylo tím, že jsem do výpočtu braking anglu předával this.getPosition()
  místo this.waypoint.
[fixed]

TODO: Vyzkoušet translaci kamery ve FlightScene, aby byl vizuálně počátek
  uprostřed obrazovky (je to asi lepší, než tranformovat všechny souřadnice.
  (a možná to pak udělat i v background scene)
[done]

TODO: Zobrazovat desiredRotation.
[done]

TODO: V CoordsTransform volat parametrizované funkce (deduplikace kódu).
[done]

TODO: Při té příležitosti asi změnit FPS fyziky (klient se klidně může
  renderovat častějš).
  - otázka je, jestli 50 nebo ještě míň (asi to bude chtít vyzkoušet).
Dal jsem 50.
[done]

Ok, takže každopádně:
TODO: Zavést Physics.MAXIMUMUM_POSSIBLE_SPEED
  a checkovat ve steeringu, že se nesnažím jít vejš.
[done]

TODO: Občas se mi nenačte background :\
- asi jen v práci
[snad fixed]

TODO: Když umře server tak SendWaypoint na klientu hodí Uncaught Error.
[fixed]

TODO: Odchytávání výjimek ze Steeringu.
- to už možná je, ale chce to zkontrolovat.
[done]

TODO: Projít všechny metody ve Vehicle, jestli musejí být public.
- funkcionalita přesunuta do VehiclePhysics
[done]

- Místo Phaser.Scene všude předávat Scene
  (což je z ní beztak zděděné, ale je to můj interní typ).
[done]

TODO: odchytávat výjimky z Tilemap.getShape().
[done]

TODO: Server/Zone.getSceneUpdate() by se asi mohlo jemnovat prostě
  getUpdate().
A SceneUpdate (packet) by se mohl jmenovat ZoneUpdate.
(updatuje se stav zóny, kterej si pak klient promítne do scény).
[done]

TODO: zone.steerVehicles() by se možná dalo hodit do update()
  (opět aby to bylo koncepčně stejně jako na klientu).
[done, sort of]

TODO: WaypointModel dát do FlightSceneGUI
TODO: Mouse dát do FlightSceneInput
  (nebo možná nechat přímo ve FlightScene)
- SceneContents přejmenovat na SceneInput
[done]

TODO: FlightSceneContents v původním významu postrádá smysl,
  lodě a objekty teď budou ve scéně.
  - pořád někde musí být waypoint (i když ten možná může bejt v ShipModelu)
    a background (ten by zas mohl bejt v úplně jiný scéně...).
  - každopádně pokud to zůstane, mělo by se to asi jmenovat jinak.
[done]

TODO: Posílání změny waypointu by nemělo být ve WaypointModelu.
[done]

TODO: V Mouse.getPosition() použít CoordsTransform.
[done]

TODO: Keyboard a Mouse by měla creatovat Scéna (jsou to taky wrapper objecty).
[done]

TODO: Hmm, dědění Myši je možná zbytečný, můžu to obsloužit ve SceneInput.
  (případné callbacky se dají provolat zpět do sceneInput a tam zpracovat).
FlightSceneMouse zrušena.
[done]

TODO: Animation by asi mohla bejt samostatná classa
  (teď se to dělá přes Scene).
- scene.createAnimation() by mohla vrátit rovnou Animation.
  - problém je, že frameNames vyrábí taky scéna...
Tohle by fakt řešilo, kdyby se Sprity a podobně vyráběly metodama Scény.
  Pak by prostě scéna do jejich konstruktoru passnula příslušný vyráběcí
  bazmek (třeba anims) a bylo by...
[done]

TODO: ShipModel by asi nemusel vyrábě exhaust spirty a animace,
  to by měl dělat Exahusts (ExhaustsModel?).
[done]

TODO: ShipAudio asi nebudu potřebovat, zvuky budou přímo v modelech.
  (to asi dává větší smysl).
[done]

TODO: Vyrobit plugin classu Physics/VehiclePhysics a přesunout do ní
  většinu toho, co je ve Vehicle.
- Vehicle potom může bejt v Game (nebo prostě tam co ostatní entity).
- Ve vehicle asi zůstane jen obecná logika steeringu (skládání jednotlivých
  behaviourů, respektive nastavování vah).
[done]

TODO: Mrknout se i na vyrábění PhysicsBody.
- asi by to mělo bejt stejně jako grafické objekty
- to bych ovšem musel udělat ještě jinou classu, nejspíš VehiclePhysics,
  která by v sobě držela fyzikální properties lodi (vehiclu) a vyráběla
  physics body.
- Taky by to mohlo bejt řešené dědičností. Vehicle by dědilo z PhysicsObjectu,
  kde by byly příslušné properties (možná budou static bodies jinak, ale to
  můžu řešit, až je budu mít).
Každopádně takhle:
- PhysicsBody je wrapper classa.
- vyrábí ji PhysicsWorld
{err, zatím na to kašlu}
  i když...
Každopádně mít všechno v rootu entity je blbost, to bude za chvíli strašně
  nepřehledný. Takže určitě musí existovat nějakej kontejner.
  - ten může mít buď physicsBody v sobě, nebo to může bejt čistě config
    a physics body bude stranou.
[done]

TODO: class PriorityQueue si zaslouží vlastní file.
[done]

TODO: Importovat celé Utils.String místo jednotlivých metod
  (skryje to String, který se stejně nemá používat, takže v pohodě).
[done]

TODO: Přehodit obsah Utils/Math to Utils/Number.
- to bude trochu složitější, Vehicle používá intervalBound a normalizeAngle.
Asi se to nebude moct jmenovat Number. Možná NumberValue?
- ale jo, bude to Number.
[done]

TODO: Number asi není serializovatelný.
 - Možná ale ani nemusí bejt, pokud ho budu používat pouze jako knihovnu
   funkcí.
[won't do now]

TODO: doladit vizuály exhaustů
- úlně je schovávat, když nejsou aktivní.
- dát jim nějakou minimální délku (jako u zadních).
[done]

TODO: Možná kromě exhaustů vypínat i zvuky, když je nulovej thrust.
[done]

TODO: Zvážit, jestli neclampovat v konstruktoru UnitRatio
  místo házení výjimky.
  - i když asi ne. Lepší je, když se musí explicitně napst UnitRatio.clamp().
[won't do]

TODO: Sound volume občas není v povoleném intervalu.
[fixed]

TODO: Number, IntervalNumber a Ratio by měly být Serializable
  (nebo musím upravit Serializale, aby je umělo savovat).
[done]

TODO: Classy UnitRatio a PositiveUnitRatio by asi nemusely držet
  minimum a maximum jako instance properties (stačí static)
[done]

TODO: Po reloadu tabu zůstává pravý přední exhaust naplno.
[fixed]

TODO: Mám prohozený směry thrusterů.
[fixed]

TODO: Zvážit SymmetricUnitRatio a UnitRatio
      místo UnitRatio a PositiveUnitRatio.
- UnitRatio je ve skutečnosti blbě, to může bejt třeba i 7:1
- Správné slovo je "Portion"
  - opět je ale otázka, co s <-1, 1>
    Portion, NonegativePortion?
ZeroToOne
MinusOneToOne
Portion
NonegativePortion
[vyhrálo ZeroToOne]

TODO: Někde jsem potratil vektory.
[fixed]

TODO: Předělat vyrábění StaticTilemapLayer a DynamicTilemapLayer
  (ty teda vyrábí tilemapa, ale princip by měl bejt stejnej).
- Ty se zatím nikde nevyráběj a jako parametr dostávají phaser tilemapu,
  nikoliv Tilemap, takže ok.
[won't do now]

TODO: Předělat Scene.createSound()
[done]

TODO: Předělat Scene.createTilemap()
[done]

TODO: Neměl by se PhaserObject.Config aplikovat v konstruktoru PhaserObjectu?
- asi jo, no. Chci po scéně věci, které by vůbec neměla dělat.
  Měla by prostě jen vyrobit příslušnej phaserObject a konec, setovat
  mu properties by měly wrappery.
V konstruktoru to nejde, ale je na to metoda applyConfig()
[done]

Hmm, ono by to asi celý mělo bejt tak, že scene.createNěco() vytvoří
  a vrátí rovnou wrapper, nikoliv interní phaserovou property.
  - takže createAnimation() by mělo vrátit Animation,
    createSound() by mělo vrátit sound, atd.
  - čili konstruktory wrapperů pak nebudou dostávat jako parametr
    Scene, ale to, co mají wrappovat.
{ Tohle asi nebrat - intuitivnější je udělat 'new Sprite()'. }
Bohužel teda u PhysicsWorld a createBody() to takhle nepůjde, protože
  v body si Vehicle drží fyzikální properties (a má ho tudíž od začátku,
  přestože ještě není v physics worldu).
  - Možná bych to ale mohl předělat, vrátit properties do PhysicsConfigu,
    nebo tak něčeho a PhysicsBody vyrábat opravdu až v addToPhysicsWorld().
    - asi jo.
[won't do]

TODO: Aktivita scény by se mohla zapisovat přímo do scény místo extra flagy.
  (sleep/wake, nebo tak něco).
- scene manager má přímo setActive() a isActive(), to by mohlo stačit
  (tzn. v konstruktoru by se setovalo setActive(false)).
(Aha a můžu použít setActive(boolean) místo activate/deactivate).
[done]

TODO: Graphics (a vůbec všechn phaser object wrappery) by měl
  v konstruktoru přijímat options (a možná i config) stejně jako
  Sprite.
- a měl by tam být container.
[done]

TODO: Potřebuju vůbec u phaser object wrapperů rozlišovat Config a Options?
- co brání tomu, aby to bylo v jednom objektu?
TODO: Config by mohl být zděděný z nějakýho základního Configu
  (PhaserObject.Config asi)
  - position, rotation, depth, container, ať neopakuju pořád stejnej kód.
[done]

TODO: Přejmenovat všechny modely na XxxModel.
  (a asi bych taky mohl sjednotit, jestli se dědí z Phaser object wrapperů,
   nebo se tyhle objekty wrappujou).
[done]

TODO: Vyhodit z BackgroundScene scrollFactor.
[done]

TODO: adresář FlightScene možná přejmenovat na Flight a BackgroundScene
  na Background?
[done]

TODO: Opravit resizování backgroundu
  (nejspíš se mi neprovolává resize() kam má).
{ Zatím to nechám takhle - funguje to, to stačí }
[done]

TODO: Udělat BackgroundScene
(BackgroundModel možná vůbec nebudu potřebovat - v BackgroundScene
 beztak bude jen jedna sprita).
- Background model jsem nechal, třeba do něj časem něco přibude.
[done]

TODO: Fyziku přesunout do shared kódu (ve finálu tam bude muset bejt,
  aby šlo dělat client-side simulaci, tak bych s tím rovnou mohl počítat.
  (klient-side simulaci ale zatím dělat nebudu).
  [done]

TODO: Server root jsem vrátil na ${workspaceRoot} - server servuje
  klienta, takže to dává smysl.
  - možná by se Client mohl rovnou jmenovat WWW, wwwRoot, nebo tak něco
    (i když, Client je asi ok).
- Potom je taky otázka, jestli má vůbec smysl adresář /Server.
  Spíš ne, je to akorát matoucí. Momentálně obsahuje /js a /Keys,
  což obojí asi může bejt rovnou v rootu (/js by se možná mohlo jmenovat
  /build, ale na clientu je to /js, tak asi dává smysl mít to stejně).
(Tohle je teda zrovna dost blbý dělat, když se to nedá přeložit, pustit
 a otestovat, takže to asi odložím.)
- otázka je, co s adresářem /Server. Buď ho zrušit úplně a přesnout
  /Server/js do rootu, nebo ho přejmenovat na Build, takže by bylo
  /Build/js/...
  - /Build by měl smysl, kdyby do něj časem přistálo víc věcí, než jen
    javascript. A taky je idiomatický (líp vyjadřuje, o co jde, než čistě /js)
  - hmm, nebo /bin? i když, /Bin by asi vypadalo blbě, takže spíš /Build
Ok, přejmenuju /Server na /Build.
[done]

TODO: Umožnit na klientu víc lodí.
- a pořádně to projít i na serveru, asi je to teď lehce zmatený.
  (getPlayerShip() je ale ok řešení, asi by šlo použít i na klientu).
- tohle pořeší předělání na scény, ale i tak to projít
{asi done - lodě jsou v zóně}
[done]

Problém: Jak se dostat k json datům tilemapy, které loadnul Phaser?
  Možná takhle:
    let data = this.cache.json.get('levelData');
  JSON se případně preloaduje takhle (ale je blbost ho loadovat dvakrát):
    this.load.json("yourkey", "your.json")
{Je to trochu jinak, čte se to z cache.tilemaps.get('levelData').data}
[done]

TODO: Výhledově zdědit Client/Ship ze Shared/Ship
- ještě to dotáhnout.
[done]

Takže TODO:
- posílat EnterFlightRequest až poté, co je vyrobená (ne preloadnutá)
  flight scéna.
[done]

Otázka je, jestli se má shape posílat v rámci přidávání lodě do scény,
nebo spíš na klientu vyrobit z dat tilemapy stejně jako na serveru.
- logičtější by asi bylo ho tam vyrobit, protože data tilemapy musí
  načíst tak jako tak.
  - bude tam ale pak chybět kontrola, že to má opravdu takovej shape, jako
    si myslím (jakej to má na serveru).
  - na druhou stranu posílat shape pro každou tilesu je blbost, stejně jako
    posílat ho pro každou loď znova.
Pak je ještě otázka, co všechno se má poslat s lodí, aby se dala na klientu
správně zobrazit.
- ideálně asi poslat celou entitu (její Shared část) a neřešit to...
- každopádně teď ale asi budu muset poslat shapeId
{shapy jsou pořešené, posílání lodě zatím počká}
[done]

TODO: Na clientu loadovat tilemapy ve scéně
- na to asi budu muset dát klientu vědět, jakou scénu má loadovat.
  (v rámci EnterGame?)
  - jednotlivé zóny budou instance stejné classy, takže bude opravdu
    potřeba ta data poslat.
  - místo ShipToScene pak taky budu posílat UpdateZone, nebo tak něco
    (a přibalit do toho celou shared Ship, místo abych z ní musel něco
     vytahovat).
  Posílat entity zatím nebudu - vezmu to natvrdo ze Zone.preloadData.
  - ok, to bych měl dělat v rámci preloadu scény.
TODO: A vyčíst z nich shapy
TODO: Ve FlightScene.createShip() použít shape loadnutej z tilemapy
  místo shapu poslaného ze serveru.
[done]

Scéna nepotřebuje odkaz na zónu - renderuje se zóna do scény, ne naopak.
- tzn. asi bych měl nejdřív vyrobit flight scénu a až pak si říct serveru
  o zónu (tzn. poslat EnterFlightRequest).
    Díky tomu pak bude existovat flightScene ve chvíli, kdy dostanu scénu
  a věci v ní, a tudíž jim můžu dát scénu jako parametru.
Nějak jsem to pořešil.
[done]

TODO: FlightScene.preload()
- loadovat podle seznamu v zóně.
[loadování je celé předělané]

TODO: Vyházet z konstructoru Client/Ship() vyrábění grafiky a tak
  a dělat to až z FlightScene.create()
  (nejspíš provolat scene.create(), která provolá create() jednotlivých
   lodí ve scéně).
- problém je, že pak grafické bazmeky v Shipu nebudou inicializované
  v konstruktoru. Možná je všechny sloučit do ShipGraphics?
  - ono to tak vlastně i je, jen exhausty a zvuky jsou mimo.
    (což možná není nutný, exhausty jsou očividně grafickej bazmek,
     takže klidně mohou být v shipGraphics.
  - Zvuky by tam ideálně měly bejt taky.
    - V tom případě by se to ale asi nemělo jmenovat ShipGraphics. Jak?
      - ShipMedia? ShipMultimedia? ShipAudiovisuals?
      ShipModel, ha!
[done]

TODO: zone.update() se nikde nevolá
  (tzn. se nevolá ani steerVehicles()).
[done]

TODO: Vyhodit vyrábění tilemapy z konstruktoru ShipModelu
  (tilemapa se bude vyrábět v creatu flightScény).
[done]

TODO: Mrknout se na serveru, jestli se initShapes() v zone.preload()
  nemůže volat až v creatu (na serveru to je všechno async, ale i tak
  by asi bylo lepší, aby to bylo stejně jako na klientu).
- zone.create() na serveru vůbec nemám, ale mám tam createPhysicsWorld(),
  s tím by se to možná dalo sloučit.
[loadování je celé předělané]

TODO: Scény přemístit do Scenes.ts
[done]

TODO: Scény vyrábět metodou, která je nacpe do setu a zkontroluje přitom,
  že je jméno unikátní.
[done]

TODO: Exhausty by měly být pod lodí, ne přes ní.
  (obávám se, že to možná bude znamenat, dát je do samostatného layeru).
  - nebo možná jen prohodit pořadí vytváření asetů.
Prohození pořadí vytváření assetů pomohlo, zatím to nechám být.
[done]

TODO: Vyrábět v zóně seznam shapů
- na serveru
  - tam se to snad dělá
- na klientu
Začnu tím, že flight scénu nebudu předávat do konfigu Phaser.Game 
(tím se totiž rovnou pustí preload() a create()), ale pouze ji vytvořím
 a preload pustím později ručně.
- FlightScene nesmí vyžadovat zónu.
[done]

TODO: Zkontrolovat, že se při vytvoření shipy na clientu
  správně získá shape ze zóny.
[done]

TODO: Ship na clientu budu muset asi pojmout úplně jinak
  - měla by být schopna existovat v zóně, i když ještě není ve scéně.
I když, hmmm.
  Možná, že ne - flight scéna přece jen asi může existovat už od začátku.
  Jen je teda otázka, jak vyřeším preload...
Zjevně se nějak řeší, jeslti je scéna "active", a tedy ji má Phaser automaticky
  loadnout a pustit, viz:
  http://www.html5gamedevs.com/topic/36148-phaser-3-scene-phaser-2-state-passing-data-to-init-when-start/
[done]

TODO: Loading scene: https://phaser.io/news/2018/05/phaser-3-preloader-tutorial
[done]

TODO: Ještě líp popsaný loading:  
https://jwiese.eu/en/blog/2018/04/phaser-3---loading-screen--asset-organization/
[done]

TODO: Vyrobit client verzi Zóny.
[done]

TODO: Zajímavá myšlenka: Předělat klienta přes async funkce, stejně
  jako server (metody preload() a create() by resolvnuly promisu,
  což by spustilo moji vlastní load() případně init() funkci).
- při té příležitosti používat flagu zone.active.
  (když budu z něčeho volat create(), tak tam můžu rovnou zavolat
   zone.activate()).
Renderer.startFlightZone() by to mohl spouštět
- respektive rozdělit ho na await Renderer.loadFlightZone() a následně
  create(), init(), nebo tak něco.
  - postload() asi radši ne, to by mátlo v souvislosti s preloadem (kterej)
    teda bude skrytej, ale i tak.
[done]

TODO: Pořešit TODO v Client/SceneUpdate.process().
[done]

PROBLÉM: Na serveru se loď při přidání do zóny rovnou přidá do physics
  worldu (což celkem dává smysl). Na klientu to ale asi nepůjde, protože
  ze zóny se čte, co se vlastně má loadovat, tudíž by v ní měly bejt lodě
  ještě před preloadem.
  - i když. Potřebuju v zóně insertnuté celé lodě, abych mohl začít
    preloadovat? Asi nepotřebuju.
    - v zásadě asi ani nepotřebuju seznam lodí (idček) v zóně
Ok, lodě se do zóny přidávají až v creatu (takže jdou přidat rovnou do physics
  worldu).
[done]

TODO: Aha, kurning. Při reloadu browser tabu se vyrobí nová connection,
  takže starej account zapomene...
ok, prozatím vyřešeno (Account je natvrdo v Accounts)
[done]

TODO: Když reloadnu browser tab, tak se znovu pošele EnterFlightRequest
  a znovu se vyrobí fighter (se stejným idčkem, takže neprojde přidání
  do scény).
Co s tím?
- buď musím při disconnectu player ship vyhodit ze scény a při dalším
  connectu ji tam zas vrátit (to asi nechci, tím by se mimo jiné dalo
  slušně cheatovat)
- nebo musím testovat, jestli ta loď už ve scéně je.
Nějak jsem to prozatím ohackoval
[done]

TODO: Create zvuků.
- zvuky by si asi měla vyrábět každá loď.
Idčko zvuku v ship.create() by se nemělo brát z preloadDat, ale z dat
  lodi.
(a opět se dostávám k tomu, že by zvuky asi měly bejt entity,
 Minimálně kvůli tomu, že když budu chtít změnit cestu ke zvuku u všech
 entit, které ten zvuk používají, tak to můžu přes entitu udělat na jednom
 místě).
Asi zatím do lodě idčko zvuku exhaustu můžu narvat natvrdo.
[done]

TODO: Preload zvuků (přidat je do zone.preloadData a přidat je do preload()
  na klientu)
[done]

TODO: Přejmenovat Client/Engine/Container na GraphicContainer
- včetně proměnné v ShipModel.
[done]

TODO: Umožnit, aby Ship.model nemusel existovat.
- a vyrábět ho až v create().
[done]

TODO: Přejmenovat property Client/Ship.graphics na model.
[done]

TODO: Hodit ShipSound do ShipModel.
[done]

TODO: Hodit ShipExhausts do ShipModel.
[done]

TODO: Hmm, ShipAudio by asi bylo lepší než ShipSound.
[done]

TODO: Přejmenovat ShipGraphics na ShipModel
[done]

TODO: Startnout flightZónu
  (nejspíš v EnterFlightResponse.process()).
[done]

TODO: Renderer by se možná mohl jmenovat Engine, ať je to stejně jako na
  serveru.
[done]

TODO: Scene by měla wrappovat Phaser.Scene, ne extendovat
  (všude mám wrappery jen scéna je potomek).
[done]

TODO: První packet na server můžu poslat, až když se spustí onOpen event.
- buď sendEnterFlightRequest() přesunu tam,
- nebo z connection.connect() udělám async fci, kterou z KosmudClient.start()
  awaitnu (connect() by vyrobila promisu a awaitnula ji).
Ta druhá varianta by znamenala, že se mezi connect() a otevřením socketu
  nebude moct nic jinýho dělat - leda bych tam awaitnul nějakou složenou
  promisu. Jednodušší asi v tom případě bude, udělat to callbackem.
[done]

TODO: Zóna by měla mít vlastní physics world.
- na klientu i na serveru.
[done]

TODO: Přidat ship do physicsWorldu.
- v Zone.addShip().
[done]

TODO: Na dvou místech transformuju z Tiled koordinátů do Phaser koordinátů
  (odečítá se tam půlka tilesy). Asi by stálo za to volat na to metody
   z CoordsTransform (čistě kvůli tomu, aby se dala snadno najít všechna
   místa, kde se transformují nějaké souřadnice).
[done]

TODO: getPlayerShip() na serveru nedává smysl - hráčských lodí tam bude víc.
- potřebuju propojit connection a ship.
  - buď do connection natvrdo vrazím odkaz na ship,
    nebo musím vyrobit Account
    - do connection dát odkaz na Account
    - do accountu dát odkaz na ship
Hmm, sakra, asi bych měl zavést event (packet classu) na EnterGame nebo
  tak něco, kterou klient pošle po připojení k serveru.
- ve zpracování tohohle eventu se vyrobí new Ship a setne
  se do connection (ještě lépe do accountu).
  (výhledově by se teda ship měla začít loadovat hned po autentifikaci, ať
   player zbytečně nečeká).
[done]

TODO: Struktura server aplikace:
- dávalo by asi větší smysl, kdyby loopoval Engine a Game jen tikala,
  stejně jako fyzika.
- steer() by možná neměl bejt součástí tiku fyziky, ale tiku hry.
  (protože při tom bude potřeba procházet herní entity).
[done]

Hmm, vyrábět PhysicsBody v konstruktoru Vehiclu asi nepůjde.
- musel bych physicsShapeId předávat konstruktoru jako parametr,
  což by asi zatím fungovalo, ale až to budou entity tak ne
  (leda by shapy byly entity, pak by se to provázalo automaticky při loadu
   - jenže tím bych měl inicializovaný pouze shape, nikoliv physics body).
Čili správné řešení asi je, že může existovat Vehicle mimo physics world
  (který tedy nemá physics body).
[done]
- hmm, pak to ale vlastně asi nebude nutný preloadovat (tilemapy asi jo,
  shapy z nich půjdou vytáhnou při initu - to se teda ostatně dělá už teď).
  - tzn. že bych se vrátil k tomu, že nemám shapeId, ale "adresu" shapu
    uvnitř tilemapy? (která tilemapa, který object layer, který objekt)
    To je asi blbost, shapeId dává smysl.
[done]
- Umožnit nemít vytvoření physicsBody by znamenalo ve Vehicle zavést metodu
  getPhysicsBody, která bude házet výjimku při neexistujícím physicsBody.
  Tzn. prakticky všechny metody ve Vehicle budou házet výjimky
  (na druhou stranu díky tomu se s tím bude pracovat jako teď, takže to je
   asi ok).
[done]

- Vyrobit Shared/Game/Zone (ať na to rovnou vidí i klient. Jo, to je určitě
  potřeba, protože tam bude seznam věcí, co se mají preloadnout + jejich
  idčka).
[done]
- dát do ní seznam tilemap a shapů, které se mají loadovat (čili ne do Ship!).
[done]
- v Zone.preload preloadovat tilemapy a vyrábět z nich shapy (podle seznamů).
  - to mimojiné znamená, že nepotřebuju Tilemaps.ts - tilemapy a shapy budou
    v zóně.
[done]

Asi bych taky mohl na serveru vytvořit Zónu, víceméně čistě pro posílení
  představy, že jedné zóně na serveru odpovídá jedna scéna na klientu
  (zóna je prostě všechno, co může bejt najednou v physics worldu a může
   to tudíž vzájemně interagovat).
[done]

TODO: Asi bych mohl udělat seznam toho, co se má pro scénu/zónu preloadnout.
  - zatím klidně natvrdo do scene.preload() (respektive na serveru
    zone.preload()) s tím, že časem to zřejmě bude savnuté v zóně
    (jaké prototypy zóna obsahuje).
[done]

TODO: Někde by asi měl existovat seznam tilemap a shapů, které se mají loadnout
  - Na druhou stranu to může bejt pro každou scénu jinak. Obecně každá scéna
    (ve smyslu zóna s jedním physics worldem) by měla vědět, co do ní patří.
    - momentálně mám jen jednu scénu/zónu, takže prostě při loadování
      je to potřeba vyjmenovat.
  Seznam je teď ve scéně (časm by se mohl sestavovat z prototypů entit
    vložených do scény, ale to je daleká budoucnost).
[done]
V zásadě jsem zase u toho, že buď musím udělat 4 classy pro 4 typy lodí,
  nebo musím zavést entity. Ovšem údaje o tom, jaké shapy je potřeba loadnout,
  dost dobře nemůžou mít až instance lodí...
Mohou to ovšem mít prototypové entity lodí.
- zatím budou 4 instance (ze kterých se časem stanou prototypy).
  properties jim setuju natvro ručně (zatím jen physics shape,
   časem přibudou minimálně ostatní physics properties).
[done, for now]

1) Opravit pohyb lodi, aby se rozumně otáčela a zabrzdila na waypointu
   (couvání a strafování zatím netřeba).
   - ještě to není úplně ok, ale prozatím se dá.
[done]
2) Efekty trysek (grafický a zvukový).
[done]
5) Lepší physics body shape pro loď
[done]
   (a pro překážky taky).
6) Anchor pointy (pro exhausty, časem pro zbraně).
   - je to ještě lepší - sprity se rovnou umisťujou v Tiled editoru.
[done]

TODO: Vehicle.addToPhysicsWorld() by si mělo o shape říkat zóně, ne
  Tilemapsům.
  (Vehicle by mělo vědět, ve které je zóně.)
[done]

Tilemaps.ts zatím vypadá, že by se měl jmenovat spíš PhysicsShapes.ts.
  - nope, shapy budou v zónách.
- respektive nejspíš nemusí existovat vůbec (a pokud, tak bude schraňovat
  tilemapy, ne shapy).
Zrušeno. Tilemapy si drží (vyrábí) zóny.
[done]

TODO: Vehicle by mohlo mít rovnou property physicsConfig místo samostatných
  properties, ze kterých se physicsConfig vyrobí.
- otázka ovšem je, jestli mi pak bude fungovat dědičnost
  (jako že defaultně asi nebude. Asi by fungovala, kdyby to byly opravdu
   entity, což ale zatím nejsou).
- a odněkud se taky musí brát shapeId...
Zatím jsem to vrátil přímo do classy, kvůli dědičnosti. Až budu mít
  prototypovou děčičnost entit, tak to můžu zvážit znova.
[done]

TODO: Preload physics shapů (zaregistruje a vrátí shapeId);
- ještě je teda otázka, jestli to držet v paměti, nebo to tahat z tilemapy.
- i když, vehicly se budou vytváře průběžně a pokaždý budou potřebovat shape.
  (to spíš bude možný po naparsování zahodit data tilemapy).
[done]

TODO idčko tilemapy definující physics shape by taky mohlo bejt rovnou ve Vehicle
  - Vehicle by si pak samo vytvářelo Physics shape.
Je tam shapeId, idčko tilemapy Vehicle nepotřebuje.
[done]

TODO: Ship by asi neměla dostávat jako parametr physicsConfig.
  Místo toho by asi tyhle properties měla rovnou mít (nejspíš v předkovi,
  ale to teď nemusím řešit). Od physics shapu asi stačí idčko s tím,
  že si shape vyžádá od nějakého manageru shapů (Zone).
[done]
- výhledově by asi taky neměla init těla a podobně dělat v konstruktoru,
  ale až v initu, protože to bude entita a bude se loadovat (init() se bude
  volat ručně po loadu).
- dělá se to přes addToPhysicsWorld()
[done]
Anyways, co s tím teď?
- Potřebuju beztak sloučit parametry (jméno tilemapy, jméno object layeru,
  jméno objectu v něm).
  - Takže kam s nima?
  Zatím to prostě narvu do Shared/Ship, nebudu se to snažit vyřešit
  všechno naráz. Konstruktory ať klidně konstruují, monetálně potřebuju
  hlavně sloučit konstanty na jedno místo v kódu (jako inicializované
  properties classy, ať se dají později měnit).
  - respektive fyzikální properties by asi měly bejt rovnou ve vehicle
    (tam už ostatně některé jsou, jen mimo classu).
- narval jsem to do zóny.
[done]

TODO: Jméno tilemapy by se mělo brát
  ze Shared/Game/Ship/TILEMAP_NAME (aby bylo stejný na klientu
  i na serveru - je to ostatně stejná tilemapa). Teď není Client/Ship
  zděděná ze Shared/Ship, takže to není tak jednoduchý.
  (viz ShipGraphics.constructor()).
[done]
TODO: Sloučit Ship na clientu a serveru, aby se používaly stejné
 properties (názvy layerů, cesta k tilemapě a tak).
 - Cesta k tilemapě teda bude muset mít jinej prefix.
[done]

TODO: Přehodit stuff ze Server/Tilemap do Shared/Tilemap.
TODO: Potřebuju já vůbec client/server verze Tilemap classy?
- liší se jen loadování a to by beztak bylo lepší dělat externě
  (loadnout json object a předhodit ho konstruktoru).
- poněkud jsem zapomněl, že na klientu tilemapu používá phaser...
  (tam teda vlastně asi nemusím řešit paměť, takže klidně můžu držet
   tilemapu v paměti 2x).
Každopádně ale client verze Tilemapy existovat musí.
[zrušnea Server/Tilemap]

TODO: Ještě jednou zvážit, jestli má být Config spíš v Physics nebo
  v PhysicsBody. Physics.Config se sice líp píše, ale technicky vzato
  to není konfig celé fyziky, ale opravdu cofig PhysicsBody.
- takže to asi spíš vrátit zpět do PhysicsBody.
[done]

TODO: Úplně se mi nelíbí, že je Tilemap pokaždý v jiným adresáři
  (v /Shared/Physics, /Server/Physics ale /Client/Phaser).
IDEA: Client/Phaser přejmenovat na Client/Engine
- pak by teoreticky mohl být i Shared/Engine a Server/Engine a Tilemap
  by mohla být tam.
- jo, udělám to tak.
[done]

TODO: Zdědit Vehicle z Entity (protože proč ne).
TODO: getErrorIdString() přejmenovat na getErrorId().
- nakoned je z toho getter 'debugId'.
[done]

TODO: Shared/Game/Ship je možná zbytečná, Ship na clientu z ní není
  zděděná.
- tak možná ne, nějaké společné properties to už má.
[won't do]

TODO: Výhledově Ship zdědit z Vehicle a přesunout tam věci, které by ship měla
sdílet s jinými pohyblivými objekty.
[done]

TODO: Výhledově sjednotit formát importů (asi import { ERROR } from './ERROR').
- spíš to nechám postaru. Vidět v importu, jestli je to ze /Shared, /Client
  nebo /Server je docela důležitý.
[done]

TODO: Rozhodnout dilema s pojmeováváním class
- vidím to na SharedClass, Client/Class, Server/Class
- zatím používám trik:
   import * as Shared from '.../Class';
   class Class extends Shared.Class {}
[done]

TODO: Změnit konstanty, aby hustota byla nějaké rozumné číslo.
- bude potřeba příslušně zvednout thrust, což je ok.
Nebude to tak jednoduchý: když to zvětším, tak pak musej
  bejt mnohem větší všechny thrusty, torques a tak a vektory
  jsou pak přes celou obrazovku.
- takže to zatím nechám bejt.
[won't do]

TODO:
- předělat tilemapu lodi tak, aby byla placnutá "normálně".
- a vrátit do kódu translaci.
  (důvod: fyzika je taky posunutá a translace tam je, tak ať je to stejně).
[done]

TODO: Dát návrh na rozvoj tile animation pluginu.
[done]

TODO: SceneUpdate by asi mělo parametry dostávat trochu víc strukturovaně
 (konstruktor s 20 parametry už je trochu přes míru...)
- sort of done
[done]


TODO: načíst výstup z Tiled editoru.
- na serveru do fyziky, na klientu do grafiky
Body zkusím editovat rovnou u tilesy (pokud to bude fungovat pro object layer).
https://medium.com/@michaelwesthadley/modular-game-worlds-in-phaser-3-tilemaps-1-958fc7e6bbd6
[done]

TODO: Tilemap by pak mohla ještě vytvářet StaticLayery a DynamicLayery.
- asi to můžu připravit, tj. classy StaticLayer a DynamicLayer zděděné klasicky
  z PhaserObjectu.
StaticTilemapLayer a DynamicTilemapLayer možná nebudou moci bejt PhaserObjecty,
protože jejich phaser varianty nejsou zděděné z GameObjectu.
- možná jim dát jiného předka? (TilemapLayer)?
- nebo možná zdědit DynamicTilemapLayer ze StaticTilemapLayer.
Zjevně to funguje, i když to v Phaseru zděděné není.
- Připravené to je, zatím to nechám být.
[done]

TODO: Asi bych měl udělat shared předka classy Tilemap,
  kterého různě implementuje klient a server. Časem budu chtít počítat
  fyziku i na klientu a asi budu chtít vyrábět zóny stejnejma metodama,
  tak ať to na to je připravený.
[done]

TODO: Ship.getShape() by si asi mohlo výsledek pamatovat, ať se pokaždý
 nevolá tilemap.getShape().
- na druhou stranu volá se to asi jen jednou (rovnou se z toho vytvoří
  physics body), takž je to asi ok.
[won't do]

TODO: Načíst physics shape lodi.
  OK, jak budu vyrábět ship?
  - primárně každopádně na serveru.
    - loadne se entita. Ta má příslušnej typ (prototyp), tzn.
      má nasetovaný properties, jako třeba jakou má použít tilemapu.
    - na server se pošle info o tom, z čeho se má pro loď vytvořit grafika
      (hmm, to zavání posláním prototypu, abych ty datový struktury
       nemusel deklarovat dvakrát)
       - Momentálně to každopádně můžu na klientu a na serveru vytvořit
         paralelně.
   Ship na serveru (nebo možná i v Shared) by každopádně měla mít
     info o tom, jakou tilemapu má použít. Prozatím to může bejt
     přiřazený natvrdo, nemusí se to loadovat z disku
     (to mi ostatně ušetří posílání prototypu na klienta - když
      to bude natvrdo v shared kódu, tak na to klient uvidí automaticky).
Async constructor asi nepůjde - to znamená, že:
- buď musím nejdřív loadnout tilemapu a až pak udělat new Ship
- nebo new Ship a pak await ship.load().
Ship tak jako tak nebude existovat od začátku, takže by asi dávalo větší
  smysl, aby měla všechny properties inicializované v konstruktoru.
- to znamená udělat nějakej preload.
[done]

TODO: Vehicly (a obecně herní objekty) by asi měly mít nastavenou hmotnost
  spíš než hustotu (hustota by se měla dopočítat).
  - na druhou stranu když pak zvětším loď na dvojnásobek, tak bude
    mít absurdní hustotu (zůstane jí hmotnost...)
[kašlat na to, hustota je ok]

TODO: Vůbec se mi nelíbí přetypování tilemapy. Mělo by se to loadovat
  jako Serializable, aby se kontrolovalo, že tam jsou patřičné properties.
- Ono to je nakonec asi ok. Když budou data jinak, tak to tak jako tak hodí
  exception. Sice nebude moc dobře popsaná a vysvětlená, ale zas mít kód
  plnej ošetřování možnáho 'undefined' by bylo taky dost naprd.
[it's ok]

TODO: Procházení dat tilemapy je dost šílený - asi to bude chtít
  udělat tak, že to projdu jen jednou a při tom vytahám všechna potřebná
  data.
- ideálně by se to mělo offline přechroustat do formátu, kterej se nemusí
  traverzovat (všechno rovnou zaindexovat), ale na to teď není prostor.
  - při tom by se daly rovnou rozřezávat nekonvexní polygony.
[done]

TODO: Přiřadit Ship shape do body
  (místo stávajícího hacku na obdélníkové body).
- Skoro!
TODO: Pořešit, proč jsou všechny polygony přes sebe.
[done]

TODO: Přesunout interface Tilemap.Data do Shared/Tilemap.
[done]

TODO: Nakonec pořádně projít a pročistit ShipGraphics, tam jsem hodně
  hackoval.
[done]

TODO:
- pojmenvávat důsledně layery ("_layer"), tilesety ("_tileset").
  (tohle asi stačí pro názvy konstant v kódu - v editoru to může
   bejt bez přípony, tam to je přehlednější).
- bez podtržítek, ale done.
[done]

TODO: Konzistentně dávat do klíčů, názvů layerů a podobně příponu, co to je.
  tzn: "thrusters_layer", "exhaust_animation"
- bez podtržítek, ale done.
[done]

TODO: Zamyslet se nad konvencí stringových jmen a idček
  (mohou tam být mezery - mělo by se to normálně číst. Otázka je, jestli
   Všechna Písmena Velká nebo jak (to moc jako normální čtení nezní)...)
[done]

TODO: .tmx formát tilemap asi vůbec není potřeba - Tiled editor by měl
  umět načítat rovnou JSON.
- cesty k texturám jsou relativní, takže záleží na tom, kde je soubor
  savnutej. Jinak je ten save stejne jako export.
  - tzn. asi budu editovat rovnou z /Client. Aspoň nebudu muset nic
    exportovat.
TODO: Tzn /RawData/TileMaps kompletně zrušit.
[done]

TODO: Zprovoznit debugování
  (abych mohl debugnout thruster backlash při dobržďování).
- ono to kupodivu v server kódu funuje.
[done]

TODO: Doma si pročistit font cache GIMPu, ať nestartuje 100 let.
[done]

TODO: Když vyrábím sprity z object layeru, tak se jim nenastavuje
  base scale.
- pokud to nebude fungovat samo, tak musím baseScale spočítat
  jako poměr stávající velikosti a velikosti v textuře.
[done]

TODO: Nějak budu muset pořešit preload tilemapy
- možná zdědit FlightSceneTilemap z TileMap?
  nebo udělat FlightSceneTilemaps jako container TileMap
  (protože zatím je sice jen jedna, ale bude jich určitě víc).
Hmm, FlightSceneTilemaps asi nebyl dobrej nápad, to asi může dělat
  rovnou ShipGraphics. Tilemapy nesouvisející s lodí budu beztak
  chtít dát někam samostatně.
[done]

TODO: Udělat ve Sprite víc konstruktorů
  (možnost předat rovnou vyrobenou spritu, nejspíš bez animace).
- udělal jsem to přes union type, ale asi done.
[done]

TODO: Výroba spritů z tilemap object layeru.
  - asi statická metoda Sprity? Ee, Tilemapy.
    Nebo možná udělat classu na tilemapu, která tohle bude dělat
    (to je lepší).
  - vrátí Array<Sprite>
  - jako parametr bere pole jmen objektů v layeru.
  - rovnou posune sprity aby byl origin uprostřed
  - rovnou na ně přiřadí a pustí texturovou animaci
    (to by měl zvládnout konstruktor spritu).
[done]

TODO: Rozdělit Sprite.baseScale na  Sprite.baseScaleX a Sprite.baseScaleY
- nastavovat to při vyrábění spritů v Tilemap.createSprites.
[done]

TODO: Ještě líp by se baseScale mělo zapamatovávat až v konstruktoru Spritu,
  když dostane jako parametry Sprite místo configu.
  - a ostatně baseScale by mělo být jen ve Sprite.Config, ne ve Sprite.Options.
[done]

TODO: Opravit pozice a scalování exhaustů.
Ha, phaserSprite.originX a phaserSprite.originY jsou ratia,
  ne absolutní hodnoty!
[done]

TODO: Že bych vůbec texturovou animaci nevyráběl automaticky při vytváření
  spritu, ale vždycky mimo?
  - pak bych mohl do konstruktoru spritu předat prostě jen jméno animace.
TODO: Má být createAnimation statická metoda Sprity?
- kde jinde by měla bejt?
  Je to přece jen sprite animation (tilové animace se zatím dělají jinak),
  takže to asi dává smysl.
[je to ok]

Ok, TODO: Vyrobit celou loď úplně znova.
- vymyslet lepší název než "rogue"
  - missile_ship, railgun_ship,
  + fighter, bomber, support, assault (zatím takhle)
  [done]
- zmenšit loď na půlku.
  [done]
- v Tiled editoru ji dát do object layeru
  [done]
  - ve hře z ní pak udělat spritu
- vyrobit texturu s exhausty v TexturePackeru
  + vyexportovat texture atlas
  [done]
- naimportovat ji do Tiled editoru, vyrobit z ní tilesy
  [done]

TODO: Hmm, textura pro lodě (a nejspíš i exhausty) by zřejmě neměla
  být jen jedna a ne pro každou loď zvlášť.
  - a tile-size by zřejmě měla bejt něco malýho (tzn. že loď bude přes více
    tilů). To možná dost zkomplikuje editaci shapu (u lodí ho asi nechci mít
    složený z X tilů, nebo jo?)
- asi se na to vykašlu a nechám 1 ship per tile (ovšem i tak jich můžu dát
  na texturu víc).
[zatím nechám 1 tile per ship]

TODO: Rozhodnout defaultní orientaci spritů.
  Asi by to mělo bejt tak, že nulová 'rotation' odpovídá defaultní
  pozici, takže orientace "doprava" je dobře.
  (to bude mít i fajn side effect, že to bude texture packer nativně
   skládat správně. Zas to ale možná bude divně v Tiled editoru... Co už).
   Budiž to "doprava"
[done]
- a pak ji všude dodržovat (u lodi, u exhaustů)...
TODO: Předělat exhausty "doprava" místo "dolů)
[done]

TODO: Pročistit data.
[done]
TODO: Vyrobit znova data pro ship_fighter
- jen object layery
[done]

TODO: vyzkoušet https://github.com/nkholski/phaser-animated-tiles
- nefunguje kvůli bugu, viz:
  https://github.com/nkholski/phaser-animated-tiles/issues/2
- a je otázka, jestli vůbec funguje na sprity vytvořené z object layeru
  (spíš asi ne).
TODO: Každopádně vyzkoušet sprite animaci aspoň na tiles layeru.
[done]
- a možná bych si pak ten converter mohl napsat...
Plugin teď asi vůbec nebudu potřebovat
[na to zatím kašlu]

TODO: Exhausts možná přejmenovat na Thrusters?
- každopádně se pro něco rozhodnout a používat to všude (včetně tilemapy lodi).
Nechám exhausts
[done]

IDEA: Nejjednodušší asi bude, vyrobit tu animaci znova v texture packeru
  s tím, že sprity nechám poskládat jednu vedle druhý, tzn. tu textutu
  budu moct beze změny využít jako tileset v Tiled editoru.
- a můžu zkusit requestnout tile animaci spritů vyrobených z object layerů
  v tile animation pluginu...
- vyzkoušeno, udělám to tak.
[done]

TODO: Vytáhnout info o animaci z tilemapy,
  vyrobit tuhle animaci ručně a přidělit ji na exhaust spritu vytvořenou
  z object layeru v tilemapě.
- vůbec nejdřív tu animaci prostě vytvořit ručně (ať mám představu).
[na tohle zatím kašlat]

IDEA: Ještě bych možná mohl zkusit, že místo vyrábění spritů z object layeru
  vyrobím nové tilesy do tile layeru.
- Hmm, vlastně bych ty thrustery rovnou mohl udělat jako static layer,
  teda až na to, že pak nepůjde scalovat velikost...
Problém trochu je, že tilesy jsou velikostí nastavené na loď a všechny
layery zjevně musej mít tilesy stejné.
  Takže asi leda udělat v mapě lodě základní tilesy podle animace exhaustů
  (loď holt bude přes víc tilesů) - to je dost pitomý, protože to pak
  bude fungovat jen na tuhle konkrétní animaci.
[na tohle kašlat]

TODO: Než se pustím do refactoringu kódu a dat tile animací, tak přece jen
  ještě vyzkoušet texture atlas animaci na exhaust.
[done]

TODO:
  Uncaught Error: Failed to resize scene 'Flight scene' because scene contents doesn't exist
    at FlightScene.resize (FlightScene.ts:113)
    at Object.resize (Renderer.ts:27)
    at CanvasDiv.onResize (CanvasDiv.ts:72)
    at CanvasDiv.window.addEventListener (CanvasDiv.ts:52)
- dlouho se loadovalo (v browseru) a do toho jsem otevřel konzoli v Chromu,
  takže došlo k resize okna. Nejspíš ještě scéna nebyla vytvořena.
- asi prostě jen neházet error - když scéna nemá contents,
  tak není co resizovat.
[done]

TODO: Nastavovat scale a visibility exhaustů podle thrustu/torque.
[done, sort of]

TODO: přidat baseVolume do Sound.
[done]

TODO: Nastavovat zvukům thrusterů volume podle thrustu.
[done]


TODO:
- Posílat na klienta thrusty a torque
  [done]
- Scalovat je a zapínat/vypínat podle thrustů a torque
[done]

TODO: Přidat classu ShipSound
[done]

TODO: Zjevně potřebuju classu Sound.
[done]

TODO: Exhausts by asi mohly být v samostatné classe.
- sprity ale pořád musej přidávat do ShipGraphics, tedy do containeru.
  - čili class ShipExhausts by měla mít taky referenci na ShipGraphics?
[done]

TODO: Udělat strafing thrustery mnohem menší.
[done]

TODO: Přidat do spritu baseScale, který se bude přinásobovat při setScale().
[done]

TODO: Natáčel loď bych měl směrem k desiredSteeringForce, nikoliv směrem
  k desiredVelocity.
  Tím se bude trochu "přetáčet".
  - tohle můžu dělat jen při seeku. Jakmile začnu brzdit, tak se tímhle
    točím do protisměru - tzn. je potřeba točit k -desiredSteeringForce.
[done]

TODO: Proč mám na začátku loď otočenou o 180°?
- asi se bere, že je ve fázi brždění, takže se aplikuje rotationFlip...
- vrátil jsem tam zpět zákaz točení při malé vzdálenosti, to to prozatím
  pořešilo
[done]

TODO: Přejmenovat adresáře v /Client (na PascalCase).
- Huh, v práci začíná všechno velkým.
- v práci je to každopádně dobře, ještě to checknout doma.
[done]

TODO: posílat aktuální thrusty
  (asi stačí číslama, není nutný posílat vektory).
- implementovat getForwardThrustRatio(),
  getLeftwardThrustRatio(),
  getTorqueRatio()
[done]

TODO: Arrive
- ještě správně počítat breaking distance.
TODO: Breaking distance se nepočítá spávně.
TODO: Asi budu ji budu muset posílat na klient a zobrazovat.
(jakž takž)
[done]

IDEA: Určit na tvrdo nějakou malou vzdálenost (10 třeba).
- před ní bude desired speed dejme tomu 10% aktuální.
- za ní bude gradual slowdown.
Skoro!
- ještě asi přidat, že když jsem fakt blízko cíli, tak se nebudu točit jak
  čamrda.
Bude to chtít hódně refactoringu, ale snad to funguje.
[done]

TODO: Jak pojmenovávat texture atlasy?
- mám několik efektů v jenom atlasu
- Adresář v TexturePackeru by se asi měl jmenovat stejně jako výsledný atlas
  (tj. Exhausts00).
  - což je vlastně vstupní adresář.
- Zjevně potřebuju nějakej adresář na "raw data". Možná SrcData?
  - raději RawData, ať se to nebije se /Src
- Kam patří tps file? (Texture packer project?)
  - Taky do RawData. Možná přímo do Textures - vždycky tam, kde je adresář,
    ze kterého je atlas udělanej.
  Tzn.:
  /RawData/Textures/Effects/Exhausts/Exhausts00.tps
  /RawData/Textures/Effects/Exhausts/Exhausts00/ExhaustBlueConical
  /RawData/Textures/Effects/Exhausts/Exhausts00/ExhaustYellowConical
  /RawData/Textures/Effects/Exhausts/Exhausts00/ExhaustYellowRectangular
.
- i kdyz to mozna není uplně chytrý, protože bych mohl chtít dělat
  atlasy napříč logickým rozdělením. Tzn. ne vsechny exhausty, ale
  spis vsechny textury k jedne lokaci/scene.
  - tzn. atlasy by mely mit nezavislou strukturu:
.
  - Spíš TexturePacks (atlas je to až vyexportované).
.
  /RawData/TexturePacks/Effects/Exhausts/Exhausts00.tps
.
  A textury taky:
.
  /RawData/Textures/Effects/Exhausts/ExhaustBlueConical
  /RawData/Textures/Effects/Exhausts/ExhaustYellowConical
  /RawData/Textures/Effects/Exhausts/ExhaustYellowRectangular
.
Možná zrušit Graphics a nahradit to rovnou podadresářema (Textures, atp?)
- asi nemusím rozlišovat texture atlasy a jiné textury
  (atlas má prostě u sebe ještě json)
.
/Client/Textures/Background
/Client/Textures/Effects/Exhausts
/Client/Textures/Markers
/Client/Textures/Ships
.
To samé v RawData (tj. /Textures/...)
[done]

TODO: Vymyslet lepší adresářovou strukturu pro TexturePacker
- output určitě rovnou do /Client, ať to nemusím překopírovávat
  a nemám to dvakrát.
[done]

TODO: Dát lodi všechny exhausty (a na správná místa)
- 2 velké dozadu
- 2 malé dopředu
- 2 doleva
- 2 doprava
[done]

TODO: Zdědit Ship ze Steering (tedy z Vehicle),
  ať nemusím do steeringových funkcí předávat takový stohy parametrů.
[done]

TODO: Fixnout errory v konzoli na klientu
  "Texture.frame missing: 1"
  "Invalid Animation Key, or Key already in use: animation_exhausts_00"
[done]

TODO: "Skákající animace": Možná je to buglé:
  https://github.com/photonstorm/phaser/issues/3288
- tak je to tím, že je v texture packeru povolená rotation
  Nenašel jsem na to vypínátko, ale pomohlo přepnout Algorithm na "basic".
[done]

TODO: To přetáčení budu muset přece jen ještě nějak stabilizovat...
[done]

TODO: Ehm, ona ta původní varianta se skládáním desiredSteeringForce
  z forward a leftward složky byla asi dobře - jsou to přece jen dva
  oddělené propulsion systémy, takže ve spolupráci opravdu dokáží
  poskládat sílu v obdélníku.
  - zase to zapnout a vyzkoušet (možná bude loď míň "plavat").
Tak ne - je to sice asi technicky správně, ale loď pak "plave" mnohem víc.
Revertuju zpět na novější verzi.
[done]

TODO: Vyzkoušet přece jen rotaci přes torque...
- Funguje!
[done]

TODO: "Dobržďování" při rotaci by možná šlo zrychlit tím, že
  nebudu angular velocity limitovat hned, ale až když bude zbývat jen
  část mojí ANGULAR_VELOCITY (třeba desetina).
[done]
TODO: a možná bych mohl udělati "zrychlování" rotace, tj. aby to z 0 na full
  neskočilo okamžitě.
- tohle jsem vyřešil přes torque
[done]

TODO: Pořád je tam problém s výpočtem směru rotace, to musím opravit.
[done]

TODO: Opravit šílené zrychlování do boku.
  Zjevně mám chybu v úvaze.
  - Když totiž limituju složky zvlášť, tak se mi změní směr vektoru.
  Tzn. musím:
  - Zjistit, jakým faktorem se limituje v jednotlivých směrech.
  - Menším z těch faktorům pronásobit původní vektor.
[done]

TODO: Zvážit, jestli je rozumný tahat ship position z grafiky (spíš není).
- tzn. pamatovat si ji v Ship.
[done]

TODO: Přejmenovat GeometryGraphics na něco rozumnějšího (ShapeGraphics)
[done]
TODO: A taky oddělit data od renderování.
[done]

TODO:
S vektory v lodi by to mělo bejt tak, že data jsou zvlášť (v Ship)
  a příslušný Graphics oject (tedy renderování) by měl bejt v ShipGraphics
  (to, že se renderuje nezávisle na containeru, na věci nic nemění. Je to
   prostě součást grafiky).
  Při renderování by se měly vektory předat do ShipGraphics jako parametr.
A ShipGraphics tudíž může bejt ve Scene (respektive FlightScene).
[done]

TODO: DestinationMarker by se možná mohl jmenovat Waypoint
  (waypointů může ostatně jít zadat i víc, pak by se to obzvlášť hodilo)
- Server/Ship.seekPosition() by se mohla jmenovat setWaypoint().
[done]

TODO: Všude přejmenovat Geometry na Shape.
[done]

TODO: Výhledově v Client/Phaser nechat jen wrappery Phaser objektů.
  Zbytek hodit do jiného adresáře
  (Engine? Potom ale PhaserEngine bude jinde...).
  Navíc je Ship záležitost enginu nebo hry?
    (ono na klientu asi hra moc smysl nedává tak jako tak).
  I když... Na serveru je Ship taky v Game, takže by to aspoň bylo
  konzistentní.
.
Phaser
  Camera
  Container
  Scene
  SceneContents (Sice to není wrapper Phaser objectu, ale patří to do Scene,
    což wrapper je.)
  Graphics
  Keyboard
  Mouse
  phaser.d.ts
  Renderer (do kterého je mergnutý PhaserEngine) [done]
  PhaserObject
  Sprite
Game
  Ship
FlightScene
  Background
  DestinationMarker (Waypoint)
  FlightScene
  FlightSceneContents
  GeometryGraphics (tohle by se mělo jmenovat jinak. PhysicsShape?
    a stejně jako u ShipVectors - renderování by mělo bejt v ShipGraphics, ale
    data by se měla držet v Ship (a předávat do ShipGraphics jako parametr)).
  ShipGraphics? (to asi spíš do Scene než do Game)
  ShipVectors?
    (jako renderuje to, ale taky je to drží informace o lodi.
    Takže možná spíš Game? Na druhou stranu by to asi mělo bejt obecnější,
    vektory maj obecně všechny pohybující se objekty (tzn. Vehicles)
[done]

TODO: Přejmenovat SetDestination na SetWaypoint.
[done]

TODO: Sloučit PhaserEngine do Rendereru.
  Renderer (to už vůbec nevím kam. Scéna? Nerenderuje jen scénu...
    možná sloučit Renderer a PhaserEngine - to zní rozumně (asi pod Renderer)
- Renderer.getPhaserEngine() nemusí bejt public
  (může se to jmenovat getInstance).
[done]

TODO: Vyřešit problém s odečítáním úhlů a cyklením po 2*PI.
[done]

TODO: Když jsou vektory mimo kontejner lodi, musí mí jinak z-order.
[done]

TODO: Rotaci lodě říkat 'rotation', ne 'angle'
[done]

TODO: Možná ještě přece jen PhaserObject zdědit (nejspíš z CoordsTransform)
  a přesunout tam metody na transformaci koordinátů.
  (transformVector(), transformPolygon(), transformAngle()).
  - obojí musí být tam i zpět (takže by ty metody asi měly bejt pojmenovaný
    podle toho, z čeho do čeho transformují).
    angleFromPhaserToBox2d()
    angleFromBox2dToPhaser()
    vectorFromPhaserToBox2d()
    vectorFromBox2dToPhaser()
    polygonFromPhaserToBox2d()
    polygonFromBox2dToPhaser()
    - nakonec stačí jedna sada funkcí, protože fungují oběma směry.
  - možná by nemuselo bejt potřeba zvlášť setX() a setY().
[done]

TODO: Vymyslet, kam dát funkce lowerBound(), upperBound() a intervalBound()
  (momentálně jsou ve Steering).
[done]
TODO: Ještě jednou zvážit rozdělení Utils (a možná přejmenování).
  - /Utils/StringUtils by mohlo být prostě Utils/String.
  - applyDefaults() by mohlo být v Utils/Object
  - reportMissingCase() těžko říct kam, možná do Syslogu?
    (sice to nic neloguje, aspoň ne přímo, ale asi proč ne).
  - lowerBound, upperBound a podobně buď do Utils/Math nebo Utils/Number.
[done]

TODO: Graphics by potřebovala oddělit kód kterej pracuje s Box2d koordinátama
 a kód na transformaci koordinátů.
 (částečně to je, DrawLine a DrawPolygon jsou ty transformační metody.
  Možná je hodit do předka?)
[done]

TODO:
  Tohle by chtělo udělat nějak líp:
    this.container.add(this.geometryGraphics.getGraphics());
  (možná zdědit ShipGraphics z Graphics?)
[done]

TODO: Phaser.GameObject wrappery přece jen z něčeho zdědit.
- transformace zajistí interní setX, setY a setAngle v předkovi.
- spousta metod je stejná, chce to nějak podědit.
[done]

TODO: seek() se pořád místy chová divně
- jen při couvání směrem trochu šikmo na levou trysku...
- problém byl v tom, že se odečítaly úhly v různých intervalech
  (což pak při ořezání na menší interval občas dělalo psí kusy)
[done]

TODO: Opravit background.
[done]

TODO: Pořešit transformaci koordinátů mezi serverem a klientem
- flip y axis
- flip all angles.
TODO: Ještě v Graphics.
[done]

TODO: Vektory nakonec nesmí být v kontejneru s grafikou lodi
  (netočí se, jsou absolutní).
  - jo, ale musej se translatovat na pozici lodi.
[done]

TODO: Fce jako setDesiredVelocity() v Client/Ship by asi neměly překreslovat
  debug grafiku rovnou, ale pouze queueovat requst na překreslení
  (ať se to zbytečně nepřekresluje víckrát v jednom tiku).
[done]

TODO: DebugGraphics by mohla být samostatná class.
- nakonec jen ShipVectors (ať je to single responsibility class).
  (debugGeometry je přímo Graphics, na to není třeba extra classa)
[done]

TODO: Debugové zobrazení fyziky na klientu
  - physics body (obrys)
    [done]
  - target position
    - k tomu budu potřebovat měnit pozici pouze při button_down
    [done]
  - desired velocity
    - k tomu ji budu muset posílat v rámci SceneUpdate
    [done]
  - steering force
    (a to před limitem i po limitu ať vidím, jak moc se mi to ořezává)
    - po limitu done.
  TODO: Ještě před limitem.
[done]

TODO: Destination marker by se výhledově asi měl renderovat v nějaké UI scéně
(aby nescaloval se zoomováním - i když, možná to bude ok...).
- zoomování vypadá ok.
[won't do]
TODO: Dát mu Z-order (menší než DEBUG ale větší než DEFAULT).
- správně by to mělo bejt:
  Překážky ve scéně
  - Waypointy
    - Ship
      - debug graphics
[done]
TODO: Dát lodi Z_ORDER_SHIPS
[done]
IMPORTANT: depth je potřeba nastavit kontejneru (v Ship). Celej obsah
  containeru má zřejmě jeho depth (+ uvnitř to ještě může bejt jinak).
[done]

TODO: Destination market by měl zmizet, když na cílové místo dorazím.
- to je asi zbytečný, loď ho prostě překreje.
[won't do]

TODO: Zvážit, jestli místo matter.js nepoužít radši Box2d
- zváženo a použito
[done]

TODO: Seekovat k destination markeru, ne k pozici myši.
- to asi znamená, posílat něco jinýho než MouseInput.
TODO: Vyrobit a posílat paket SetDestination
TODO: Zpracovávat SetDestination na serveru (místo MouseInputu).
[done]

TODO: Destination marker má zůstat viditelný i po releasu buttonu
[done]

TODO: Opravit detektování mouse-down.
- je to chyba v Phaseru
[done]

TODO: Smazat ./vscode/Build, až ho nebudu potřebovat.
[done]

TODO: Updatovat verzi tasks.json (budu to muset celý předělat...)
[done]

TODO: Vyhodit tslint option "no-unused-variables" a nahradit ji typescriptovou.
[done]

TODO: Vyzkoušet ještě lint options co chtějí type info.
- nepovedlo se mi rozběhat.
[done]

TODO: Zkusit pouštět tslint před tsc (sice v tslintu píšou,
  že se má pouštět až na zkompilovaný kód, ale třeba to není
  nutný).
  - pokud to bude ok, tak smazat příslušné commenty v tasks.json.
[done]

TODO: Přidat do build tasku mazání starého buildu.
[done]

TODO: Možná do build tasku hodit i lint celého kódu
  (ideálně s type information), ať se při rebuildu
  checkne všechno.
- pokud to rozběhnu, budu potřebovat -e na ignorování Box2d.
[done]

for those who use vscode with tslint as editor/lintinig you can add the
following to the vscode config:
// Configure glob patterns of file paths to exclude from linting
"tslint.exclude": "**/PATH_eg_TESTS/**/*.ts"
- musím opravit liter errory, abych zjistil, jestli to pak pustí tsc
  ve watch módu
[done]

TODO: Zvážit použití
  https://marketplace.visualstudio.com/items?itemName=eg2.ts-tslint
  (kvůlivá kontrolám, které vyžadují type information)
- nepovedlo se mi rozběhat
[done]

Warning: member-ordering - Bad member kind: public-before-private
Warning: The 'prefer-readonly' rule requires type information.
Warning: The 'promise-function-async' rule requires type information.
Warning: The 'await-promise' rule requires type information.
Warning: The 'no-floating-promises' rule requires type information.
Warning: The 'no-for-in-array' rule requires type information.
Warning: The 'no-inferred-empty-object-type' rule requires type information.
Warning: The 'no-unsafe-any' rule requires type information.
Warning: The 'restrict-plus-operands' rule requires type information.
Warning: The 'strict-boolean-expressions' rule requires type information.
Warning: The 'use-default-type-parameter' rule requires type information.
Warning: The 'deprecation' rule requires type information.
Warning: The 'match-default-export-name' rule requires type information.
Warning: The 'no-boolean-literal-compare' rule requires type information.
Warning: The 'no-unnecessary-type-assertion' rule requires type information.
Warning: The 'return-undefined' rule requires type information.
[Warn  - 6:31:20 PM] Warning: member-ordering - Bad member kind: public-before-private
[Warn  - 6:31:20 PM] Warning: The 'prefer-readonly' rule requires type information.
[Warn  - 6:31:20 PM] Warning: The 'promise-function-async' rule requires type information.
[Warn  - 6:31:20 PM] Warning: The 'await-promise' rule requires type information.
[Warn  - 6:31:20 PM] Warning: The 'no-floating-promises' rule requires type information.
[Warn  - 6:31:20 PM] Warning: The 'no-for-in-array' rule requires type information.
[Warn  - 6:31:20 PM] Warning: The 'no-inferred-empty-object-type' rule requires type information.
[Warn  - 6:31:20 PM] Warning: The 'no-unsafe-any' rule requires type information.
[Warn  - 6:31:20 PM] Warning: The 'restrict-plus-operands' rule requires type information.
[Warn  - 6:31:20 PM] Warning: The 'strict-boolean-expressions' rule requires type information.
[Warn  - 6:31:20 PM] Warning: The 'use-default-type-parameter' rule requires type information.
[Warn  - 6:31:20 PM] Warning: The 'deprecation' rule requires type information.
[Warn  - 6:31:20 PM] Warning: The 'match-default-export-name' rule requires type information.
[Warn  - 6:31:20 PM] Warning: The 'no-boolean-literal-compare' rule requires type information.
[Warn  - 6:31:20 PM] Warning: The 'no-unnecessary-type-assertion' rule requires type information.
[Warn  - 6:31:20 PM] Warning: The 'return-undefined' rule requires type information.
[Warn  - 6:33:48 PM] vscode-tslint: Cannot read tslint configuration - 'Failed to load c:\Brutus\Kosmud\Src\tslint.json: Unexpected string in JSON at position 1515 in c:\Brutus\Kosmud\Src\tslint.json'
[done]

TODO: Upgradnout verzi typecriptu (a možná i tslintu)
[done]

TODO (Tslint) import { Cosi } from...
- pořád se mi to moc nezdá, ale asi jo, no
  (každopádně to dává smysl, je to v podsatě vytahování properties z objektů).
[done]

TODO: Prozkoumat (a ideálně použít):
  https://decembersoft.com/posts/say-goodbye-to-relative-paths-in-typescript-imports/
(nejspíš bude stačit baseurl
 - nebude, na serveru to nefunguje a je potřeba nastavit NODE_PATH)
[done]

TODO: Nastavit z-order pro Ship.gebugGraphics.
[done]

TODO: debug čáry by to asi chtělo dát do stejné grupy jako Ship
  (respektive Ship bude group a v ní bude ship_hull, debug_draw a tak),
  abych to rotoval a posouval najednou.
  - musí to být container, s grupou se nedá hejbat.
Scene.create()
{
  let group = this.add.group();
  let sprite = this.add.sprite(400, 300, 'phaser');
  
  group.add(sprite);
}
[done]

TODO: Vyrobit classu Phaser/Graphics,
  která bude umět kreslit čáry (a rovnou třeba vykreslist Geometry).
- je otázkla, jestli strokePoints() bude dělat to, co si myslím, ale
  třeba jo. Musím to vyzkoušet.
[done]

TODO: Zdědit FlightScene ze Scene a rozhodit mezi ně kód.
- DEPTH_COSI by asi měly bejt až ve FlightScene.
[done]

TODO: Steně tak asi rovnou vyrobit i FlightSceneContents
[done]


TODO: Zrušit přidávání shipy do scény při creatu scény.
[done]
TODO: Procesit ShipToScene na clientu (přidat ship do scény).
- možný problém: ShipToScene může klidně přijít před vytvořením
  scény (až se bude dýl loadovat, tak to dokonce bude celkem pravděpodobný).
[done]
Co s tím?
- buď si to nabufferovat a zpracovat to až ve chvíli, kdy bude scéna existovat.
  - tohle má výhodu v tom, že se mohou data poslat ještě v průběhu loadování.
- nebo po vytvoření scény poslat na server request.
TODO: Do Scene přidat buffer na přidávání věcí do scény.
  - dokud není scéna vytvořená, dávat ShipToScene do bufferu.
  - při vytvoření zpracovat ShipToScene z bufferu.
[done]

TODO: Na klientu nevyrábět ship rovnou, ale až když mi přijde
  packet s přidáním shipy do scény.
- player se teda asi bude na scénu přidávat rovnou při loginu
  (respektive spíš při EnterGame), ale přidávat se budou i jiný
  entity v průběhu, takže se to neztratí.
(Technicky vzato je to update scény, ale asi je lepší udělat novej typ
 packetu, než dělat komplikovaný vnitřní typy).
[done]

TODO: Mergnout SceneContents a Scene.
- to asi nebyl úplně nejlepší nápad. Teď zas musím ošetřovat každou property
  zvlášť. Mít to sdružený dohromady dávalo smysl.
Takže jinak: Nechat SceneContents, ale jen jako data container, nedávat do
  něj metody. Scéna prostě bude přistupovat přes this.contentns.camera apod.
[done]

TODO: Na serveru vyrábět a posílat paket ShipToScene
- otázka je kdy.
  - asi jako response na přihlášení klienta
    (nejspíš tam, co se bude výhledově posílat LoginRequest či co...
     - hmm, to asi nepůjde, páč komunikace po connectu začíná až tím,
       že user klikne na login button - pak se pošle LoginRequest)
     - takže asi zatím natvrdo do WebSocketServer.onNewConnection.
[done]

TODO: Je blbost posílat geometrii v každém tiku, takže:
- vyrobit packet "Přidávám playera na scénu"
  [done]
  - ShipToScene (přejmenovat to můžu vždycky)
- ten bude obsahovat:
  - geometrii.
    [done]
  - startovní pozici
    [done]
  - co vlastně přidávám
    (to zatím řešit nebudu)
[done]

TODO: Remove unecessary constructors from packet classes.
[done]

TODO: Udělat 'version' static.
[done]
TODO: Nepsat 'version' do paketů a nekontrolovat ji při deserializaci.
[done]

TODO: Možná by v Packetech přece jen nemusel bejt Vector, ale pouze
  {x, y}. Posílalo by se míň dat (a fungovat to asi bude taky)
  - otázka je, jak ten typ pojmenovat. XY? Coords?
  - a kam ho dát? Do Types? Do Packetu, protože se bude používat jen
    v packetech?
  - nebo prostě Packet.Vector...
[done]
- blbý je, že se to musí konvertit ručně, páč Vector se vleze do
  interfacu { x, y }...
Možná teda vyžadovat v constructoru packetů paramety (x: number, y: number)
  místo složeného typu (to zabrání předání a tedy assignování vectoru).
- err, to je taky naprd.
Takže jinak:
TODO: Vrátit do packetů vectory a upravit Serializační kód aby byl výsledek
  míň ukecanej.
[done]

TODO: metoda Vector.setLength();
- normalize
- scale
[done]

TODO: Použít classu Vector všude kde jsou koordináty
- místo GameEntity.Position
  [done]
- místo { x: number, y: number }
  [done]
- místo b2Vec2
[done]

TODO: Fix onBeforeUnload
- když je connection closed nebo closing, nezavírat ji.
[done]

TODO: Naučit Serializable savovat Vectory, aby Vector nemusel bejt zděděnej
  ze Serializable.
- netestováno
[done]

TODO: Vyrobit classu Vector (v Physics)
- Math ne, to by kolidovalo s javascriptovým Math.
[done]

TODO: Rozdělit PlayerInput na MouseInput a KeyboardInput
(nemusel bych dělat komplikovanej vnitřní typ).
[done]

TODO: Vymyslet, jak to udělat s typama
- určitě chci Position (nebo Vector?)
- otázka je, jestli to opravdu má bejt v GameEntity.
  Smysl to sice jakž takž dává, ale GameEntity není ničím zvláštní.
- Možná to hodit do Types?
- Nebo použít Vector (ať se s tím dá rovnou počítat?)
  - asi jo.
- Vector by asi měl bejt Serializable
[done]

TODO: Implementovat "Follow mouse position"
- posílat mouse_position na server
  [done]
- implementovat Steering.seek()
  [done]
- aplikovat steering force na ship
  [done]

Zatím mi ale stačí natvrdo jedno body pro ship, takže to prostě hacknu
  a uvidíme.
[done]

Aktuální TODO:
- umím vyrobit Box2D body (respektive PhysicsBody).
- někde vyrobit world
[done]
- v něm vyrobit body pro ship
[done]
- posílat na klienta pozici a rotaci shipy
[done]
- na klientovi to vykreslovat
  - transformovat souřadnice a rotace
    - tohle nějak záhadně není potřeba
      (nebo to možná dělám a ani o tom nevím. Asi správně zvolená znaménka
        u zatáčení na serveru).
  - setovat pozici a rotaci
[done]

TODO: Zatrhnout prohledávání TODO, DONE a CONTEMPLATION
- možná to rovnou přehodit někam do Users/Rahman
[done]

TODO: Jo a zatrhnout prohledávání Shared/Box2D
[done]


TODO: Dodělat cleanup a refactoring:
.
+Client root (KosmudClient.ts)
+Client/Class
+Client/Gui
+Client/Log
+Client/Net
Client/Phaser
+Client/Protocol
.
+Server root (KosmudServer.ts)
+Server/Class
+Server/FS
+Server/Game
+Server/Log
+Server/Net
Server/Physics
+Server/Protocol
.
+Shared/Utils
+Shared/Class
+Shared/Game
+Shared/Log
+Shared/Net
+Shared/Protocol
+Shared/Utils
.
(ve zbytku se vrtám)
[done]

TODO: Zavést classu GUI a v ní metodu init().
[done]

TODO: Opravit poslední commit.
[done]

TODO: PhaserEngine přejmenovat na DisplayEngine
  (nebo RenderEngine, nebo tak něco)
  - možná prostě Renderer?
- zatím přidán Renderer, který vlastní PhaserEngine. Časem to určitě
  budu refactorovat dál.
[done]

TODO: Zvážit, jestli v Game.start() spíš nepustit jen jeden timer
  a z něj pak volat všechno ostatní.
  (60 tiků za vteřinu je blbý číslo btw, bude se s tím špatně počítat...
   na druhou stranu je to rozumný strop fps).
- Každopádně to jsou entry-level funkce a je tam potřeba reportovat uncaught
  exceptiony [to je DONE].
[done]

TODO: Updatnout commenty v Application, Client a Server.
- všechno smazáno, takže asi done :-)
[done]

TODO: Přesunout FileUtils na Server (Client je nepotřebuje).
- mergnul jsem to do FileSystem.
[done]

TODO: Return values ve StringUtils
[done]

TODO: Rozdělit Utils na víc souborů.
- stringové fce
- souborové fce
  - ty by asi mohly jít do FS (už je tam isValidFileName()).
TODO: Zamyslet se, co se zbytkem Utils
  (mělo by to mít specifičtější pojmenování.)
- zatím to vypadá, že 'Utils' bude asi nejlepší...
- ...
[done]

TODO: Vyhodit z Utils ERROR a FATAL_ERROR (a vůbec ho celý projít).
- nahradit je exceptionama.
[done]

TODO: Asi sloučit classy Client a KosmudClient, Server a KosmudServer.
[done]

TODO: Potenciální problém - 'entities' asi budou muset bej v Application
  místo v Entities, protože se k nim musím dostat
  v Serializable.readEntityReference a v Serializable nejdou importnout
  Entities.
- Možná si metodu GetEntities() { return Entities.entities; } hodit někam
  do Utils.
(zatím to přeložit jde. Nechám si to tu, až budu zprovozňovat Entities)
TODO: Ještě jednou se zkusit obejít bez .entities v Application. Šlo
  by pak zrušit instancování klientu a serveru (dělá to Syslog, to stačí).
[done]

TODO: Rozdělit MessageType na Syslog.MessageType a zbytek.
  (mimo jiné se nebude muset všude se Syslogem importovat ještě MessageType).
- ten "zbytek" navíc zatím nejspíš nebudu potřebovat, takže prostě
  vyrobit Syslo.MessageType a MessageType zrušit.
[done]

TODO: Try-catchnout všechna volání serialize() a deserialize().
- ještě to zkontrolovat
[done]

TODO: Refactorovat Connectiony a WebSockety.
+/Shared/Net/PacketHandler.ts
+/Shared/Net/Socket.ts
+/Shared/Net/WebSocketEvent.ts
+/Server/Net/Connection.ts
+/Server/Net/Connections.ts
+/Server/Net/HttpsServer.ts
+/Server/Net/Socket.ts
+/Server/Net/WebSocketServer.ts
+/Client/Net/Connection.ts
+/Client/Net/Socket.ts
[done]

TODO: Obecněji pořešit posílání packetů do closed connection.
  (i když nejvíc to vadilo u "client closed browser tab" message,
   páč tam problikla exception těsně před zavřením tabu)
[done]

TODO: Pořešit Client/Connection.reportClosingBrowserTab()
- info je v commentu
[done]

[UNCAUGHT_EXCEPTION] Failed to send packet to websocket (/ [::ffff:195.113.180.1
95]). Reason: WebSocket is not open: readyState 2 (CLOSING) (this exception has
propagated to top-level function. It needs to be caught much deeper where the er
ror can be properly recovered from.)
    at ServerSocket.send (D:\svetlym\tmp\00\Brutus\Kosmud\Src\Server\Net\ServerS
ocket.ts:69:13)
    at Connection.send (D:\svetlym\tmp\00\Brutus\Kosmud\Src\Server\Net\Connectio
n.ts:184:17)
    at Function.broadcast (D:\svetlym\tmp\00\Brutus\Kosmud\Src\Server\Net\Connec
tions.ts:52:18)
    at Function.updateClients (D:\svetlym\tmp\00\Brutus\Kosmud\Src\Server\Game\G
ame.ts:67:19)
    at Timeout.start.setInterval [as _onTimeout] (D:\svetlym\tmp\00\Brutus\Kosmu
d\Src\Server\Game\Game.ts:37:20)
    at ontimeout (timers.js:425:11)
    at tryOnTimeout (timers.js:289:5)
    at listOnTimeout (timers.js:252:5)
    at Timer.processTimers (timers.js:212:10)
- zaprvé musím testovat, jestli je connection CLOSING
  (to nejspíš souvisí s testováním connection.isOpen()
   v Connections.broadcast)))
[done]
- zadruhé musím tyhle exceptiony někde odchytávat.
[done]

TODO: Client musí nějak ošetřit disconnect
  (aby pak neházel errory jako
   'Uncaught Error: Failed to send data to the server because the connection
    is closed')
- jsou tam alerty a exeptiony by mělo pořešit neposílání paketů do closed
  connection.
[done]

TODO: Event handlery v Keyboard jsou top-level fce, měly by asi volat
  Syslog.reportUncaughtException().
- done, ale výhledově to chce keyboard handling komplet přepsat.
[done]

TODO: Projít všechny výskyty send() a zajistit, že se testuje isOpen().
  A přidat taky exception handling. Connection.send() hází výjimky.
- v Keyboard() je to done.
[done]

TODO: send() a receiveData() by asi vůbec neměly catchovat exceptiony
  (respektive receiveData() možná jo, ta se volá interně z callbacku,
   ale send() volá někdo jinej a ten by asi měl exception dostat).
- Jasně. A onReceiveMessage() už pak reportí jen uncaught exception
  pro případ, že by ji někdo nezhandlil sám.
[done]

TODO: Pořešit rethrow v ServerSocket.send()
  (a asi i v ClientSocket)
[done]

TODO: Musí být connection.receiveData() public?
- jestli se to volá ze socketu, tak sloučením Socketu a Connection
  by callback vidě na private receiveData().
[done]

TODO: Asi bych to mohl udělat tak, že Connection zdědím z WebSocketu
- díky tomu to pořád bude separated code, ale nebudu muset řešit
  alokaci websocketu a budu mít protected přístup na receiveData().
[done]

TODO: Connections.broadcast() musí testovat, jestli jsou
  connectiony otevřené.
[done]

TODO: V ClientSocket (a nejspíš i ServerSocket) je pořád spousta ERROR()
  callů. Zkontrolovat, jestli to nemají být exceptiony.
[done]

TODO: ještě jednou mrknout na connection.send(packet), jestli by to nemělo
  bejt v PacketHandleru (musí se tomu dát serialize mode, takže asi ani
  nemůže, ale mohlo by to tam bejt aspoň abstract).
[done]

TODO: Přesunout connection instance na Clientu do Connection.
[done]

TODO: Posílání PlayerInputu prohnat fcí, která otestuje, jeslti je connection
  open.
[done]

TODO: Alerty o disconnectech (momentálně je to nejjednodušší).
[done]

TODO: Shared.Connection by se asi mělo jmenovat jinak.
[done]

TODO: Refactorovat WebSocketServer
[done]

TODO: Exceptiony ve FileSystem.
[done]

TODO: Vyzkoušet webpack
- pomalé, žere class names. Zatím nebrat
[done]

TODO: Použít Express (kvůli security)
[done]

TODO: HttpServer by se asi rovnou mohl jmenovat HttpsServer...
[done]

TODO: Refactorovat HttpServer
[done]

TODO: Zkontrolovat, že http server neservuje soubory mimo www-root.
- to zařídí express
[done]

TODO: Neservovat data, když je https server closed.
- hmm to asi nepůjde, když to teď dělá express.
- takže možná zrušit .open
(když to někdy bude potřeba, tak se to dá napsat dodatečně)
[done]

ERROR()
--------
.
Pokud nechám ERROR(), asi by se dalo použít tohle:
https://www.bennadel.com/blog/2828-creating-custom-error-objects-in-node-js-with-error-capturestacktrace.htm
.
  In the V8 engine, the stacktrace of an error is gathered using the
  Error.captureStackTrace() method:
  .
    Error.captureStackTrace( errorObject, localContextFunction )
  .
  This method injects a "stack" property into the first argument and,
  optionally, excludes the localContextFunction from the stacktrace.
  So, for example, if we were to generate the stacktrace inside of an
  error Factory function, we could tell V8 to exclude the factory function
  when generating the stack. This would reduce the noise of the error
  implementation and confine the stacktrace to meaningful information
  about the error context.
[done]

TODO: Otestovat reportování errorů.
[done]

TODO: Vyzkoušet ERROR() a REPORT() i na klientu.
[done]

TODO: Někde v kódu mám RERORT(new Error("test"));
- už snad ne
[done]

TODO: Reportování errorů a exceptionů je pořád divný.
- snad fixed
[done]

TODO: Odstranit testovací kód na ERROR() a REPORT() ze serveru a z klienta.
[done]

TODO: Když se stejně nakonec na zobrazení errorů volá Syslog,
  nebylo by lepší udělat polymorfní jen ten, místo Application?
  - respektive neprovolávat ty reporting funkce přes Application.
    (Tam to moc nepatří).
  - application je zatím taky singleton, možná to bude potřeba
[done]

TODO: Asi jsem rozbil tikání physics enginu a posílání updatů.
- to bylo nejspíš tím, že mi utekla uncaught exception. Client
  se tím zřejmě taky zastaví.
[done]

TODO: Updatnout commenty v ERROR (a vůbec v celém reportovacím kódu).
[done]

TODO: Z Utils oddělit ještě FileUtils.
[done]

TODO: FATAL_ERROR() by neměl bejt v Shared kódu (na klientu nedává smysl).
  A možná by šel vyhodit úplně.
- zrušen kompletně
[done]

TODO: Extra házení EXCEPTION_CAUGHT možná není úplně dobrý, protože tam
  není uvedeno, jaká exception byla chycena. Asi by to fakt měl bejt jeden
  message.
[done]

TODO: Mrknout ještě na REPORT() a logování catch message.
[done]

TODO: Testnout additional message u RERPORT().
[done]

TODO: Funkce ze StringUtils by se měly volat jak StringUtils.něco
  (ať je jasný, že to je z externího modulu).
[done]

TODO: Otestovat, jestli getTrimmedStackTrace() správně trimuje stack trace.
- otestováno při hození erroru.
- Klient to nepoužívá, hází místo toho exception.
[done]

TODO: Zvážit, jestli úplně nezrušit ERROR a nenechat jen syslog.
- Nakonec ne, viz třeba ClientSocket. Entry point funkce rovnou reportují,
  nemá smysl, aby házely exception.
[done]

TODO: Nahradit fs-promise něčím jiným
  npm WARN deprecated fs-promise@2.0.3: Use mz or fs-extra^3.0 with Promise Support
[done]

TODO: Everything is brutally slow now. Need to investigate what has happened.
  (fs-extra probably causes this).
- never mind, it works fine.
[done]

TODO: Serializable by nemělo nic vědět o entitách.
  - Entity by si měly přetížit metodu na serializaci/deserializaci properties.
- Nakonec jsem deserializování referencí na entity nechal v Serializable,
  aby šly házet reference na entity do non-entity class (a serializovat je
  jako reference).
[won't do]

Ok, seriózní TODO: Zprovoznit pohyb lodě tak, že na serveru to bude physics
  body v matter.js a na klienta se bude posílat aktuální pozice a rotace.
- importnout na serveru Matter.js
  [done]
- vytvořit testovací body pro ship
  [done]
- nasimulovat wsad (speed, rotation, position).
  (Zatím nic moc, ale tohle teď skipnu, s tím si bude lepší hrát s vizuální
   odezvou.)
- ukrást websockety z BrutusNext
[done]
- ukrást Serializable z BrutusNext
[done]
- posílat pozici a rotaci a zobrazovat to na klientu.
[done]
- posílat keyboard eventy (nejspíš už přeložené na herní akce?)
[done]

TODO: Velocity vector se musí updatovat spolu s rotací lodě.
- pamatovat si velocity (scalar value) starnou a velocity vector
  z ní počítat každej update().
[done]

TODO: Hodit funkce na práci s typy z Utils do Types.
[done]

TODO: Uklidit v Serializable public, protected atd.
[done]

TODO: Updatnout úvodní pokec v Serializable.
[done]

TODO: Vrátit se k jednoduchému modelu shared-only a data-only packetů
  a processPacket() udělat jako externí kód se switchem na className packetu.
- Zrušit Server/Protocol a Client/Protocol
- Zrušit IncomingPacket a OutgoingPacket.
- Classy XXXData přejmenovat na XXX.
- napsat processPacket() na serveru.
- napsat processPacket() na klientu.
[abandoned, reverted]

TODO: Vyhodit z gitu zkompilovaný kód.
[done]

TODO: Přejmenovat adresáře Client/js, Server/js, atd. (na CamelCase)
[done]

TODO: Objekty ve scéně by měly být v classe, která se celá
  nainstancuje ve Scene.create(), ať nemusím testovat, jestli to existuje.
  - problém je, že některé věci se vyrábí v preloadu...
    Preload s konkrétními sprity nesouvisí - z jedné textury se dá vyrobit
    milión lodí. 
[done]