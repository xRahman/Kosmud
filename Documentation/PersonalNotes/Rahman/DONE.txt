TODO: Dát návrh na rozvoj tile animation pluginu.
[done]

TODO: SceneUpdate by asi mělo parametry dostávat trochu víc strukturovaně
 (konstruktor s 20 parametry už je trochu přes míru...)
- sort of done
[done]


TODO: načíst výstup z Tiled editoru.
- na serveru do fyziky, na klientu do grafiky
Body zkusím editovat rovnou u tilesy (pokud to bude fungovat pro object layer).
https://medium.com/@michaelwesthadley/modular-game-worlds-in-phaser-3-tilemaps-1-958fc7e6bbd6
[done]

TODO: Tilemap by pak mohla ještě vytvářet StaticLayery a DynamicLayery.
- asi to můžu připravit, tj. classy StaticLayer a DynamicLayer zděděné klasicky
  z PhaserObjectu.
StaticTilemapLayer a DynamicTilemapLayer možná nebudou moci bejt PhaserObjecty,
protože jejich phaser varianty nejsou zděděné z GameObjectu.
- možná jim dát jiného předka? (TilemapLayer)?
- nebo možná zdědit DynamicTilemapLayer ze StaticTilemapLayer.
Zjevně to funguje, i když to v Phaseru zděděné není.
- Připravené to je, zatím to nechám být.
[done]

TODO: Asi bych měl udělat shared předka classy Tilemap,
  kterého různě implementuje klient a server. Časem budu chtít počítat
  fyziku i na klientu a asi budu chtít vyrábět zóny stejnejma metodama,
  tak ať to na to je připravený.
[done]

TODO: Ship.getShape() by si asi mohlo výsledek pamatovat, ať se pokaždý
 nevolá tilemap.getShape().
- na druhou stranu volá se to asi jen jednou (rovnou se z toho vytvoří
  physics body), takž je to asi ok.
[won't do]

TODO: Načíst physics shape lodi.
  OK, jak budu vyrábět ship?
  - primárně každopádně na serveru.
    - loadne se entita. Ta má příslušnej typ (prototyp), tzn.
      má nasetovaný properties, jako třeba jakou má použít tilemapu.
    - na server se pošle info o tom, z čeho se má pro loď vytvořit grafika
      (hmm, to zavání posláním prototypu, abych ty datový struktury
       nemusel deklarovat dvakrát)
       - Momentálně to každopádně můžu na klientu a na serveru vytvořit
         paralelně.
   Ship na serveru (nebo možná i v Shared) by každopádně měla mít
     info o tom, jakou tilemapu má použít. Prozatím to může bejt
     přiřazený natvrdo, nemusí se to loadovat z disku
     (to mi ostatně ušetří posílání prototypu na klienta - když
      to bude natvrdo v shared kódu, tak na to klient uvidí automaticky).
Async constructor asi nepůjde - to znamená, že:
- buď musím nejdřív loadnout tilemapu a až pak udělat new Ship
- nebo new Ship a pak await ship.load().
Ship tak jako tak nebude existovat od začátku, takže by asi dávalo větší
  smysl, aby měla všechny properties inicializované v konstruktoru.
- to znamená udělat nějakej preload.
[done]

TODO: Vehicly (a obecně herní objekty) by asi měly mít nastavenou hmotnost
  spíš než hustotu (hustota by se měla dopočítat).
  - na druhou stranu když pak zvětším loď na dvojnásobek, tak bude
    mít absurdní hustotu (zůstane jí hmotnost...)
[kašlat na to, hustota je ok]

TODO: Vůbec se mi nelíbí přetypování tilemapy. Mělo by se to loadovat
  jako Serializable, aby se kontrolovalo, že tam jsou patřičné properties.
- Ono to je nakonec asi ok. Když budou data jinak, tak to tak jako tak hodí
  exception. Sice nebude moc dobře popsaná a vysvětlená, ale zas mít kód
  plnej ošetřování možnáho 'undefined' by bylo taky dost naprd.
[it's ok]

TODO: Procházení dat tilemapy je dost šílený - asi to bude chtít
  udělat tak, že to projdu jen jednou a při tom vytahám všechna potřebná
  data.
- ideálně by se to mělo offline přechroustat do formátu, kterej se nemusí
  traverzovat (všechno rovnou zaindexovat), ale na to teď není prostor.
  - při tom by se daly rovnou rozřezávat nekonvexní polygony.
[done]

TODO: Přiřadit Ship shape do body
  (místo stávajícího hacku na obdélníkové body).
- Skoro!
TODO: Pořešit, proč jsou všechny polygony přes sebe.
[done]

TODO: Přesunout interface Tilemap.Data do Shared/Tilemap.
[done]

TODO: Nakonec pořádně projít a pročistit ShipGraphics, tam jsem hodně
  hackoval.
[done]

TODO:
- pojmenvávat důsledně layery ("_layer"), tilesety ("_tileset").
  (tohle asi stačí pro názvy konstant v kódu - v editoru to může
   bejt bez přípony, tam to je přehlednější).
- bez podtržítek, ale done.
[done]

TODO: Konzistentně dávat do klíčů, názvů layerů a podobně příponu, co to je.
  tzn: "thrusters_layer", "exhaust_animation"
- bez podtržítek, ale done.
[done]

TODO: Zamyslet se nad konvencí stringových jmen a idček
  (mohou tam být mezery - mělo by se to normálně číst. Otázka je, jestli
   Všechna Písmena Velká nebo jak (to moc jako normální čtení nezní)...)
[done]

TODO: .tmx formát tilemap asi vůbec není potřeba - Tiled editor by měl
  umět načítat rovnou JSON.
- cesty k texturám jsou relativní, takže záleží na tom, kde je soubor
  savnutej. Jinak je ten save stejne jako export.
  - tzn. asi budu editovat rovnou z /Client. Aspoň nebudu muset nic
    exportovat.
TODO: Tzn /RawData/TileMaps kompletně zrušit.
[done]

TODO: Zprovoznit debugování
  (abych mohl debugnout thruster backlash při dobržďování).
- ono to kupodivu v server kódu funuje.
[done]

TODO: Doma si pročistit font cache GIMPu, ať nestartuje 100 let.
[done]

TODO: Když vyrábím sprity z object layeru, tak se jim nenastavuje
  base scale.
- pokud to nebude fungovat samo, tak musím baseScale spočítat
  jako poměr stávající velikosti a velikosti v textuře.
[done]

TODO: Nějak budu muset pořešit preload tilemapy
- možná zdědit FlightSceneTilemap z TileMap?
  nebo udělat FlightSceneTilemaps jako container TileMap
  (protože zatím je sice jen jedna, ale bude jich určitě víc).
Hmm, FlightSceneTilemaps asi nebyl dobrej nápad, to asi může dělat
  rovnou ShipGraphics. Tilemapy nesouvisející s lodí budu beztak
  chtít dát někam samostatně.
[done]

TODO: Udělat ve Sprite víc konstruktorů
  (možnost předat rovnou vyrobenou spritu, nejspíš bez animace).
- udělal jsem to přes union type, ale asi done.
[done]

TODO: Výroba spritů z tilemap object layeru.
  - asi statická metoda Sprity? Ee, Tilemapy.
    Nebo možná udělat classu na tilemapu, která tohle bude dělat
    (to je lepší).
  - vrátí Array<Sprite>
  - jako parametr bere pole jmen objektů v layeru.
  - rovnou posune sprity aby byl origin uprostřed
  - rovnou na ně přiřadí a pustí texturovou animaci
    (to by měl zvládnout konstruktor spritu).
[done]

TODO: Rozdělit Sprite.baseScale na  Sprite.baseScaleX a Sprite.baseScaleY
- nastavovat to při vyrábění spritů v Tilemap.createSprites.
[done]

TODO: Ještě líp by se baseScale mělo zapamatovávat až v konstruktoru Spritu,
  když dostane jako parametry Sprite místo configu.
  - a ostatně baseScale by mělo být jen ve Sprite.Config, ne ve Sprite.Options.
[done]

TODO: Opravit pozice a scalování exhaustů.
Ha, phaserSprite.originX a phaserSprite.originY jsou ratia,
  ne absolutní hodnoty!
[done]

TODO: Že bych vůbec texturovou animaci nevyráběl automaticky při vytváření
  spritu, ale vždycky mimo?
  - pak bych mohl do konstruktoru spritu předat prostě jen jméno animace.
TODO: Má být createAnimation statická metoda Sprity?
- kde jinde by měla bejt?
  Je to přece jen sprite animation (tilové animace se zatím dělají jinak),
  takže to asi dává smysl.
[je to ok]

Ok, TODO: Vyrobit celou loď úplně znova.
- vymyslet lepší název než "rogue"
  - missile_ship, railgun_ship,
  + fighter, bomber, support, assault (zatím takhle)
  [done]
- zmenšit loď na půlku.
  [done]
- v Tiled editoru ji dát do object layeru
  [done]
  - ve hře z ní pak udělat spritu
- vyrobit texturu s exhausty v TexturePackeru
  + vyexportovat texture atlas
  [done]
- naimportovat ji do Tiled editoru, vyrobit z ní tilesy
  [done]

TODO: Hmm, textura pro lodě (a nejspíš i exhausty) by zřejmě neměla
  být jen jedna a ne pro každou loď zvlášť.
  - a tile-size by zřejmě měla bejt něco malýho (tzn. že loď bude přes více
    tilů). To možná dost zkomplikuje editaci shapu (u lodí ho asi nechci mít
    složený z X tilů, nebo jo?)
- asi se na to vykašlu a nechám 1 ship per tile (ovšem i tak jich můžu dát
  na texturu víc).
[zatím nechám 1 tile per ship]

TODO: Rozhodnout defaultní orientaci spritů.
  Asi by to mělo bejt tak, že nulová 'rotation' odpovídá defaultní
  pozici, takže orientace "doprava" je dobře.
  (to bude mít i fajn side effect, že to bude texture packer nativně
   skládat správně. Zas to ale možná bude divně v Tiled editoru... Co už).
   Budiž to "doprava"
[done]
- a pak ji všude dodržovat (u lodi, u exhaustů)...
TODO: Předělat exhausty "doprava" místo "dolů)
[done]

TODO: Pročistit data.
[done]
TODO: Vyrobit znova data pro ship_fighter
- jen object layery
[done]

TODO: vyzkoušet https://github.com/nkholski/phaser-animated-tiles
- nefunguje kvůli bugu, viz:
  https://github.com/nkholski/phaser-animated-tiles/issues/2
- a je otázka, jestli vůbec funguje na sprity vytvořené z object layeru
  (spíš asi ne).
TODO: Každopádně vyzkoušet sprite animaci aspoň na tiles layeru.
[done]
- a možná bych si pak ten converter mohl napsat...
Plugin teď asi vůbec nebudu potřebovat
[na to zatím kašlu]

TODO: Exhausts možná přejmenovat na Thrusters?
- každopádně se pro něco rozhodnout a používat to všude (včetně tilemapy lodi).
Nechám exhausts
[done]

IDEA: Nejjednodušší asi bude, vyrobit tu animaci znova v texture packeru
  s tím, že sprity nechám poskládat jednu vedle druhý, tzn. tu textutu
  budu moct beze změny využít jako tileset v Tiled editoru.
- a můžu zkusit requestnout tile animaci spritů vyrobených z object layerů
  v tile animation pluginu...
- vyzkoušeno, udělám to tak.
[done]

TODO: Vytáhnout info o animaci z tilemapy,
  vyrobit tuhle animaci ručně a přidělit ji na exhaust spritu vytvořenou
  z object layeru v tilemapě.
- vůbec nejdřív tu animaci prostě vytvořit ručně (ať mám představu).
[na tohle zatím kašlat]

IDEA: Ještě bych možná mohl zkusit, že místo vyrábění spritů z object layeru
  vyrobím nové tilesy do tile layeru.
- Hmm, vlastně bych ty thrustery rovnou mohl udělat jako static layer,
  teda až na to, že pak nepůjde scalovat velikost...
Problém trochu je, že tilesy jsou velikostí nastavené na loď a všechny
layery zjevně musej mít tilesy stejné.
  Takže asi leda udělat v mapě lodě základní tilesy podle animace exhaustů
  (loď holt bude přes víc tilesů) - to je dost pitomý, protože to pak
  bude fungovat jen na tuhle konkrétní animaci.
[na tohle kašlat]

TODO: Než se pustím do refactoringu kódu a dat tile animací, tak přece jen
  ještě vyzkoušet texture atlas animaci na exhaust.
[done]

TODO:
  Uncaught Error: Failed to resize scene 'Flight scene' because scene contents doesn't exist
    at FlightScene.resize (FlightScene.ts:113)
    at Object.resize (Renderer.ts:27)
    at CanvasDiv.onResize (CanvasDiv.ts:72)
    at CanvasDiv.window.addEventListener (CanvasDiv.ts:52)
- dlouho se loadovalo (v browseru) a do toho jsem otevřel konzoli v Chromu,
  takže došlo k resize okna. Nejspíš ještě scéna nebyla vytvořena.
- asi prostě jen neházet error - když scéna nemá contents,
  tak není co resizovat.
[done]

TODO: Nastavovat scale a visibility exhaustů podle thrustu/torque.
[done, sort of]

TODO: přidat baseVolume do Sound.
[done]

TODO: Nastavovat zvukům thrusterů volume podle thrustu.
[done]


TODO:
- Posílat na klienta thrusty a torque
  [done]
- Scalovat je a zapínat/vypínat podle thrustů a torque
[done]

TODO: Přidat classu ShipSound
[done]

TODO: Zjevně potřebuju classu Sound.
[done]

TODO: Exhausts by asi mohly být v samostatné classe.
- sprity ale pořád musej přidávat do ShipGraphics, tedy do containeru.
  - čili class ShipExhausts by měla mít taky referenci na ShipGraphics?
[done]

TODO: Udělat strafing thrustery mnohem menší.
[done]

TODO: Přidat do spritu baseScale, který se bude přinásobovat při setScale().
[done]

TODO: Natáčel loď bych měl směrem k desiredSteeringForce, nikoliv směrem
  k desiredVelocity.
  Tím se bude trochu "přetáčet".
  - tohle můžu dělat jen při seeku. Jakmile začnu brzdit, tak se tímhle
    točím do protisměru - tzn. je potřeba točit k -desiredSteeringForce.
[done]

TODO: Proč mám na začátku loď otočenou o 180°?
- asi se bere, že je ve fázi brždění, takže se aplikuje rotationFlip...
- vrátil jsem tam zpět zákaz točení při malé vzdálenosti, to to prozatím
  pořešilo
[done]

TODO: Přejmenovat adresáře v /Client (na PascalCase).
- Huh, v práci začíná všechno velkým.
- v práci je to každopádně dobře, ještě to checknout doma.
[done]

TODO: posílat aktuální thrusty
  (asi stačí číslama, není nutný posílat vektory).
- implementovat getForwardThrustRatio(),
  getLeftwardThrustRatio(),
  getTorqueRatio()
[done]

TODO: Arrive
- ještě správně počítat breaking distance.
TODO: Breaking distance se nepočítá spávně.
TODO: Asi budu ji budu muset posílat na klient a zobrazovat.
(jakž takž)
[done]

IDEA: Určit na tvrdo nějakou malou vzdálenost (10 třeba).
- před ní bude desired speed dejme tomu 10% aktuální.
- za ní bude gradual slowdown.
Skoro!
- ještě asi přidat, že když jsem fakt blízko cíli, tak se nebudu točit jak
  čamrda.
Bude to chtít hódně refactoringu, ale snad to funguje.
[done]

TODO: Jak pojmenovávat texture atlasy?
- mám několik efektů v jenom atlasu
- Adresář v TexturePackeru by se asi měl jmenovat stejně jako výsledný atlas
  (tj. Exhausts00).
  - což je vlastně vstupní adresář.
- Zjevně potřebuju nějakej adresář na "raw data". Možná SrcData?
  - raději RawData, ať se to nebije se /Src
- Kam patří tps file? (Texture packer project?)
  - Taky do RawData. Možná přímo do Textures - vždycky tam, kde je adresář,
    ze kterého je atlas udělanej.
  Tzn.:
  /RawData/Textures/Effects/Exhausts/Exhausts00.tps
  /RawData/Textures/Effects/Exhausts/Exhausts00/ExhaustBlueConical
  /RawData/Textures/Effects/Exhausts/Exhausts00/ExhaustYellowConical
  /RawData/Textures/Effects/Exhausts/Exhausts00/ExhaustYellowRectangular
.
- i kdyz to mozna není uplně chytrý, protože bych mohl chtít dělat
  atlasy napříč logickým rozdělením. Tzn. ne vsechny exhausty, ale
  spis vsechny textury k jedne lokaci/scene.
  - tzn. atlasy by mely mit nezavislou strukturu:
.
  - Spíš TexturePacks (atlas je to až vyexportované).
.
  /RawData/TexturePacks/Effects/Exhausts/Exhausts00.tps
.
  A textury taky:
.
  /RawData/Textures/Effects/Exhausts/ExhaustBlueConical
  /RawData/Textures/Effects/Exhausts/ExhaustYellowConical
  /RawData/Textures/Effects/Exhausts/ExhaustYellowRectangular
.
Možná zrušit Graphics a nahradit to rovnou podadresářema (Textures, atp?)
- asi nemusím rozlišovat texture atlasy a jiné textury
  (atlas má prostě u sebe ještě json)
.
/Client/Textures/Background
/Client/Textures/Effects/Exhausts
/Client/Textures/Markers
/Client/Textures/Ships
.
To samé v RawData (tj. /Textures/...)
[done]

TODO: Vymyslet lepší adresářovou strukturu pro TexturePacker
- output určitě rovnou do /Client, ať to nemusím překopírovávat
  a nemám to dvakrát.
[done]

TODO: Dát lodi všechny exhausty (a na správná místa)
- 2 velké dozadu
- 2 malé dopředu
- 2 doleva
- 2 doprava
[done]

TODO: Zdědit Ship ze Steering (tedy z Vehicle),
  ať nemusím do steeringových funkcí předávat takový stohy parametrů.
[done]

TODO: Fixnout errory v konzoli na klientu
  "Texture.frame missing: 1"
  "Invalid Animation Key, or Key already in use: animation_exhausts_00"
[done]

TODO: "Skákající animace": Možná je to buglé:
  https://github.com/photonstorm/phaser/issues/3288
- tak je to tím, že je v texture packeru povolená rotation
  Nenašel jsem na to vypínátko, ale pomohlo přepnout Algorithm na "basic".
[done]

TODO: To přetáčení budu muset přece jen ještě nějak stabilizovat...
[done]

TODO: Ehm, ona ta původní varianta se skládáním desiredSteeringForce
  z forward a leftward složky byla asi dobře - jsou to přece jen dva
  oddělené propulsion systémy, takže ve spolupráci opravdu dokáží
  poskládat sílu v obdélníku.
  - zase to zapnout a vyzkoušet (možná bude loď míň "plavat").
Tak ne - je to sice asi technicky správně, ale loď pak "plave" mnohem víc.
Revertuju zpět na novější verzi.
[done]

TODO: Vyzkoušet přece jen rotaci přes torque...
- Funguje!
[done]

TODO: "Dobržďování" při rotaci by možná šlo zrychlit tím, že
  nebudu angular velocity limitovat hned, ale až když bude zbývat jen
  část mojí ANGULAR_VELOCITY (třeba desetina).
[done]
TODO: a možná bych mohl udělati "zrychlování" rotace, tj. aby to z 0 na full
  neskočilo okamžitě.
- tohle jsem vyřešil přes torque
[done]

TODO: Pořád je tam problém s výpočtem směru rotace, to musím opravit.
[done]

TODO: Opravit šílené zrychlování do boku.
  Zjevně mám chybu v úvaze.
  - Když totiž limituju složky zvlášť, tak se mi změní směr vektoru.
  Tzn. musím:
  - Zjistit, jakým faktorem se limituje v jednotlivých směrech.
  - Menším z těch faktorům pronásobit původní vektor.
[done]

TODO: Zvážit, jestli je rozumný tahat ship position z grafiky (spíš není).
- tzn. pamatovat si ji v Ship.
[done]

TODO: Přejmenovat GeometryGraphics na něco rozumnějšího (ShapeGraphics)
[done]
TODO: A taky oddělit data od renderování.
[done]

TODO:
S vektory v lodi by to mělo bejt tak, že data jsou zvlášť (v Ship)
  a příslušný Graphics oject (tedy renderování) by měl bejt v ShipGraphics
  (to, že se renderuje nezávisle na containeru, na věci nic nemění. Je to
   prostě součást grafiky).
  Při renderování by se měly vektory předat do ShipGraphics jako parametr.
A ShipGraphics tudíž může bejt ve Scene (respektive FlightScene).
[done]

TODO: DestinationMarker by se možná mohl jmenovat Waypoint
  (waypointů může ostatně jít zadat i víc, pak by se to obzvlášť hodilo)
- Server/Ship.seekPosition() by se mohla jmenovat setWaypoint().
[done]

TODO: Všude přejmenovat Geometry na Shape.
[done]

TODO: Výhledově v Client/Phaser nechat jen wrappery Phaser objektů.
  Zbytek hodit do jiného adresáře
  (Engine? Potom ale PhaserEngine bude jinde...).
  Navíc je Ship záležitost enginu nebo hry?
    (ono na klientu asi hra moc smysl nedává tak jako tak).
  I když... Na serveru je Ship taky v Game, takže by to aspoň bylo
  konzistentní.
.
Phaser
  Camera
  Container
  Scene
  SceneContents (Sice to není wrapper Phaser objectu, ale patří to do Scene,
    což wrapper je.)
  Graphics
  Keyboard
  Mouse
  phaser.d.ts
  Renderer (do kterého je mergnutý PhaserEngine) [done]
  PhaserObject
  Sprite
Game
  Ship
FlightScene
  Background
  DestinationMarker (Waypoint)
  FlightScene
  FlightSceneContents
  GeometryGraphics (tohle by se mělo jmenovat jinak. PhysicsShape?
    a stejně jako u ShipVectors - renderování by mělo bejt v ShipGraphics, ale
    data by se měla držet v Ship (a předávat do ShipGraphics jako parametr)).
  ShipGraphics? (to asi spíš do Scene než do Game)
  ShipVectors?
    (jako renderuje to, ale taky je to drží informace o lodi.
    Takže možná spíš Game? Na druhou stranu by to asi mělo bejt obecnější,
    vektory maj obecně všechny pohybující se objekty (tzn. Vehicles)
[done]

TODO: Přejmenovat SetDestination na SetWaypoint.
[done]

TODO: Sloučit PhaserEngine do Rendereru.
  Renderer (to už vůbec nevím kam. Scéna? Nerenderuje jen scénu...
    možná sloučit Renderer a PhaserEngine - to zní rozumně (asi pod Renderer)
- Renderer.getPhaserEngine() nemusí bejt public
  (může se to jmenovat getInstance).
[done]

TODO: Vyřešit problém s odečítáním úhlů a cyklením po 2*PI.
[done]

TODO: Když jsou vektory mimo kontejner lodi, musí mí jinak z-order.
[done]

TODO: Rotaci lodě říkat 'rotation', ne 'angle'
[done]

TODO: Možná ještě přece jen PhaserObject zdědit (nejspíš z CoordsTransform)
  a přesunout tam metody na transformaci koordinátů.
  (transformVector(), transformPolygon(), transformAngle()).
  - obojí musí být tam i zpět (takže by ty metody asi měly bejt pojmenovaný
    podle toho, z čeho do čeho transformují).
    angleFromPhaserToBox2d()
    angleFromBox2dToPhaser()
    vectorFromPhaserToBox2d()
    vectorFromBox2dToPhaser()
    polygonFromPhaserToBox2d()
    polygonFromBox2dToPhaser()
    - nakonec stačí jedna sada funkcí, protože fungují oběma směry.
  - možná by nemuselo bejt potřeba zvlášť setX() a setY().
[done]

TODO: Vymyslet, kam dát funkce lowerBound(), upperBound() a intervalBound()
  (momentálně jsou ve Steering).
[done]
TODO: Ještě jednou zvážit rozdělení Utils (a možná přejmenování).
  - /Utils/StringUtils by mohlo být prostě Utils/String.
  - applyDefaults() by mohlo být v Utils/Object
  - reportMissingCase() těžko říct kam, možná do Syslogu?
    (sice to nic neloguje, aspoň ne přímo, ale asi proč ne).
  - lowerBound, upperBound a podobně buď do Utils/Math nebo Utils/Number.
[done]

TODO: Graphics by potřebovala oddělit kód kterej pracuje s Box2d koordinátama
 a kód na transformaci koordinátů.
 (částečně to je, DrawLine a DrawPolygon jsou ty transformační metody.
  Možná je hodit do předka?)
[done]

TODO:
  Tohle by chtělo udělat nějak líp:
    this.container.add(this.geometryGraphics.getGraphics());
  (možná zdědit ShipGraphics z Graphics?)
[done]

TODO: Phaser.GameObject wrappery přece jen z něčeho zdědit.
- transformace zajistí interní setX, setY a setAngle v předkovi.
- spousta metod je stejná, chce to nějak podědit.
[done]

TODO: seek() se pořád místy chová divně
- jen při couvání směrem trochu šikmo na levou trysku...
- problém byl v tom, že se odečítaly úhly v různých intervalech
  (což pak při ořezání na menší interval občas dělalo psí kusy)
[done]

TODO: Opravit background.
[done]

TODO: Pořešit transformaci koordinátů mezi serverem a klientem
- flip y axis
- flip all angles.
TODO: Ještě v Graphics.
[done]

TODO: Vektory nakonec nesmí být v kontejneru s grafikou lodi
  (netočí se, jsou absolutní).
  - jo, ale musej se translatovat na pozici lodi.
[done]

TODO: Fce jako setDesiredVelocity() v Client/Ship by asi neměly překreslovat
  debug grafiku rovnou, ale pouze queueovat requst na překreslení
  (ať se to zbytečně nepřekresluje víckrát v jednom tiku).
[done]

TODO: DebugGraphics by mohla být samostatná class.
- nakonec jen ShipVectors (ať je to single responsibility class).
  (debugGeometry je přímo Graphics, na to není třeba extra classa)
[done]

TODO: Debugové zobrazení fyziky na klientu
  - physics body (obrys)
    [done]
  - target position
    - k tomu budu potřebovat měnit pozici pouze při button_down
    [done]
  - desired velocity
    - k tomu ji budu muset posílat v rámci SceneUpdate
    [done]
  - steering force
    (a to před limitem i po limitu ať vidím, jak moc se mi to ořezává)
    - po limitu done.
  TODO: Ještě před limitem.
[done]

TODO: Destination marker by se výhledově asi měl renderovat v nějaké UI scéně
(aby nescaloval se zoomováním - i když, možná to bude ok...).
- zoomování vypadá ok.
[won't do]
TODO: Dát mu Z-order (menší než DEBUG ale větší než DEFAULT).
- správně by to mělo bejt:
  Překážky ve scéně
  - Waypointy
    - Ship
      - debug graphics
[done]
TODO: Dát lodi Z_ORDER_SHIPS
[done]
IMPORTANT: depth je potřeba nastavit kontejneru (v Ship). Celej obsah
  containeru má zřejmě jeho depth (+ uvnitř to ještě může bejt jinak).
[done]

TODO: Destination market by měl zmizet, když na cílové místo dorazím.
- to je asi zbytečný, loď ho prostě překreje.
[won't do]

TODO: Zvážit, jestli místo matter.js nepoužít radši Box2d
- zváženo a použito
[done]

TODO: Seekovat k destination markeru, ne k pozici myši.
- to asi znamená, posílat něco jinýho než MouseInput.
TODO: Vyrobit a posílat paket SetDestination
TODO: Zpracovávat SetDestination na serveru (místo MouseInputu).
[done]

TODO: Destination marker má zůstat viditelný i po releasu buttonu
[done]

TODO: Opravit detektování mouse-down.
- je to chyba v Phaseru
[done]

TODO: Smazat ./vscode/Build, až ho nebudu potřebovat.
[done]

TODO: Updatovat verzi tasks.json (budu to muset celý předělat...)
[done]

TODO: Vyhodit tslint option "no-unused-variables" a nahradit ji typescriptovou.
[done]

TODO: Vyzkoušet ještě lint options co chtějí type info.
- nepovedlo se mi rozběhat.
[done]

TODO: Zkusit pouštět tslint před tsc (sice v tslintu píšou,
  že se má pouštět až na zkompilovaný kód, ale třeba to není
  nutný).
  - pokud to bude ok, tak smazat příslušné commenty v tasks.json.
[done]

TODO: Přidat do build tasku mazání starého buildu.
[done]

TODO: Možná do build tasku hodit i lint celého kódu
  (ideálně s type information), ať se při rebuildu
  checkne všechno.
- pokud to rozběhnu, budu potřebovat -e na ignorování Box2d.
[done]

for those who use vscode with tslint as editor/lintinig you can add the
following to the vscode config:
// Configure glob patterns of file paths to exclude from linting
"tslint.exclude": "**/PATH_eg_TESTS/**/*.ts"
- musím opravit liter errory, abych zjistil, jestli to pak pustí tsc
  ve watch módu
[done]

TODO: Zvážit použití
  https://marketplace.visualstudio.com/items?itemName=eg2.ts-tslint
  (kvůlivá kontrolám, které vyžadují type information)
- nepovedlo se mi rozběhat
[done]

Warning: member-ordering - Bad member kind: public-before-private
Warning: The 'prefer-readonly' rule requires type information.
Warning: The 'promise-function-async' rule requires type information.
Warning: The 'await-promise' rule requires type information.
Warning: The 'no-floating-promises' rule requires type information.
Warning: The 'no-for-in-array' rule requires type information.
Warning: The 'no-inferred-empty-object-type' rule requires type information.
Warning: The 'no-unsafe-any' rule requires type information.
Warning: The 'restrict-plus-operands' rule requires type information.
Warning: The 'strict-boolean-expressions' rule requires type information.
Warning: The 'use-default-type-parameter' rule requires type information.
Warning: The 'deprecation' rule requires type information.
Warning: The 'match-default-export-name' rule requires type information.
Warning: The 'no-boolean-literal-compare' rule requires type information.
Warning: The 'no-unnecessary-type-assertion' rule requires type information.
Warning: The 'return-undefined' rule requires type information.
[Warn  - 6:31:20 PM] Warning: member-ordering - Bad member kind: public-before-private
[Warn  - 6:31:20 PM] Warning: The 'prefer-readonly' rule requires type information.
[Warn  - 6:31:20 PM] Warning: The 'promise-function-async' rule requires type information.
[Warn  - 6:31:20 PM] Warning: The 'await-promise' rule requires type information.
[Warn  - 6:31:20 PM] Warning: The 'no-floating-promises' rule requires type information.
[Warn  - 6:31:20 PM] Warning: The 'no-for-in-array' rule requires type information.
[Warn  - 6:31:20 PM] Warning: The 'no-inferred-empty-object-type' rule requires type information.
[Warn  - 6:31:20 PM] Warning: The 'no-unsafe-any' rule requires type information.
[Warn  - 6:31:20 PM] Warning: The 'restrict-plus-operands' rule requires type information.
[Warn  - 6:31:20 PM] Warning: The 'strict-boolean-expressions' rule requires type information.
[Warn  - 6:31:20 PM] Warning: The 'use-default-type-parameter' rule requires type information.
[Warn  - 6:31:20 PM] Warning: The 'deprecation' rule requires type information.
[Warn  - 6:31:20 PM] Warning: The 'match-default-export-name' rule requires type information.
[Warn  - 6:31:20 PM] Warning: The 'no-boolean-literal-compare' rule requires type information.
[Warn  - 6:31:20 PM] Warning: The 'no-unnecessary-type-assertion' rule requires type information.
[Warn  - 6:31:20 PM] Warning: The 'return-undefined' rule requires type information.
[Warn  - 6:33:48 PM] vscode-tslint: Cannot read tslint configuration - 'Failed to load c:\Brutus\Kosmud\Src\tslint.json: Unexpected string in JSON at position 1515 in c:\Brutus\Kosmud\Src\tslint.json'
[done]

TODO: Upgradnout verzi typecriptu (a možná i tslintu)
[done]

TODO (Tslint) import { Cosi } from...
- pořád se mi to moc nezdá, ale asi jo, no
  (každopádně to dává smysl, je to v podsatě vytahování properties z objektů).
[done]

TODO: Prozkoumat (a ideálně použít):
  https://decembersoft.com/posts/say-goodbye-to-relative-paths-in-typescript-imports/
(nejspíš bude stačit baseurl
 - nebude, na serveru to nefunguje a je potřeba nastavit NODE_PATH)
[done]

TODO: Nastavit z-order pro Ship.gebugGraphics.
[done]

TODO: debug čáry by to asi chtělo dát do stejné grupy jako Ship
  (respektive Ship bude group a v ní bude ship_hull, debug_draw a tak),
  abych to rotoval a posouval najednou.
  - musí to být container, s grupou se nedá hejbat.
Scene.create()
{
  let group = this.add.group();
  let sprite = this.add.sprite(400, 300, 'phaser');
  
  group.add(sprite);
}
[done]

TODO: Vyrobit classu Phaser/Graphics,
  která bude umět kreslit čáry (a rovnou třeba vykreslist Geometry).
- je otázkla, jestli strokePoints() bude dělat to, co si myslím, ale
  třeba jo. Musím to vyzkoušet.
[done]

TODO: Zdědit FlightScene ze Scene a rozhodit mezi ně kód.
- DEPTH_COSI by asi měly bejt až ve FlightScene.
[done]

TODO: Steně tak asi rovnou vyrobit i FlightSceneContents
[done]


TODO: Zrušit přidávání shipy do scény při creatu scény.
[done]
TODO: Procesit ShipToScene na clientu (přidat ship do scény).
- možný problém: ShipToScene může klidně přijít před vytvořením
  scény (až se bude dýl loadovat, tak to dokonce bude celkem pravděpodobný).
[done]
Co s tím?
- buď si to nabufferovat a zpracovat to až ve chvíli, kdy bude scéna existovat.
  - tohle má výhodu v tom, že se mohou data poslat ještě v průběhu loadování.
- nebo po vytvoření scény poslat na server request.
TODO: Do Scene přidat buffer na přidávání věcí do scény.
  - dokud není scéna vytvořená, dávat ShipToScene do bufferu.
  - při vytvoření zpracovat ShipToScene z bufferu.
[done]

TODO: Na klientu nevyrábět ship rovnou, ale až když mi přijde
  packet s přidáním shipy do scény.
- player se teda asi bude na scénu přidávat rovnou při loginu
  (respektive spíš při EnterGame), ale přidávat se budou i jiný
  entity v průběhu, takže se to neztratí.
(Technicky vzato je to update scény, ale asi je lepší udělat novej typ
 packetu, než dělat komplikovaný vnitřní typy).
[done]

TODO: Mergnout SceneContents a Scene.
- to asi nebyl úplně nejlepší nápad. Teď zas musím ošetřovat každou property
  zvlášť. Mít to sdružený dohromady dávalo smysl.
Takže jinak: Nechat SceneContents, ale jen jako data container, nedávat do
  něj metody. Scéna prostě bude přistupovat přes this.contentns.camera apod.
[done]

TODO: Na serveru vyrábět a posílat paket ShipToScene
- otázka je kdy.
  - asi jako response na přihlášení klienta
    (nejspíš tam, co se bude výhledově posílat LoginRequest či co...
     - hmm, to asi nepůjde, páč komunikace po connectu začíná až tím,
       že user klikne na login button - pak se pošle LoginRequest)
     - takže asi zatím natvrdo do WebSocketServer.onNewConnection.
[done]

TODO: Je blbost posílat geometrii v každém tiku, takže:
- vyrobit packet "Přidávám playera na scénu"
  [done]
  - ShipToScene (přejmenovat to můžu vždycky)
- ten bude obsahovat:
  - geometrii.
    [done]
  - startovní pozici
    [done]
  - co vlastně přidávám
    (to zatím řešit nebudu)
[done]

TODO: Remove unecessary constructors from packet classes.
[done]

TODO: Udělat 'version' static.
[done]
TODO: Nepsat 'version' do paketů a nekontrolovat ji při deserializaci.
[done]

TODO: Možná by v Packetech přece jen nemusel bejt Vector, ale pouze
  {x, y}. Posílalo by se míň dat (a fungovat to asi bude taky)
  - otázka je, jak ten typ pojmenovat. XY? Coords?
  - a kam ho dát? Do Types? Do Packetu, protože se bude používat jen
    v packetech?
  - nebo prostě Packet.Vector...
[done]
- blbý je, že se to musí konvertit ručně, páč Vector se vleze do
  interfacu { x, y }...
Možná teda vyžadovat v constructoru packetů paramety (x: number, y: number)
  místo složeného typu (to zabrání předání a tedy assignování vectoru).
- err, to je taky naprd.
Takže jinak:
TODO: Vrátit do packetů vectory a upravit Serializační kód aby byl výsledek
  míň ukecanej.
[done]

TODO: metoda Vector.setLength();
- normalize
- scale
[done]

TODO: Použít classu Vector všude kde jsou koordináty
- místo GameEntity.Position
  [done]
- místo { x: number, y: number }
  [done]
- místo b2Vec2
[done]

TODO: Fix onBeforeUnload
- když je connection closed nebo closing, nezavírat ji.
[done]

TODO: Naučit Serializable savovat Vectory, aby Vector nemusel bejt zděděnej
  ze Serializable.
- netestováno
[done]

TODO: Vyrobit classu Vector (v Physics)
- Math ne, to by kolidovalo s javascriptovým Math.
[done]

TODO: Rozdělit PlayerInput na MouseInput a KeyboardInput
(nemusel bych dělat komplikovanej vnitřní typ).
[done]

TODO: Vymyslet, jak to udělat s typama
- určitě chci Position (nebo Vector?)
- otázka je, jestli to opravdu má bejt v GameEntity.
  Smysl to sice jakž takž dává, ale GameEntity není ničím zvláštní.
- Možná to hodit do Types?
- Nebo použít Vector (ať se s tím dá rovnou počítat?)
  - asi jo.
- Vector by asi měl bejt Serializable
[done]

TODO: Implementovat "Follow mouse position"
- posílat mouse_position na server
  [done]
- implementovat Steering.seek()
  [done]
- aplikovat steering force na ship
  [done]

Zatím mi ale stačí natvrdo jedno body pro ship, takže to prostě hacknu
  a uvidíme.
[done]

Aktuální TODO:
- umím vyrobit Box2D body (respektive PhysicsBody).
- někde vyrobit world
[done]
- v něm vyrobit body pro ship
[done]
- posílat na klienta pozici a rotaci shipy
[done]
- na klientovi to vykreslovat
  - transformovat souřadnice a rotace
    - tohle nějak záhadně není potřeba
      (nebo to možná dělám a ani o tom nevím. Asi správně zvolená znaménka
        u zatáčení na serveru).
  - setovat pozici a rotaci
[done]

TODO: Zatrhnout prohledávání TODO, DONE a CONTEMPLATION
- možná to rovnou přehodit někam do Users/Rahman
[done]

TODO: Jo a zatrhnout prohledávání Shared/Box2D
[done]


TODO: Dodělat cleanup a refactoring:
.
+Client root (KosmudClient.ts)
+Client/Class
+Client/Gui
+Client/Log
+Client/Net
Client/Phaser
+Client/Protocol
.
+Server root (KosmudServer.ts)
+Server/Class
+Server/FS
+Server/Game
+Server/Log
+Server/Net
Server/Physics
+Server/Protocol
.
+Shared/Utils
+Shared/Class
+Shared/Game
+Shared/Log
+Shared/Net
+Shared/Protocol
+Shared/Utils
.
(ve zbytku se vrtám)
[done]

TODO: Zavést classu GUI a v ní metodu init().
[done]

TODO: Opravit poslední commit.
[done]

TODO: PhaserEngine přejmenovat na DisplayEngine
  (nebo RenderEngine, nebo tak něco)
  - možná prostě Renderer?
- zatím přidán Renderer, který vlastní PhaserEngine. Časem to určitě
  budu refactorovat dál.
[done]

TODO: Zvážit, jestli v Game.start() spíš nepustit jen jeden timer
  a z něj pak volat všechno ostatní.
  (60 tiků za vteřinu je blbý číslo btw, bude se s tím špatně počítat...
   na druhou stranu je to rozumný strop fps).
- Každopádně to jsou entry-level funkce a je tam potřeba reportovat uncaught
  exceptiony [to je DONE].
[done]

TODO: Updatnout commenty v Application, Client a Server.
- všechno smazáno, takže asi done :-)
[done]

TODO: Přesunout FileUtils na Server (Client je nepotřebuje).
- mergnul jsem to do FileSystem.
[done]

TODO: Return values ve StringUtils
[done]

TODO: Rozdělit Utils na víc souborů.
- stringové fce
- souborové fce
  - ty by asi mohly jít do FS (už je tam isValidFileName()).
TODO: Zamyslet se, co se zbytkem Utils
  (mělo by to mít specifičtější pojmenování.)
- zatím to vypadá, že 'Utils' bude asi nejlepší...
- ...
[done]

TODO: Vyhodit z Utils ERROR a FATAL_ERROR (a vůbec ho celý projít).
- nahradit je exceptionama.
[done]

TODO: Asi sloučit classy Client a KosmudClient, Server a KosmudServer.
[done]

TODO: Potenciální problém - 'entities' asi budou muset bej v Application
  místo v Entities, protože se k nim musím dostat
  v Serializable.readEntityReference a v Serializable nejdou importnout
  Entities.
- Možná si metodu GetEntities() { return Entities.entities; } hodit někam
  do Utils.
(zatím to přeložit jde. Nechám si to tu, až budu zprovozňovat Entities)
TODO: Ještě jednou se zkusit obejít bez .entities v Application. Šlo
  by pak zrušit instancování klientu a serveru (dělá to Syslog, to stačí).
[done]

TODO: Rozdělit MessageType na Syslog.MessageType a zbytek.
  (mimo jiné se nebude muset všude se Syslogem importovat ještě MessageType).
- ten "zbytek" navíc zatím nejspíš nebudu potřebovat, takže prostě
  vyrobit Syslo.MessageType a MessageType zrušit.
[done]

TODO: Try-catchnout všechna volání serialize() a deserialize().
- ještě to zkontrolovat
[done]

TODO: Refactorovat Connectiony a WebSockety.
+/Shared/Net/PacketHandler.ts
+/Shared/Net/Socket.ts
+/Shared/Net/WebSocketEvent.ts
+/Server/Net/Connection.ts
+/Server/Net/Connections.ts
+/Server/Net/HttpsServer.ts
+/Server/Net/Socket.ts
+/Server/Net/WebSocketServer.ts
+/Client/Net/Connection.ts
+/Client/Net/Socket.ts
[done]

TODO: Obecněji pořešit posílání packetů do closed connection.
  (i když nejvíc to vadilo u "client closed browser tab" message,
   páč tam problikla exception těsně před zavřením tabu)
[done]

TODO: Pořešit Client/Connection.reportClosingBrowserTab()
- info je v commentu
[done]

[UNCAUGHT_EXCEPTION] Failed to send packet to websocket (/ [::ffff:195.113.180.1
95]). Reason: WebSocket is not open: readyState 2 (CLOSING) (this exception has
propagated to top-level function. It needs to be caught much deeper where the er
ror can be properly recovered from.)
    at ServerSocket.send (D:\svetlym\tmp\00\Brutus\Kosmud\Src\Server\Net\ServerS
ocket.ts:69:13)
    at Connection.send (D:\svetlym\tmp\00\Brutus\Kosmud\Src\Server\Net\Connectio
n.ts:184:17)
    at Function.broadcast (D:\svetlym\tmp\00\Brutus\Kosmud\Src\Server\Net\Connec
tions.ts:52:18)
    at Function.updateClients (D:\svetlym\tmp\00\Brutus\Kosmud\Src\Server\Game\G
ame.ts:67:19)
    at Timeout.start.setInterval [as _onTimeout] (D:\svetlym\tmp\00\Brutus\Kosmu
d\Src\Server\Game\Game.ts:37:20)
    at ontimeout (timers.js:425:11)
    at tryOnTimeout (timers.js:289:5)
    at listOnTimeout (timers.js:252:5)
    at Timer.processTimers (timers.js:212:10)
- zaprvé musím testovat, jestli je connection CLOSING
  (to nejspíš souvisí s testováním connection.isOpen()
   v Connections.broadcast)))
[done]
- zadruhé musím tyhle exceptiony někde odchytávat.
[done]

TODO: Client musí nějak ošetřit disconnect
  (aby pak neházel errory jako
   'Uncaught Error: Failed to send data to the server because the connection
    is closed')
- jsou tam alerty a exeptiony by mělo pořešit neposílání paketů do closed
  connection.
[done]

TODO: Event handlery v Keyboard jsou top-level fce, měly by asi volat
  Syslog.reportUncaughtException().
- done, ale výhledově to chce keyboard handling komplet přepsat.
[done]

TODO: Projít všechny výskyty send() a zajistit, že se testuje isOpen().
  A přidat taky exception handling. Connection.send() hází výjimky.
- v Keyboard() je to done.
[done]

TODO: send() a receiveData() by asi vůbec neměly catchovat exceptiony
  (respektive receiveData() možná jo, ta se volá interně z callbacku,
   ale send() volá někdo jinej a ten by asi měl exception dostat).
- Jasně. A onReceiveMessage() už pak reportí jen uncaught exception
  pro případ, že by ji někdo nezhandlil sám.
[done]

TODO: Pořešit rethrow v ServerSocket.send()
  (a asi i v ClientSocket)
[done]

TODO: Musí být connection.receiveData() public?
- jestli se to volá ze socketu, tak sloučením Socketu a Connection
  by callback vidě na private receiveData().
[done]

TODO: Asi bych to mohl udělat tak, že Connection zdědím z WebSocketu
- díky tomu to pořád bude separated code, ale nebudu muset řešit
  alokaci websocketu a budu mít protected přístup na receiveData().
[done]

TODO: Connections.broadcast() musí testovat, jestli jsou
  connectiony otevřené.
[done]

TODO: V ClientSocket (a nejspíš i ServerSocket) je pořád spousta ERROR()
  callů. Zkontrolovat, jestli to nemají být exceptiony.
[done]

TODO: ještě jednou mrknout na connection.send(packet), jestli by to nemělo
  bejt v PacketHandleru (musí se tomu dát serialize mode, takže asi ani
  nemůže, ale mohlo by to tam bejt aspoň abstract).
[done]

TODO: Přesunout connection instance na Clientu do Connection.
[done]

TODO: Posílání PlayerInputu prohnat fcí, která otestuje, jeslti je connection
  open.
[done]

TODO: Alerty o disconnectech (momentálně je to nejjednodušší).
[done]

TODO: Shared.Connection by se asi mělo jmenovat jinak.
[done]

TODO: Refactorovat WebSocketServer
[done]

TODO: Exceptiony ve FileSystem.
[done]

TODO: Vyzkoušet webpack
- pomalé, žere class names. Zatím nebrat
[done]

TODO: Použít Express (kvůli security)
[done]

TODO: HttpServer by se asi rovnou mohl jmenovat HttpsServer...
[done]

TODO: Refactorovat HttpServer
[done]

TODO: Zkontrolovat, že http server neservuje soubory mimo www-root.
- to zařídí express
[done]

TODO: Neservovat data, když je https server closed.
- hmm to asi nepůjde, když to teď dělá express.
- takže možná zrušit .open
(když to někdy bude potřeba, tak se to dá napsat dodatečně)
[done]

ERROR()
--------
.
Pokud nechám ERROR(), asi by se dalo použít tohle:
https://www.bennadel.com/blog/2828-creating-custom-error-objects-in-node-js-with-error-capturestacktrace.htm
.
  In the V8 engine, the stacktrace of an error is gathered using the
  Error.captureStackTrace() method:
  .
    Error.captureStackTrace( errorObject, localContextFunction )
  .
  This method injects a "stack" property into the first argument and,
  optionally, excludes the localContextFunction from the stacktrace.
  So, for example, if we were to generate the stacktrace inside of an
  error Factory function, we could tell V8 to exclude the factory function
  when generating the stack. This would reduce the noise of the error
  implementation and confine the stacktrace to meaningful information
  about the error context.
[done]

TODO: Otestovat reportování errorů.
[done]

TODO: Vyzkoušet ERROR() a REPORT() i na klientu.
[done]

TODO: Někde v kódu mám RERORT(new Error("test"));
- už snad ne
[done]

TODO: Reportování errorů a exceptionů je pořád divný.
- snad fixed
[done]

TODO: Odstranit testovací kód na ERROR() a REPORT() ze serveru a z klienta.
[done]

TODO: Když se stejně nakonec na zobrazení errorů volá Syslog,
  nebylo by lepší udělat polymorfní jen ten, místo Application?
  - respektive neprovolávat ty reporting funkce přes Application.
    (Tam to moc nepatří).
  - application je zatím taky singleton, možná to bude potřeba
[done]

TODO: Asi jsem rozbil tikání physics enginu a posílání updatů.
- to bylo nejspíš tím, že mi utekla uncaught exception. Client
  se tím zřejmě taky zastaví.
[done]

TODO: Updatnout commenty v ERROR (a vůbec v celém reportovacím kódu).
[done]

TODO: Z Utils oddělit ještě FileUtils.
[done]

TODO: FATAL_ERROR() by neměl bejt v Shared kódu (na klientu nedává smysl).
  A možná by šel vyhodit úplně.
- zrušen kompletně
[done]

TODO: Extra házení EXCEPTION_CAUGHT možná není úplně dobrý, protože tam
  není uvedeno, jaká exception byla chycena. Asi by to fakt měl bejt jeden
  message.
[done]

TODO: Mrknout ještě na REPORT() a logování catch message.
[done]

TODO: Testnout additional message u RERPORT().
[done]

TODO: Funkce ze StringUtils by se měly volat jak StringUtils.něco
  (ať je jasný, že to je z externího modulu).
[done]

TODO: Otestovat, jestli getTrimmedStackTrace() správně trimuje stack trace.
- otestováno při hození erroru.
- Klient to nepoužívá, hází místo toho exception.
[done]

TODO: Zvážit, jestli úplně nezrušit ERROR a nenechat jen syslog.
- Nakonec ne, viz třeba ClientSocket. Entry point funkce rovnou reportují,
  nemá smysl, aby házely exception.
[done]

TODO: Nahradit fs-promise něčím jiným
  npm WARN deprecated fs-promise@2.0.3: Use mz or fs-extra^3.0 with Promise Support
[done]

TODO: Everything is brutally slow now. Need to investigate what has happened.
  (fs-extra probably causes this).
- never mind, it works fine.
[done]

TODO: Serializable by nemělo nic vědět o entitách.
  - Entity by si měly přetížit metodu na serializaci/deserializaci properties.
- Nakonec jsem deserializování referencí na entity nechal v Serializable,
  aby šly házet reference na entity do non-entity class (a serializovat je
  jako reference).
[won't do]

Ok, seriózní TODO: Zprovoznit pohyb lodě tak, že na serveru to bude physics
  body v matter.js a na klienta se bude posílat aktuální pozice a rotace.
- importnout na serveru Matter.js
  [done]
- vytvořit testovací body pro ship
  [done]
- nasimulovat wsad (speed, rotation, position).
  (Zatím nic moc, ale tohle teď skipnu, s tím si bude lepší hrát s vizuální
   odezvou.)
- ukrást websockety z BrutusNext
[done]
- ukrást Serializable z BrutusNext
[done]
- posílat pozici a rotaci a zobrazovat to na klientu.
[done]
- posílat keyboard eventy (nejspíš už přeložené na herní akce?)
[done]

TODO: Velocity vector se musí updatovat spolu s rotací lodě.
- pamatovat si velocity (scalar value) starnou a velocity vector
  z ní počítat každej update().
[done]

TODO: Hodit funkce na práci s typy z Utils do Types.
[done]

TODO: Uklidit v Serializable public, protected atd.
[done]

TODO: Updatnout úvodní pokec v Serializable.
[done]

TODO: Vrátit se k jednoduchému modelu shared-only a data-only packetů
  a processPacket() udělat jako externí kód se switchem na className packetu.
- Zrušit Server/Protocol a Client/Protocol
- Zrušit IncomingPacket a OutgoingPacket.
- Classy XXXData přejmenovat na XXX.
- napsat processPacket() na serveru.
- napsat processPacket() na klientu.
[abandoned, reverted]

TODO: Vyhodit z gitu zkompilovaný kód.
[done]

TODO: Přejmenovat adresáře Client/js, Server/js, atd. (na CamelCase)
[done]

TODO: Objekty ve scéně by měly být v classe, která se celá
  nainstancuje ve Scene.create(), ať nemusím testovat, jestli to existuje.
  - problém je, že některé věci se vyrábí v preloadu...
    Preload s konkrétními sprity nesouvisí - z jedné textury se dá vyrobit
    milión lodí. 
[done]