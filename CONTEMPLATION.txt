
-----------------------------------------------------------------------

TODO: Zvážit, jestli se na ERROR() nevyprdnout úplně.
- v browseru stejně nakonec skončím vyhozením výjimky.
- stejně chci nakonec logovat i exceptiony.
- throw Error() má správně stack a není třeba nic uřezávat.
Vlastně jediné použití ERRORU() co mě napadá, je, když chci něco
  jen zalogovat a pokračovat dál ve fci (throw je jako return);
ZÁVĚR: Zkusím co nejvíc používat throw Error().


Pozn.: Nehybnost backgroundu by šla kromě scrollFactoru 0 vyřešit
  ještě tím, že by se renderoval do samostatné scény. Viz sceneManager.
  (Pokud budu mít ui, tak na to asi stejně dojde).


-----------------------------------------------------------------------

Úvaha o referencích na entity:

- reference by se získávaly přes:
    Entities.getReference(whoAsks, whatDoesHeWant, whereIsReferenceWritten);

- Entities by si zapamatovaly toho, kdo si o referenci žádá (do seznamu
  žadatelů) a odkazovanou entitu (do seznamu odkazovaných entit), případně
  by to mohly mít entity poznamenané u sebe (seznam koho referencují a kdo
  je referencuje).
    Když se entita maže, tak musí tyhle seznamy projít a vyhodit se z nich,
  plus odkazovaná entita zapíše do všech referencí na sebe 'null';

- getReference bude vracet typ Entity | null. Díky tomu typescript vynutí
  kontroly na null při každé manipulaci s referencí.

Downside: Pořád nebude zaručeno, že si někdo nesavne referenci přímo,
  místo aby si ji vzal přes Entities.getReference(). Tudíž je otázka,
  jestli celé tohle cvičení má smysl.
- na druhou stranu když si vzpomenu vzít si referenci správně, tak mě
  pak typescript donutí všude psát null checky, když s ní budu manipulovat.

Problém s implementací by mohl být, jak předat, kam se reference zapisuje.
  Když předám getReference(this.badPlayer), tak se předá hodnota, tj.
  nejspíš 'null' nebo co zrovna v té property bude. Musel bych předat
  getReference(this, 'badPlayer') - což je problém, protože nemám string
  s názvem proměnné.

- Předávání referencí by vyřešilo, kdyby entita nebyla pověšená přímo
  v property (třeba .ch), ale až v .ch.ref. Ta by navíc asi mohla bejt
  skrytá za Proxy, takže by se to používalo normálně. Když bych pak chtěl
  tuhle referenci vynulovat, tak bych zapsal ch.ref = null.

Otázka je, jestli tohle všechno má vůbec smysl. Zresetování properties
  mazané entity sice nezajistí kontrolu ze strany typescriptu (to by musely
  všechny properties všech entit být typu (Cosi | null)), abych vždycky musel
  kontrolovat, že nepřistupuju na neexistující property, ale vyhodí výjimku,
  takže se to v runtimu dozvím.
- fakt teda je, že kontrola už v compile timu je výrazně lepší - odhalí
  i případné chyby se vzácným výskytem.

-----------------------------------------------------------------------

Mixiny (vícenásobná dědičnost)
--------------------------------


TODO: Vyzkoušet npm/mixin
- asi nebrat, typescript si s tím nerozumí.

Typescriptové mixiny fungují tak, že je možné funkcí přidat properties
  na libovolnou classu - to by teoreticky mohlo fungovat taky, až na to, že
  ty přidávané properties nemohou mít vlastní strom dědičnosti, a že to má
  dost divnou syntaxi...

http://justinfagnani.com/2015/12/21/real-mixins-with-javascript-classes/
- class MyClass extends mix(MyBaseClass).with(Mixin1, Mixin2) {  
  /* ... */
}

Tohle by mohlo být zajímavé:
(viz https://github.com/Microsoft/TypeScript/pull/13743#issuecomment-414547593)

// Helper code:
/// Odtud by se brala funkce Mixin()...

export type Constructor<T = {}> = new (...args: any[]) => T;

/* turns A | B | C into A & B & C */
type UnionToIntersection<U> =
	(U extends any ? (k: U) => void : never) extends ((k: infer I) => void) ? I : never

/* merges constructor types - self explanitory */
type MergeConstructorTypes<T extends Array<Constructor<any>>> =
	UnionToIntersection<InstanceType<T[number]>>;

export function Mixin<T extends Array<Constructor<any>>>(constructors: T): Constructor<MergeConstructorTypes<T>> {
	const cls = class {
		state = {
		}
		constructor() {
			constructors.forEach((c: any) => {
				const oldState = this.state;
				c.apply(this);
				this.state = Object.assign({}, this.state, oldState);
			});
		}
	} as any;
	constructors.forEach((c: any) => {
		Object.assign(cls.prototype, c.prototype);
	});
	return cls as any;
}

/// And the implementation.....


export class FooMixin {
	state = {
		value: ""
	}
	getBlah() {
		return "Blah"
	}
}

export class BarMixin {
	state = {
		othervalue: "merge together"
	}
	getBar() {
		return "Bar"
	}
}

export class FooBar extends Mixin([FooMixin, BarMixin]) {
	constructor() {
		super();
		this.getBlah = this.getBlah.bind(this);
		this.getBar = this.getBar.bind(this);
	}

	test() {
		this.state.value  // here on the typings good :)
		this.state.othervalue // here on the typings good :) this proves the merge strategy for state
		this.getBar(); // here :)
		this.getBlah(); // here :)
	}
}

- Vypadá to moc hezky, ale nefunguje to, protože na constructoru se nedá
  zavolat apply ani call.
    Tzn. řádka:
      c.apply(this);
    hodí exception.


-----------------------------------------------------------------------